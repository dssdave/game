<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>SNES-Style RPG (Tile-Based, Single File)</title>
  <!-- Allow data: URIs and inline scripts/styles. This is important for GitHub Pages. -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: 'unsafe-inline';">
  <style>
    body {
      margin: 0;
      background: #333;
    }
    canvas {
      display: block;
      margin: 20px auto;
      background: #000;
      image-rendering: pixelated; /* retro look */
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="640" height="480"></canvas>

<script>
"use strict";

/**
 * SNES-Style RPG Example (Tile-Based)
 * Single-file version with embedded images and CSP allowing data: URIs.
 * 
 * - Arrow keys to move the princess.
 * - Collect coins & flowers on the map.
 * - Enter the "castle" door to go inside, exit door to come back out.
 * - If you see a black screen, press F12 and check the Console for errors.
 */

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Dimensions
const TILE_SIZE = 32;
const MAP_WIDTH = 20;   // in tiles
const MAP_HEIGHT = 15;  // in tiles

// Game states
const STATE_TOWN = "town";
const STATE_INTERIOR = "interior";
let gameState = STATE_TOWN;

// Player
const player = {
  x: 9 * TILE_SIZE, // start near middle
  y: 7 * TILE_SIZE,
  width: 32,
  height: 32,
  speed: 2
};

// Counters
let coinsCount = 0;
let flowersCount = 0;

// Keyboard input
const keys = {};
window.addEventListener("keydown", e => { keys[e.key] = true; });
window.addEventListener("keyup", e => { keys[e.key] = false; });

// --------------------------------------
//  BASE64-ENCODED PNG IMAGES
// --------------------------------------
const imageURLs = {
  princess:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABZklEQVRYCe2XMU8DQRCFf0UpExWSiARLJAIlIKAi1ElM8AuVAIlYgQp8ARZ0AlVEI1IJYlJKFoh8Ai1+caZ7aXc3+vdmZXg++SwOybl9nZ+9OACPMc5LOs0SXsx0yZ6K40JeEI6a8zA0Mg88+0HnMcmEEimcRkDd8wH3ZwhAiU9ANHGFu+4ZcIR6F7CaBBcQfrj3Z6/ju2YBR31FyxEUfprPnjHnHG5rUnEMytMXUgXq5lfaQxiUZLS2esr+9koZTr1iTAFaacAfMYfInbR2vFUfe1UPMnt9A/fv4QOlpRzWYM7z7I8jAH9k9rMYrC2bnZX/nwjv7dwdZV81A/jSH+2Wg9MzE8ds87vZ90O6LDZy0Ne7QF64jrKyx6hCb+Tu2uW6SoXoQCY/SAO1gK/QCLOg2+ACNMd1Z0Sa5uAAAAAElFTkSuQmCC",

  // A simple coin (16x16)
  coin:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABXElEQVQ4EZXRv2sTYRjH8c/VKkpqJAlNs7MRMmiCJNJ9k5cAGskXw4pEdXqCDNypgpoOKSgKVJC2No1yBItBE6hAnBRZBAtEpYQc4BYIkh08o9n5mX/O8nIGCEqTTvGmS6noyDc5RXX5CO1swBR0yH3V/FTw6l0SaM+B1p2pBjco9vQRoTwGn2X6+phbKWqJzM5Bp3jjIQyQhz7u5h8vB3M7lZ8svwh+Qw0/xroFxPLx5DImPIr+M74GnSH0C5Y1wTrk5RtiNEplEu6hxHkOkHcbE/1r+N8jHbLCnkH+LL6s+QdU65hEGhZxdD9Z4C6Lva3wEwGTCnkJpHfKyIu4Rq0BicFLG0VfKo+UB7NfVe9B3jNex2hNTI55EZQ7HNYDT5z5C1Y6A63eEB/WuVgUL8uWn8OmBPe/tUBDX7rYb94vwc1jKcvafgAI/2WRz1QvwXG9VVF3vMzBgAAAABJRU5ErkJggg==",

  // A simple flower (16x16)
  flower:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAt0lEQVQoz2NgGAWjgHsgBhA8/2B/gMsWAf5k8z9q+X8tAS6Y8T+7/d1uQmWgU4XBAEGWzT6W2IFm9wgyQCUAWhlOMIctkAHRM9uQ/G+LY3G1LCB/5whWA7IZIK2bFZwhS2Q8E4m9g+0Z+PnSg3OfHzPw/GSo47OJ+6Tr4YM+F9Sl8ZtXh7n95Bw3rhDwZc1QBAgwABV9mtiRacqNAAAAABJRU5ErkJggg==",

  // 32x32 grass tile
  tileGrass:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAyUlEQVQ4Ea3UoQ2CQBTH8YcUVzUMkI3qvAEqfYBOfzYg3rArUPUKKCgdiATDdr8YedneHaR/H3vAC7A9UQB4FXdvVX3sv3F0ZDWzKoyAGhUh3ey6BWB7TmmBMr2in5Z99S3PUd12x7eW0PHk2B6ySS70Z0d7yaKGKnFoRMQGwixTT5v4+Hta9rsQpZr9rHeCVSl4gmdHGZqXd7NnF6+eKpEqCPzo61Xb0+RfRCKAiAyZcoAAAAASUVORK5CYII=",

  // 32x32 path tile
  tilePath:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAvklEQVQ4EZXQMQrCQAxF0ZqBH6ANp1fAevZEQdxFW1gDHYGbwBVDXAuO1g7ZqJ+KAc5Hb1u94Nz5AiUBETC9CAXn6Xz1X5t9d1TAiwbI10GL6+5Y0rC6npgSXNnqAq4EMB62uUX7XU8lmstF1IoIP7sSlblEgozEkg6Y3nsEfz5/lscB9KCCfep+e4bOPOOWc6k4MGkZaH+RZ8b7+wZg4psCEvbfSXAAAABJRU5ErkJggg==",

  // 32x32 "castle" tile (for the wall)
  tileCastleWall:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAr0lEQVQ4EZWUMQ6CQAxFz6oE6IMfCVft3BSdQKQcsFXcCF6fLa+2I10uFBvMRv4vMCpBAg9WOmKRQ1K3QyTXkhe2ANyHT3YCS69A74ICFZm26D0b3bgCJeUCX6zD21/mGl30FKT5jA9w6G0ID+6LJABcRYBnOKHMEhpf8vYfZ2qOVCk3f3pH7ORWZSh/TfSgE3EwXoHZ9t1CP8EiBRP0rJG7yAAAAAElFTkSuQmCC",

  // 32x32 "roof" tile
  tileHouseRoof:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAqElEQVQ4EYWUQQrAIAxG3/gLb9kpaN2v4eAsldmXh0gnIQ5Cwp8Gc9omdwv0RzwZZgy1l3S09EnxTrM64BTDJ8BRz0i4q8G3a0SM8KT9mMBeHsvWRrgjTM+pISVu5dM/k2Qy7tYAYf4zvud8o1cw/PvOGQH0lE4AC6IZ2Q36ObJIFAIYND/wC+oVnHeCDrAwAAAABJRU5ErkJggg==",

  // 32x32 door tile
  tileDoor:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAh0lEQVQ4EZWV0QmAMAxE3bCLdH9yW6TxqjMHpnmg7q0gNFIkIhZogfZeAZNnF8zb2ZgW6gC4iGSVeAUw1PQAi7JCHoVQf7hMA95fA3irxAg8lI5kPgLPPGe0BJeOkGBRNn9QCjkPB7N99evf7f5fQ2gV3lYrnYGQncSLg2iPYfAUc4J4xJsAAAAASUVORK5CYII=",

  // 32x32 floor tile (interior)
  tileFloor:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAu0lEQVQ4Ea3UsQ2CMBRF0YXwaRyBpL2cXq7LHLsC2a7DYbJDdnobCINdXEmkO8/gAUu4HgfZBH4zUBYTxX4EODhnk4JP3e9n51Mke3W8n/IxdIEtIfIXSTvTnPVDa/Ch9yx6T/rDBh9nc10cknrgzjThTeSMuUclzvCk6leZXc+Znk5CRFUTIYSN2IGKn6jCbSV3gXy7ZmPbvL80b39FuWY7AHyz7fnn3Y8wAAAABJRU5ErkJggg==",

  // 32x32 interior wall
  tileInteriorWall:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAq0lEQVQ4EYWUMQ6CQBBFz6oE6INocpN7BzZzSlgqKJY0DW4ECIJB5KfZa/VCtH/g6HeBe9sl7E6eh0LaqQ0peQT9n4EXAc00heMKmSNRDwqg9tUFJhI3EW7O0y37I7z7SBx61d0C9aYPf3S7AqjCdW1en8TEX7a0kQbOv+vD+fIzPUenSm58vf5y5kECOK69F0Xb0plAAAAAElFTkSuQmCC",

  // 32x32 interior exit door
  tileExitDoor:
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAqklEQVQ4EYWUPQ6CQBBE/1pMTmxItLZGuA0yEIcRRiSI0gaJLSRPSQ1p9vArT3QGTyA2Dys2nyIhx05BNPnzvIr3pl4MDwgw7LwMT4gZ0gB2Z8tI9FEsuTZR+LodKN0kWcvKMT8DcT7wrnK21cs6/gFFP2SWZdsQ6a+4w7n+evpP+9H6/nf4AS/94Qwk7vI0BkETTbf1n0Znu1X5eZQPxrgE9woLEOJdgAAAABJRU5ErkJggg=="
};

// TOWN map data (20 wide x 15 high).  Each cell is an integer referencing a tile in `tilesTown`.
const mapTownData = [
  [2,2,2,2,2,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0],
  [2,0,0,1,1,1,0,0,0,0, 0,0,0,0,0,0,0,0,0,0],
  [2,0,0,0,0,1,0,0,0,0, 0,0,0,0,0,0,0,0,0,0],
  [2,0,0,0,0,1,1,1,1,1, 1,1,0,0,0,0,0,0,0,0],
  [2,4,0,0,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0,0],
  [2,2,2,2,2,1,1,1,0,0, 0,1,0,0,0,3,3,3,3,3],
  [0,0,0,0,1,1,0,1,0,0, 0,1,0,0,0,3,3,3,3,3],
  [0,0,0,0,1,1,0,1,1,1, 1,1,0,0,0,3,4,3,3,3],
  [0,0,0,0,1,1,0,0,0,0, 0,1,0,0,0,3,3,3,3,3],
  [0,0,0,0,1,1,1,1,1,1, 1,1,0,0,0,3,3,3,3,3],
  [0,0,0,0,1,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,1,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,1,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,1,1,1,1,1,1, 1,1,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0]
];
// 0=grass, 1=path, 2=castleWall, 3=roof, 4=door
// We'll treat castleWall=2 and roof=3 as blocked. door=4 is not blocked (to allow stepping on it).

// INTERIOR map data
const mapInteriorData = [
  [1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1],
  [1,2,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1]
];
// 0=floor, 1=interiorWall, 2=exitDoor

// We map these indices to image keys:
const tilesTown = {
  0: "tileGrass",
  1: "tilePath",
  2: "tileCastleWall",
  3: "tileHouseRoof",
  4: "tileDoor"
};

const tilesInterior = {
  0: "tileFloor",
  1: "tileInteriorWall",
  2: "tileExitDoor"
};

// Which are blocked?
function isTownBlocked(tileIndex) {
  // castleWall=2 or roof=3 => blocked
  return (tileIndex === 2 || tileIndex === 3);
}
function isInteriorBlocked(tileIndex) {
  // interiorWall=1 => blocked
  // exitDoor=2 => not blocked
  return (tileIndex === 1);
}

// Some items placed in the TOWN map at tile coords:
let items = [
  { type: "coin",   x: 6,  y: 5,  collected: false },
  { type: "coin",   x: 10, y: 8,  collected: false },
  { type: "flower", x: 12, y: 4,  collected: false },
  { type: "coin",   x: 8,  y: 12, collected: false },
  { type: "flower", x: 3,  y: 8,  collected: false }
];

// Load all images
const images = {};
function loadImages(callback) {
  const keys = Object.keys(imageURLs);
  let loaded = 0;
  for (let k of keys) {
    const img = new Image();
    img.onload = () => {
      loaded++;
      if (loaded === keys.length) {
        console.log("All images loaded!");
        callback();
      }
    };
    img.onerror = () => {
      console.error("Failed to load image:", k);
      loaded++;
      if (loaded === keys.length) callback();
    };
    img.src = imageURLs[k];
    images[k] = img;
  }
}

// MAIN LOOP
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

function update() {
  if (gameState === STATE_TOWN) {
    updateTown();
  } else {
    updateInterior();
  }
}

function updateTown() {
  const oldX = player.x;
  const oldY = player.y;

  if (keys["ArrowUp"])    player.y -= player.speed;
  if (keys["ArrowDown"])  player.y += player.speed;
  if (keys["ArrowLeft"])  player.x -= player.speed;
  if (keys["ArrowRight"]) player.x += player.speed;

  // Boundaries
  if (player.x < 0) player.x = 0;
  if (player.y < 0) player.y = 0;
  if (player.x > (MAP_WIDTH * TILE_SIZE - player.width)) {
    player.x = MAP_WIDTH * TILE_SIZE - player.width;
  }
  if (player.y > (MAP_HEIGHT * TILE_SIZE - player.height)) {
    player.y = MAP_HEIGHT * TILE_SIZE - player.height;
  }

  // Collision with blocked tiles
  if (collidesWithTownBlocked()) {
    player.x = oldX;
    player.y = oldY;
  }

  // Check if on door tile => go inside
  let col = Math.floor(player.x / TILE_SIZE);
  let row = Math.floor(player.y / TILE_SIZE);
  if (mapTownData[row] && mapTownData[row][col] === 4) {
    // Enter interior
    gameState = STATE_INTERIOR;
    // place player near top inside
    player.x = 9 * TILE_SIZE;
    player.y = 7 * TILE_SIZE;
  }

  // Check item pickups
  for (let item of items) {
    if (!item.collected) {
      const ix = item.x * TILE_SIZE + TILE_SIZE/4;
      const iy = item.y * TILE_SIZE + TILE_SIZE/4;
      const iSize = TILE_SIZE/2;
      if (rectOverlap(player.x, player.y, player.width, player.height,
                      ix, iy, iSize, iSize)) {
        item.collected = true;
        if (item.type === "coin") coinsCount++;
        else if (item.type === "flower") flowersCount++;
      }
    }
  }
}

function updateInterior() {
  const oldX = player.x;
  const oldY = player.y;

  if (keys["ArrowUp"])    player.y -= player.speed;
  if (keys["ArrowDown"])  player.y += player.speed;
  if (keys["ArrowLeft"])  player.x -= player.speed;
  if (keys["ArrowRight"]) player.x += player.speed;

  // Boundaries
  if (player.x < 0) player.x = 0;
  if (player.y < 0) player.y = 0;
  if (player.x > (MAP_WIDTH * TILE_SIZE - player.width)) {
    player.x = MAP_WIDTH * TILE_SIZE - player.width;
  }
  if (player.y > (MAP_HEIGHT * TILE_SIZE - player.height)) {
    player.y = MAP_HEIGHT * TILE_SIZE - player.height;
  }

  // Collisions
  if (collidesWithInteriorBlocked()) {
    player.x = oldX;
    player.y = oldY;
  }

  // If on exit door tile => go back to TOWN
  let col = Math.floor(player.x / TILE_SIZE);
  let row = Math.floor(player.y / TILE_SIZE);
  if (mapInteriorData[row] && mapInteriorData[row][col] === 2) {
    gameState = STATE_TOWN;
    // place player just outside door
    player.x = 1.5 * TILE_SIZE;
    player.y = 4 * TILE_SIZE;
  }
}

function collidesWithTownBlocked() {
  // Check the corners of the player's bounding box
  const left = player.x;
  const right = player.x + player.width - 1;
  const top = player.y;
  const bottom = player.y + player.height - 1;

  if (tileBlockedTown(left,  top))    return true;
  if (tileBlockedTown(right, top))    return true;
  if (tileBlockedTown(left,  bottom)) return true;
  if (tileBlockedTown(right, bottom)) return true;

  return false;
}

function tileBlockedTown(xPix, yPix) {
  const col = Math.floor(xPix / TILE_SIZE);
  const row = Math.floor(yPix / TILE_SIZE);
  if (row < 0 || row >= MAP_HEIGHT || col < 0 || col >= MAP_WIDTH) return true;
  const tileIndex = mapTownData[row][col];
  return isTownBlocked(tileIndex);
}

function collidesWithInteriorBlocked() {
  const left = player.x;
  const right = player.x + player.width - 1;
  const top = player.y;
  const bottom = player.y + player.height - 1;

  if (tileBlockedInterior(left,  top))    return true;
  if (tileBlockedInterior(right, top))    return true;
  if (tileBlockedInterior(left,  bottom)) return true;
  if (tileBlockedInterior(right, bottom)) return true;

  return false;
}

function tileBlockedInterior(xPix, yPix) {
  const col = Math.floor(xPix / TILE_SIZE);
  const row = Math.floor(yPix / TILE_SIZE);
  if (row < 0 || row >= MAP_HEIGHT || col < 0 || col >= MAP_WIDTH) return true;
  const tileIndex = mapInteriorData[row][col];
  return isInteriorBlocked(tileIndex);
}

// Quick rectangle-overlap check
function rectOverlap(x1,y1,w1,h1, x2,y2,w2,h2) {
  return !(
    x1 > x2 + w2 ||
    x1 + w1 < x2 ||
    y1 > y2 + h2 ||
    y1 + h1 < y2
  );
}

// DRAW
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (gameState === STATE_TOWN) {
    drawMapTown();
    drawItems();
  } else {
    drawMapInterior();
  }

  // Draw player
  ctx.drawImage(images.princess, player.x, player.y, player.width, player.height);

  // UI
  ctx.fillStyle = "black";
  ctx.font = "16px Arial";
  ctx.fillText("Coins: " + coinsCount, 10, 20);
  ctx.fillText("Flowers: " + flowersCount, 10, 40);
}

function drawMapTown() {
  for (let row = 0; row < MAP_HEIGHT; row++) {
    for (let col = 0; col < MAP_WIDTH; col++) {
      const index = mapTownData[row][col];
      const tileKey = tilesTown[index];
      const tileImg = images[tileKey];
      if (tileImg) {
        ctx.drawImage(tileImg, col * TILE_SIZE, row * TILE_SIZE);
      }
    }
  }
}

function drawMapInterior() {
  for (let row = 0; row < MAP_HEIGHT; row++) {
    for (let col = 0; col < MAP_WIDTH; col++) {
      const index = mapInteriorData[row][col];
      const tileKey = tilesInterior[index];
      const tileImg = images[tileKey];
      if (tileImg) {
        ctx.drawImage(tileImg, col * TILE_SIZE, row * TILE_SIZE);
      }
    }
  }
}

function drawItems() {
  for (let item of items) {
    if (!item.collected) {
      const centerX = item.x * TILE_SIZE + (TILE_SIZE - 16)/2;
      const centerY = item.y * TILE_SIZE + (TILE_SIZE - 16)/2;
      if (item.type === "coin") {
        ctx.drawImage(images.coin, centerX, centerY, 16, 16);
      } else if (item.type === "flower") {
        ctx.drawImage(images.flower, centerX, centerY, 16, 16);
      }
    }
  }
}

// LOAD images then start
loadImages(() => {
  console.log("Starting game loop...");
  gameLoop();
});
</script>
</body>
</html>
