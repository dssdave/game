<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Princess Doniaâ€™s Town - Enhanced 3D RPG</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-size: 16px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
      #ballCount {
        position: absolute;
        top: 10px;
        right: 10px;
        color: #fff;
        font-size: 16px;
        background: rgba(0,0,0,0.7);
        padding: 5px;
        border-radius: 5px;
        z-index: 10;
      }
      #dialogue {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: #fff;
        font-size: 14px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
        max-width: 600px;
        z-index: 10;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        color: #fff;
        font-size: 14px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
      #errorMessage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 20px;
        background: rgba(0,0,0,0.8);
        padding: 20px;
        border-radius: 5px;
        z-index: 20;
        display: none;
      }
      /* Joystick containers */
      #joystickLeft,
      #joystickRight {
        position: absolute;
        width: 15vw;
        height: 15vw;
        min-width: 80px;
        min-height: 80px;
        max-width: 100px;
        max-height: 100px;
        opacity: 0.5;
        z-index: 15;
      }
      #joystickLeft {
        bottom: 6vh;
        left: 2vw;
      }
      #joystickRight {
        bottom: 6vh;
        right: 2vw;
      }
      /* Large pop-up for guard / NPC messages */
      #guardPopup {
        position: absolute;
        bottom: 50%;
        left: 50%;
        transform: translate(-50%, 50%);
        color: #fff;
        font-size: 48px; /* 3x bigger */
        font-family: 'Press Start 2P', monospace;
        background: rgba(0,0,0,0.8);
        border: 2px solid #fff;
        padding: 20px;
        border-radius: 5px;
        display: none;
        z-index: 50;
        text-align: center;
      }
    </style>
    <!-- Include Three.js and NippleJS from CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>
      <div id="ballCount">
        Balls Thrown: <span id="ballCountValue">0</span>
      </div>
      <div id="dialogue"></div>
      <div id="controls">
        Controls:<br>
        Joysticks/Arrow Keys: Move<br>
        Joysticks/Mouse: Look Around<br>
        Tap Center/Space: Throw Ball
      </div>
      <div id="joystickLeft"></div>
      <div id="joystickRight"></div>
      <div id="errorMessage">
        WebGL is not supported in your browser. Please use a modern browser.
      </div>
      <div id="guardPopup"></div>
    </div>
    <script>
      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');
        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          throw new Error('WebGL not supported');
        }

        // Basic Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameCanvas.style.display = 'block';

        // Global references for NPC and bird motion
        let npcData = { angle: 0, speed: 0.001, radius: 120, object: null };
        let birdData = { angle: 0, speed: 0.002, radius: 140, object: null };

        class Game {
          constructor() {
            // Game state variables
            this.scene = 'town';
            this.flowers = 0;
            this.coins = 0;
            this.gems = 0;
            this.potions = 0;
            this.keys = 0;
            this.artifacts = 0;
            this.health = 100;
            this.time = 'Day';
            this.dayNightCycle = 0;

            // Player data
            this.player = {
              x: 0,
              z: 0,
              speedKeyboard: 0.1,
              speedJoystick: 0.05,
              yaw: 0,
              pitch: -0.2,
              object: null,
              lastMoveVec: new THREE.Vector3(1,0,0)
            };

            this.dialogue = '';
            this.dialogueTimer = 0;
            this.objects = [];
            this.npcs = [];
            this.ballCount = 0;
            this.thrownBalls = [];
            this.collectionGlow = null;
            this.joystickLeft = null;
            this.joystickRight = null;
            this.keysPressed = {};
            this.sceneObj = scene;
            this.camera = camera;
            this.renderer = renderer;
            this.itemRange = 80;

            // Sun/moon/stars
            this.sunMesh = null;
            this.moonMesh = null;
            this.starsMesh = null;

            // Guard/NPC interaction
            this.guardObject = null;
            this.guardMessageShown = false;
            this.npcMessageShown = false;

            // Initialize everything
            this.initScene();
            this.initJoysticks();
            this.initKeyboardMouse();
            this.startAnimation();
          }

          //==============================
          // Scene Creation Methods
          //==============================
          initScene() {
            // Ground (300 x 300)
            const groundGeo = new THREE.PlaneGeometry(300,300,50,50);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x6bb26b, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = Math.PI/2;
            ground.receiveShadow = true;
            this.sceneObj.add(ground);

            // Sky (gradient using shader)
            const skyGeo = new THREE.SphereGeometry(700,60,40);
            const skyMat = new THREE.ShaderMaterial({
              uniforms: {
                topColor: { value: new THREE.Color(0x87ceeb) },
                bottomColor: { value: new THREE.Color(0x2f4f4f) },
                offset: { value: 0.5 },
                exponent: { value: 0.6 }
              },
              vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                  vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                  vWorldPosition = worldPosition.xyz;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                  float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
                  gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h,0.0), exponent), 0.0)), 1.0);
                }
              `,
              side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.name = 'sky';
            this.sceneObj.add(sky);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            this.sceneObj.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10,20,10);
            dirLight.castShadow = true;
            this.sceneObj.add(dirLight);

            // Terrain & characters
            this.createBeach();
            this.createMermaid();
            this.createBird();

            this.createPlayerModel();
            this.createBlueNPC();
            this.createGuardAtCastle();

            this.createBoundary();

            this.createCastle();
            this.createHouse();
            this.createFountain();
            this.createCafe();

            this.createFlowers(10);
            this.createCoins(8);
            this.createGems(4);
            this.createPotions(3);
            this.createKeys(2);
            this.createArtifacts(2);

            this.createSun();
            this.createMoon();
            this.createStars();
          }

          createSun() {
            this.sunMesh = new THREE.Mesh(
              new THREE.SphereGeometry(3,16,16),
              new THREE.MeshBasicMaterial({ color: 0xffee00 })
            );
            this.sunMesh.position.set(0,200,-200);
            this.sunMesh.visible = true;
            this.sceneObj.add(this.sunMesh);
          }

          createMoon() {
            this.moonMesh = new THREE.Mesh(
              new THREE.SphereGeometry(2,16,16),
              new THREE.MeshBasicMaterial({ color: 0xcccccc })
            );
            this.moonMesh.position.set(-100,150,100);
            this.moonMesh.visible = false;
            this.sceneObj.add(this.moonMesh);
          }

          createStars() {
            const starCount = 300;
            const positions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
              const radius = 300 + Math.random() * 200;
              const angle = Math.random() * Math.PI * 2;
              const ySpread = Math.random() * 200 - 50;
              positions[i*3] = Math.cos(angle) * radius;
              positions[i*3+1] = 50 + ySpread;
              positions[i*3+2] = Math.sin(angle) * radius;
            }
            const starGeo = new THREE.BufferGeometry();
            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2 });
            const starField = new THREE.Points(starGeo, starMat);
            starField.visible = false;
            this.sceneObj.add(starField);
            this.starsMesh = starField;
          }

          createBeach() {
            const sandGeo = new THREE.PlaneGeometry(300,30);
            const sandMat = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
            const sand = new THREE.Mesh(sandGeo, sandMat);
            sand.rotation.x = -Math.PI/2;
            sand.position.set(0,0.01,-115);
            this.sceneObj.add(sand);
            this.objects.push({ mesh: sand, type: 'beach', x: 0, z: -115, boundingRadius: 0 });

            const waterGeo = new THREE.PlaneGeometry(300,10);
            const waterMat = new THREE.MeshStandardMaterial({
              color: 0x1E90FF,
              transparent: true,
              opacity: 0.8
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI/2;
            water.position.set(0,0.02,-125);
            this.sceneObj.add(water);
            this.objects.push({ mesh: water, type: 'water', x: 0, z: -125, boundingRadius: 0 });
          }

          createMermaid() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,0.6,16),
              new THREE.MeshStandardMaterial({ color: 0xff69b4 })
            );
            body.position.set(0,0.9,0);
            group.add(body);
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.4,0);
            group.add(head);
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.31,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.3,0);
            hair.rotation.x = Math.PI;
            group.add(hair);
            group.position.set(20,-0.5,-125);
            this.sceneObj.add(group);
          }

          createBird() {
            const bird = new THREE.Mesh(
              new THREE.SphereGeometry(0.5,8,8),
              new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            bird.castShadow = true;
            bird.receiveShadow = true;
            this.sceneObj.add(bird);
            birdData.object = bird;
          }

          createPlayerModel() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,1.2,16),
              new THREE.MeshStandardMaterial({ color: 0xff69b4 })
            );
            body.position.set(0,0.6,0);
            group.add(body);
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.4,0);
            group.add(head);
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.31,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.4,0);
            hair.rotation.x = Math.PI;
            group.add(hair);
            const crown = new THREE.Mesh(
              new THREE.TorusGeometry(0.25,0.05,8,16),
              new THREE.MeshStandardMaterial({ color: 0xffd700 })
            );
            crown.rotation.x = Math.PI/2;
            crown.position.set(0,1.65,0);
            group.add(crown);
            const leftArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1,0.1,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            leftArm.position.set(-0.5,1.0,0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1,0.1,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            rightArm.position.set(0.5,1.0,0);
            group.add(rightArm);
            const leftLeg = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12,0.12,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            leftLeg.position.set(-0.2,0.2,0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12,0.12,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            rightLeg.position.set(0.2,0.2,0);
            group.add(rightLeg);
            group.position.set(0,0.5,0);
            this.player.object = group;
            this.sceneObj.add(group);
          }

          createBlueNPC() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,1.2,16),
              new THREE.MeshStandardMaterial({ color: 0x0000ff })
            );
            body.position.set(0,0.6,0);
            group.add(body);
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.4,0);
            group.add(head);
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.31,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.4,0);
            hair.rotation.x = Math.PI;
            group.add(hair);
            const leftArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1,0.1,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            leftArm.position.set(-0.5,1.0,0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1,0.1,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            rightArm.position.set(0.5,1.0,0);
            group.add(rightArm);
            const leftLeg = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12,0.12,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            leftLeg.position.set(-0.2,0.2,0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12,0.12,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            rightLeg.position.set(0.2,0.2,0);
            group.add(rightLeg);
            group.position.set(120,0.5,0);
            this.sceneObj.add(group);
            npcData.object = group;
          }

          createGuardAtCastle() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,1.2,16),
              new THREE.MeshStandardMaterial({ color: 0x000000 })
            );
            body.position.set(0,0.6,0);
            group.add(body);
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.4,0);
            group.add(head);
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.31,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.4,0);
            hair.rotation.x = Math.PI;
            group.add(hair);
            const leftArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1,0.1,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            leftArm.position.set(-0.5,1.0,0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1,0.1,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            rightArm.position.set(0.5,1.0,0);
            group.add(rightArm);
            const leftLeg = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12,0.12,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            leftLeg.position.set(-0.2,0.2,0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12,0.12,0.8,8),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            rightLeg.position.set(0.2,0.2,0);
            group.add(rightLeg);
            group.position.set(45,0.5,50.5);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type: 'guard', x: 45, z: 50.5, boundingRadius: 3 });
            this.guardObject = group;
          }

          createBoundary() {
            for (let x = -130; x <= 130; x += 4) {
              this.addShrub(x, -130);
              this.addShrub(x, 130);
            }
            for (let z = -130; z <= 130; z += 4) {
              this.addShrub(-130, z);
              this.addShrub(130, z);
            }
          }

          addShrub(x, z) {
            const geo = new THREE.CylinderGeometry(1, 1, 2, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const shrub = new THREE.Mesh(geo, mat);
            shrub.position.set(x,1,z);
            this.sceneObj.add(shrub);
            this.objects.push({ mesh: shrub, type: 'boundary', x: x, z: z, boundingRadius: 2 });
          }

          createCastle() {
            const group = new THREE.Group();
            const keep = new THREE.Mesh(
              new THREE.BoxGeometry(20,10,20),
              new THREE.MeshStandardMaterial({ color: 0xcccccc })
            );
            keep.position.set(0,5,0);
            group.add(keep);
            const towerGeo = new THREE.CylinderGeometry(3,3,15,16);
            const towerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            [[10,7.5,10],[-10,7.5,10],[10,7.5,-10],[-10,7.5,-10]].forEach(pos => {
              const tower = new THREE.Mesh(towerGeo, towerMat);
              tower.position.set(pos[0], pos[1], pos[2]);
              group.add(tower);
            });
            const door = new THREE.Mesh(
              new THREE.PlaneGeometry(4,6),
              new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide })
            );
            door.position.set(0,3,10.01);
            group.add(door);
            // Sign
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black'; ctx.fillRect(0,0,512,128);
            ctx.fillStyle = 'white'; ctx.font = '60px Arial';
            ctx.fillText("Daddy's Castle", 50,80);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex });
            const signGeo = new THREE.PlaneGeometry(12,3);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0,8,10.1);
            group.add(signMesh);
            group.position.set(40,0,40);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type: 'building', x: 40, z: 40, boundingRadius: 15 });
          }

          createHouse() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(
              new THREE.BoxGeometry(10,6,8),
              new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            base.position.set(0,3,0);
            group.add(base);
            const roof = new THREE.Mesh(
              new THREE.ConeGeometry(6,4,4),
              new THREE.MeshStandardMaterial({ color: 0x800000 })
            );
            roof.position.set(0,7,0);
            roof.rotation.y = Math.PI/4;
            group.add(roof);
            const door = new THREE.Mesh(
              new THREE.PlaneGeometry(2,4),
              new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide })
            );
            door.position.set(0,2,4.01);
            group.add(door);
            // Two windows
            const winGeo = new THREE.PlaneGeometry(1,1);
            const winMat = new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            const win1 = new THREE.Mesh(winGeo, winMat);
            win1.position.set(-2,3,4.02);
            const win2 = new THREE.Mesh(winGeo, winMat);
            win2.position.set(2,3,4.02);
            group.add(win1, win2);
            // House sign
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black'; ctx.fillRect(0,0,128,32);
            ctx.fillStyle = 'white'; ctx.font = '20px Arial';
            ctx.fillText("Donia's House", 5,22);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent:true });
            const signGeo = new THREE.PlaneGeometry(4,1);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0,3.8,4.05);
            group.add(signMesh);
            group.position.set(-40,0,-40);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type: 'building', x: -40, z: -40, boundingRadius: 10 });
          }

          createFountain() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(
              new THREE.CylinderGeometry(3,3,1,16),
              new THREE.MeshStandardMaterial({ color: 0x808080 })
            );
            base.position.set(0,0.5,0);
            group.add(base);
            const bowl = new THREE.Mesh(
              new THREE.TorusGeometry(3,0.3,16,32),
              new THREE.MeshStandardMaterial({ color: 0x808080 })
            );
            bowl.rotation.x = Math.PI/2;
            bowl.position.y = 1;
            group.add(bowl);
            const water = new THREE.Mesh(
              new THREE.CylinderGeometry(2.8,2.8,0.2,16),
              new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent:true, opacity:0.6 })
            );
            water.position.set(0,1.1,0);
            group.add(water);
            group.position.set(0,0,20);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type: 'decoration', x: 0, z: 20, boundingRadius: 5 });
          }

          createCafe() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(
              new THREE.BoxGeometry(10,5,8),
              new THREE.MeshStandardMaterial({ color: 0x888888 })
            );
            base.position.set(0,2.5,0);
            group.add(base);
            const door = new THREE.Mesh(
              new THREE.PlaneGeometry(2,3),
              new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide })
            );
            door.position.set(0,1.5,4.01);
            group.add(door);
            // Cafe sign, centered
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0,0,256,64);
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("Donia's Cafe", 128,40);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent:true });
            const signGeo = new THREE.PlaneGeometry(8,2);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0,3.5,4.05);
            group.add(signMesh);
            group.position.set(150,0,-30);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type: 'building', x: 150, z: -30, boundingRadius: 10 });
          }

          //==============================
          // Pickup creation methods
          //==============================
          createFlowers(count) {
            for (let i = 0; i < count; i++) {
              const fx = Math.random() * this.itemRange * 2 - this.itemRange;
              const fz = Math.random() * this.itemRange * 2 - this.itemRange;
              const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05,0.05,1,8),
                new THREE.MeshStandardMaterial({ color: 0x008000 })
              );
              stem.position.y = 0.5;
              const bloom = new THREE.Mesh(
                new THREE.SphereGeometry(0.2,8,8),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
              );
              bloom.position.y = 1;
              const flower = new THREE.Group();
              flower.add(stem, bloom);
              flower.position.set(fx,0,fz);
              flower.castShadow = true;
              flower.receiveShadow = true;
              this.sceneObj.add(flower);
              this.objects.push({ mesh: flower, type: 'flower', isPickup: true, x: fx, z: fz });
            }
          }

          createCoins(count) {
            for (let i = 0; i < count; i++) {
              const cx = Math.random() * this.itemRange * 2 - this.itemRange;
              const cz = Math.random() * this.itemRange * 2 - this.itemRange;
              const coin = new THREE.Mesh(
                new THREE.CircleGeometry(0.3,16),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
              );
              coin.rotation.x = -Math.PI/2;
              coin.position.set(cx,0.01,cz);
              coin.castShadow = true;
              coin.receiveShadow = true;
              this.sceneObj.add(coin);
              this.objects.push({ mesh: coin, type: 'coin', isPickup: true, x: cx, z: cz });
            }
          }

          createGems(count) {
            for (let i = 0; i < count; i++) {
              const gx = Math.random() * this.itemRange * 2 - this.itemRange;
              const gz = Math.random() * this.itemRange * 2 - this.itemRange;
              const gem = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.5,0),
                new THREE.MeshStandardMaterial({ color: 0x00ffff })
              );
              gem.position.set(gx,0.5, gz);
              gem.castShadow = true;
              gem.receiveShadow = true;
              this.sceneObj.add(gem);
              this.objects.push({ mesh: gem, type: 'gem', isPickup: true, x: gx, z: gz });
            }
          }

          createPotions(count) {
            for (let i = 0; i < count; i++) {
              const px = Math.random() * this.itemRange * 2 - this.itemRange;
              const pz = Math.random() * this.itemRange * 2 - this.itemRange;
              const base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3,0.3,0.8,16),
                new THREE.MeshStandardMaterial({ color: 0xffffff })
              );
              base.position.y = 0.4;
              const liquid = new THREE.Mesh(
                new THREE.CylinderGeometry(0.25,0.25,0.6,16),
                new THREE.MeshStandardMaterial({ color: 0xff4500 })
              );
              liquid.position.y = 0.4;
              const potion = new THREE.Group();
              potion.add(base, liquid);
              potion.position.set(px,0,pz);
              potion.castShadow = true;
              potion.receiveShadow = true;
              this.sceneObj.add(potion);
              this.objects.push({ mesh: potion, type: 'potion', isPickup: true, x: px, z: pz });
            }
          }

          createKeys(count) {
            for (let i = 0; i < count; i++) {
              const kx = Math.random() * this.itemRange * 2 - this.itemRange;
              const kz = Math.random() * this.itemRange * 2 - this.itemRange;
              const handle = new THREE.Mesh(
                new THREE.SphereGeometry(0.2,16,16),
                new THREE.MeshStandardMaterial({ color: 0xffd700 })
              );
              const shaft = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1,0.1,0.8,8),
                new THREE.MeshStandardMaterial({ color: 0xffd700 })
              );
              shaft.position.y = -0.4;
              const key = new THREE.Group();
              key.add(handle, shaft);
              key.position.set(kx,0.5,kz);
              key.rotation.x = Math.PI/2;
              key.castShadow = true;
              key.receiveShadow = true;
              this.sceneObj.add(key);
              this.objects.push({ mesh: key, type: 'key', isPickup: true, x: kx, z: kz });
            }
          }

          createArtifacts(count) {
            for (let i = 0; i < count; i++) {
              const ax = Math.random() * this.itemRange * 2 - this.itemRange;
              const az = Math.random() * this.itemRange * 2 - this.itemRange;
              const artifact = new THREE.Mesh(
                new THREE.SphereGeometry(0.5,16,16),
                new THREE.MeshStandardMaterial({ color: 0x9400d3 })
              );
              artifact.castShadow = true;
              artifact.receiveShadow = true;
              const glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6,16,16),
                new THREE.MeshBasicMaterial({ color: 0xffeb3b, transparent: true, opacity: 0.5, side: THREE.BackSide })
              );
              const group = new THREE.Group();
              group.add(artifact, glow);
              group.position.set(ax,0.5,az);
              this.sceneObj.add(group);
              this.objects.push({ mesh: group, type: 'artifact', isPickup: true, x: ax, z: az });
            }
          }

          //==============================
          // Input & Animation
          //==============================
          initJoysticks() {
            this.joystickLeft = nipplejs.create({
              zone: document.getElementById('joystickLeft'),
              mode: 'static',
              color: 'white',
              size: 100,
              position: { left: '2vw', bottom: '6vh' }
            });
            this.joystickLeft.on('move', (evt, data) => {
              if (data && data.force > 0) {
                const angle = data.angle.radian;
                const speed = data.force * this.player.speedJoystick;
                const dx = Math.cos(angle) * speed;
                const dz = Math.sin(angle) * speed;
                const newX = this.player.x + dx;
                const newZ = this.player.z - dz;
                let blocked = false;
                for (const obj of this.objects) {
                  if (obj.type === 'building' || obj.type === 'wall' || obj.type === 'boundary' || obj.type === 'decoration') {
                    const dxObj = newX - obj.x;
                    const dzObj = newZ - obj.z;
                    const distSq = dxObj*dxObj + dzObj*dzObj;
                    const r = (obj.boundingRadius || 1) + 0.5;
                    if (distSq < r*r) { blocked = true; break; }
                  }
                }
                if (!blocked) {
                  this.player.x = newX;
                  this.player.z = newZ;
                }
                this.joystickLeft.active = true;
              }
            });
            this.joystickLeft.on('end', () => { this.joystickLeft.active = false; });

            this.joystickRight = nipplejs.create({
              zone: document.getElementById('joystickRight'),
              mode: 'static',
              color: 'white',
              size: 100,
              position: { right: '2vw', bottom: '6vh' }
            });
            this.joystickRight.on('move', (evt, data) => {
              if (data && data.force > 0) {
                const sensitivity = 0.001;
                this.player.yaw += data.vector.x * sensitivity * data.force;
                this.player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.pitch + data.vector.y * sensitivity * data.force));
              }
            });
            this.joystickRight.on('end', () => {});
            document.getElementById('gameContainer').addEventListener('click', e => {
              const rect = e.target.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              if (x > rect.width/4 && x < (rect.width*3)/4 && y > rect.height/4 && y < (rect.height*3)/4) {
                this.throwBall();
              }
            });
          }

          initKeyboardMouse() {
            document.addEventListener('keydown', e => {
              this.keysPressed[e.key] = true;
              if (e.key === ' ') this.throwBall();
            });
            document.addEventListener('keyup', e => { this.keysPressed[e.key] = false; });
            document.addEventListener('mousedown', () => { document.body.requestPointerLock(); });
            document.addEventListener('mousemove', event => {
              if (document.pointerLockElement === document.body) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                const sensitivity = 0.001;
                this.player.yaw += movementX * sensitivity;
                this.player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.pitch + movementY * sensitivity));
              }
            });
          }

          startAnimation() {
            const animate = () => {
              requestAnimationFrame(animate);
              this.update();
              this.renderer.render(this.sceneObj, this.camera);
            };
            animate();
          }

          //==============================
          // Update Loop
          //==============================
          update() {
            this.updateDayNight();

            // Update thrown balls
            this.thrownBalls.forEach((ball, index) => {
              ball.position.add(ball.userData.velocity);
              ball.userData.velocity.y -= 0.01;
              if (ball.position.y < 0) {
                if (!ball.userData.bounced) {
                  ball.position.y = 0;
                  ball.userData.velocity.y *= -0.7;
                  ball.userData.bounced = true;
                } else if (ball.position.y < -0.5) {
                  this.sceneObj.remove(ball);
                  this.thrownBalls.splice(index, 1);
                }
              }
            });

            // Player movement
            let dx = 0, dz = 0;
            const isKey = this.keysPressed['ArrowUp'] || this.keysPressed['ArrowDown'] || this.keysPressed['ArrowLeft'] || this.keysPressed['ArrowRight'];
            const speed = isKey ? this.player.speedKeyboard : this.player.speedJoystick;
            if (this.keysPressed['ArrowUp']) dz -= speed;
            if (this.keysPressed['ArrowDown']) dz += speed;
            if (this.keysPressed['ArrowLeft']) dx -= speed;
            if (this.keysPressed['ArrowRight']) dx += speed;
            if (dx !== 0 || dz !== 0) { this.player.lastMoveVec.set(dx,0,dz); }
            const newX = this.player.x + dx * Math.cos(this.player.yaw) + dz * Math.sin(this.player.yaw);
            const newZ = this.player.z - dx * Math.sin(this.player.yaw) + dz * Math.cos(this.player.yaw);
            let blocked = false;
            for (const obj of this.objects) {
              if (obj.type === 'beach' || obj.type === 'water') continue;
              if (obj.type === 'building' || obj.type === 'wall' || obj.type === 'boundary' || obj.type === 'decoration') {
                const dxObj = newX - obj.x;
                const dzObj = newZ - obj.z;
                const distSq = dxObj*dxObj + dzObj*dzObj;
                const r = (obj.boundingRadius || 1) + 0.5;
                if (distSq < r*r) { blocked = true; break; }
              }
            }
            if (!blocked) {
              this.player.x = newX;
              this.player.z = newZ;
            }
            this.player.object.position.set(this.player.x,0.5,this.player.z);
            this.player.object.rotation.y = -this.player.yaw;

            // Walking animation
            const moving = dx !== 0 || dz !== 0 || (this.joystickLeft && this.joystickLeft.active);
            if (moving) {
              this.player.object.traverse(child => {
                if (child.isMesh && child.userData.isBodyPart)
                  child.rotation.z = Math.sin(Date.now()*0.005)*0.1;
              });
            } else {
              this.player.object.traverse(child => {
                if (child.isMesh && child.userData.isBodyPart)
                  child.rotation.set(0,0,0);
              });
            }

            // Update NPC (blue)
            npcData.angle += npcData.speed;
            const npcX = npcData.radius * Math.cos(npcData.angle);
            const npcZ = npcData.radius * Math.sin(npcData.angle);
            if (npcData.object) {
              npcData.object.position.set(npcX,0.5,npcZ);
              npcData.object.rotation.y = -npcData.angle;
            }

            // Update Bird
            if (birdData.object) {
              birdData.angle += birdData.speed;
              const bx = birdData.radius * Math.cos(birdData.angle);
              const bz = birdData.radius * Math.sin(birdData.angle);
              birdData.object.position.set(bx,60,bz);
              birdData.object.rotation.y = -birdData.angle;
            }

            // Guard interaction
            if (this.guardObject && !this.guardMessageShown) {
              const dxG = this.player.x - this.guardObject.position.x;
              const dzG = this.player.z - this.guardObject.position.z;
              const distG = Math.sqrt(dxG*dxG + dzG*dzG);
              if (distG < 5) { this.showGuardPopup("Please show me your ID"); }
            }

            // NPC interaction (blue NPC says "Hello Princess Donia!")
            if (npcData.object && !this.npcMessageShown) {
              const dxN = this.player.x - npcData.object.position.x;
              const dzN = this.player.z - npcData.object.position.z;
              const distN = Math.sqrt(dxN*dxN + dzN*dzN);
              if (distN < 5) {
                this.showGuardPopup("Hello Princess Donia!");
                this.npcMessageShown = true;
                setTimeout(() => { this.npcMessageShown = false; }, 2500);
              }
            }

            // Camera positioning
            const camDist = 15;
            const offsetX = camDist * Math.sin(this.player.yaw) * Math.cos(this.player.pitch);
            const offsetZ = camDist * Math.cos(this.player.yaw) * Math.cos(this.player.pitch);
            const offsetY = camDist * Math.sin(this.player.pitch) + 15;
            this.camera.position.set(this.player.x+offsetX, offsetY, this.player.z+offsetZ);
            this.camera.lookAt(this.player.x, 3.5, this.player.z);

            // Check for item pickups
            for (const obj of this.objects) {
              if (obj.isPickup) {
                const dxObj = this.player.x - obj.x;
                const dzObj = this.player.z - obj.z;
                const distSq = dxObj*dxObj + dzObj*dzObj;
                if (distSq < 4) {
                  switch(obj.type) {
                    case 'flower':
                      this.flowers++;
                      document.getElementById('flowers').textContent = this.flowers;
                      this.showDialogue('You picked a radiant flower!');
                      break;
                    case 'coin':
                      this.coins++;
                      document.getElementById('coins').textContent = this.coins;
                      this.showDialogue('You picked up a shiny coin!');
                      break;
                    case 'gem':
                      this.gems++;
                      document.getElementById('gems').textContent = this.gems;
                      this.showDialogue('A dazzling gem is yours!');
                      break;
                    case 'potion':
                      this.potions++;
                      document.getElementById('potions').textContent = this.potions;
                      this.showDialogue('You found a potion!');
                      break;
                    case 'key':
                      this.keys++;
                      document.getElementById('keys').textContent = this.keys;
                      this.showDialogue('A golden key is yours!');
                      break;
                    case 'artifact':
                      this.artifacts++;
                      document.getElementById('artifacts').textContent = this.artifacts;
                      this.showDialogue('You discovered a mystical artifact!');
                      break;
                    default:
                      break;
                  }
                  this.sceneObj.remove(obj.mesh);
                  this.objects = this.objects.filter(o => o !== obj);
                  this.startCollectionGlow();
                }
              }
            }
          }

          //==============================
          // Update Day/Night
          //==============================
          updateDayNight() {
            this.dayNightCycle = (this.dayNightCycle + 1) % 1200;
            this.time = this.dayNightCycle < 600 ? 'Day' : 'Night';
            document.getElementById('time').textContent = this.time;
            if (this.sunMesh && this.moonMesh && this.starsMesh) {
              if (this.time === 'Day') {
                this.sunMesh.visible = true;
                this.moonMesh.visible = false;
                this.starsMesh.visible = false;
              } else {
                this.sunMesh.visible = false;
                this.moonMesh.visible = true;
                this.starsMesh.visible = true;
              }
            }
          }

          //==============================
          // Utility Methods
          //==============================
          showDialogue(text) {
            this.dialogue = text;
            document.getElementById('dialogue').textContent = text;
          }

          showGuardPopup(text) {
            const popup = document.getElementById('guardPopup');
            popup.style.display = 'block';
            popup.textContent = text;
            this.guardMessageShown = true;
            setTimeout(() => {
              popup.style.display = 'none';
              popup.textContent = '';
              this.guardMessageShown = false;
            }, 2000);
          }

          throwBall() {
            let direction = new THREE.Vector3();
            if (this.player.lastMoveVec.lengthSq() > 0.001) {
              direction.copy(this.player.lastMoveVec).normalize();
            } else {
              direction.set(Math.cos(this.player.yaw), 0, Math.sin(this.player.yaw)).normalize();
            }
            const ball = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xff4500 })
            );
            ball.position.copy(this.player.object.position);
            ball.position.y += 1;
            ball.userData = {
              velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
              bounced: false
            };
            this.sceneObj.add(ball);
            this.thrownBalls.push(ball);
            this.ballCount++;
            document.getElementById('ballCountValue').textContent = this.ballCount;
            this.showDialogue("Threw a magic ball!");
          }

          startCollectionGlow() {
            if (this.collectionGlow) this.sceneObj.remove(this.collectionGlow);
            const glow = new THREE.Mesh(
              new THREE.SphereGeometry(1,16,16),
              new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5, side: THREE.BackSide })
            );
            glow.position.copy(this.player.object.position);
            glow.position.y += 0.5;
            this.sceneObj.add(glow);
            this.collectionGlow = glow;
            setTimeout(() => {
              if (this.collectionGlow) {
                this.sceneObj.remove(this.collectionGlow);
                this.collectionGlow = null;
              }
            }, 1000);
          }

          //==============================
          // Input Methods
          //==============================
          initJoysticks() {
            this.joystickLeft = nipplejs.create({
              zone: document.getElementById('joystickLeft'),
              mode: 'static',
              color: 'white',
              size: 100,
              position: { left: '2vw', bottom: '6vh' }
            });
            this.joystickLeft.on('move', (evt, data) => {
              if (data && data.force > 0) {
                const angle = data.angle.radian;
                const speed = data.force * this.player.speedJoystick;
                const dx = Math.cos(angle) * speed;
                const dz = Math.sin(angle) * speed;
                const newX = this.player.x + dx;
                const newZ = this.player.z - dz;
                let blocked = false;
                for (const obj of this.objects) {
                  if (obj.type === 'building' || obj.type === 'wall' || obj.type === 'boundary' || obj.type === 'decoration') {
                    const dxObj = newX - obj.x;
                    const dzObj = newZ - obj.z;
                    const distSq = dxObj*dxObj + dzObj*dzObj;
                    const r = (obj.boundingRadius || 1) + 0.5;
                    if (distSq < r*r) { blocked = true; break; }
                  }
                }
                if (!blocked) {
                  this.player.x = newX;
                  this.player.z = newZ;
                }
                this.joystickLeft.active = true;
              }
            });
            this.joystickLeft.on('end', () => { this.joystickLeft.active = false; });

            this.joystickRight = nipplejs.create({
              zone: document.getElementById('joystickRight'),
              mode: 'static',
              color: 'white',
              size: 100,
              position: { right: '2vw', bottom: '6vh' }
            });
            this.joystickRight.on('move', (evt, data) => {
              if (data && data.force > 0) {
                const sensitivity = 0.001;
                this.player.yaw += data.vector.x * sensitivity * data.force;
                this.player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.pitch + data.vector.y * sensitivity * data.force));
              }
            });
            this.joystickRight.on('end', () => {});
            document.getElementById('gameContainer').addEventListener('click', e => {
              const rect = e.target.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              if (x > rect.width/4 && x < (rect.width*3)/4 && y > rect.height/4 && y < (rect.height*3)/4) {
                this.throwBall();
              }
            });
          }

          initKeyboardMouse() {
            document.addEventListener('keydown', e => {
              this.keysPressed[e.key] = true;
              if (e.key === ' ') this.throwBall();
            });
            document.addEventListener('keyup', e => { this.keysPressed[e.key] = false; });
            document.addEventListener('mousedown', () => { document.body.requestPointerLock(); });
            document.addEventListener('mousemove', event => {
              if (document.pointerLockElement === document.body) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                const sensitivity = 0.001;
                this.player.yaw += movementX * sensitivity;
                this.player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.pitch + movementY * sensitivity));
              }
            });
          }
        }

        const game = new Game();
      } catch (error) {
        console.error('Error initializing the game:', error);
      }
    </script>
  </body>
</html>
