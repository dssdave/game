<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Princess Adventure - Enhanced Edition</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #87ceeb; /* Light blue sky */
        }
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 32; // Each tile is 32x32 pixels

        // Define maps for town and house
        const maps = {
            'town': {
                grid: [
                    [0,0,0,0,0,0,0,0,0,0],
                    [0,1,1,1,0,0,1,1,1,0],
                    [0,1,0,0,0,0,0,0,1,0],
                    [0,1,0,0,0,0,0,0,1,0],
                    [0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0],
                    [0,1,0,0,0,0,0,0,1,0],
                    [0,1,0,0,0,0,0,0,1,0],
                    [0,1,1,1,0,0,1,1,1,0],
                    [0,0,0,0,0,0,0,0,0,0]
                ],
                entrances: [
                    { x: 4, y: 4, scene: 'house', enterX: 2, enterY: 2 }
                ]
            },
            'house': {
                grid: [
                    [1,1,1,1,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,1]
                ],
                exits: [
                    { x: 2, y: 3, scene: 'town', exitX: 4, exitY: 5 }
                ]
            }
        };

        let currentScene = 'town';
        const initialGrid = maps[currentScene].grid;
        canvas.width = initialGrid[0].length * tileSize;
        canvas.height = initialGrid.length * tileSize;

        // Princess properties
        let princess = {
            x: 1 * tileSize,
            y: 1 * tileSize,
            width: tileSize,
            height: tileSize,
            speed: 4 // Pixels per frame
        };

        // Handle keyboard input
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Collision detection
        function isColliding(x, y, grid) {
            const tileX = Math.floor(x / tileSize);
            const tileY = Math.floor(y / tileSize);
            if (tileX < 0 || tileX >= grid[0].length || tileY < 0 || tileY >= grid.length) return true;
            return grid[tileY][tileX] === 1; // Wall
        }

        // Update princess position
        function updatePrincess() {
            let dx = 0;
            let dy = 0;
            if (keys['ArrowLeft']) dx -= princess.speed;
            if (keys['ArrowRight']) dx += princess.speed;
            if (keys['ArrowUp']) dy -= princess.speed;
            if (keys['ArrowDown']) dy += princess.speed;

            // Check horizontal movement
            let newX = princess.x + dx;
            if (!isColliding(newX, princess.y, maps[currentScene].grid) && !isColliding(newX + princess.width, princess.y, maps[currentScene].grid)) {
                princess.x = newX;
            }

            // Check vertical movement
            let newY = princess.y + dy;
            if (!isColliding(princess.x, newY, maps[currentScene].grid) && !isColliding(princess.x, newY + princess.height, maps[currentScene].grid)) {
                princess.y = newY;
            }

            // Keep princess within bounds
            princess.x = Math.max(0, Math.min(princess.x, canvas.width - princess.width));
            princess.y = Math.max(0, Math.min(princess.y, canvas.height - princess.height));

            // Check for scene switch
            const tileX = Math.floor(princess.x / tileSize);
            const tileY = Math.floor(princess.y / tileSize);
            if (currentScene === 'town') {
                const entrance = maps['town'].entrances.find(e => e.x === tileX && e.y === tileY);
                if (entrance) {
                    switchScene(entrance.scene, entrance.enterX, entrance.enterY);
                }
            } else if (currentScene === 'house') {
                const exit = maps['house'].exits.find(e => e.x === tileX && e.y === tileY);
                if (exit) {
                    switchScene(exit.scene, exit.exitX, exit.exitY);
                }
            }
        }

        // Switch scene
        function switchScene(newScene, newX, newY) {
            currentScene = newScene;
            const grid = maps[newScene].grid;
            canvas.width = grid[0].length * tileSize;
            canvas.height = grid.length * tileSize;
            princess.x = newX * tileSize;
            princess.y = newY * tileSize;
        }

        // Draw the map
        function drawMap() {
            const grid = maps[currentScene].grid;
            let entrances = currentScene === 'town' ? maps['town'].entrances : [];
            let exits = currentScene === 'house' ? maps['house'].exits : [];
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[0].length; col++) {
                    const tile = grid[row][col];
                    let color;
                    if (currentScene === 'town') {
                        if (entrances.some(e => e.x === col && e.y === row)) {
                            color = 'blue';
                        } else if (tile === 0) {
                            color = `hsl(120, 50%, ${40 + Math.random() * 20}%)`;
                        } else {
                            color = 'gray';
                        }
                    } else if (currentScene === 'house') {
                        if (exits.some(e => e.x === col && e.y === row)) {
                            color = 'red';
                        } else if (tile === 0) {
                            color = 'brown';
                        } else {
                            color = 'gray';
                        }
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                }
            }
        }

        // Draw the princess
        function drawPrincess() {
            // Body (gown)
            ctx.fillStyle = '#ff69b4'; // Pink gown
            ctx.fillRect(princess.x + 8, princess.y + 16, 16, 16);
            // Head
            ctx.fillStyle = '#ffdab9'; // Skin tone
            ctx.beginPath();
            ctx.arc(princess.x + 16, princess.y + 8, 8, 0, Math.PI * 2);
            ctx.fill();
            // Hair
            ctx.fillStyle = '#8b4513'; // Brown hair
            ctx.fillRect(princess.x + 8, princess.y, 16, 8);
            // Crown
            ctx.fillStyle = '#ffd700'; // Gold crown
            ctx.fillRect(princess.x + 12, princess.y - 4, 8, 4);
        }

        // Main game loop
        function gameLoop() {
            updatePrincess();
            drawMap();
            drawPrincess();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>
