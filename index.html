<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town – Fully Restored</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; }
    #ui, #ballCount, #dialogue, #controls, #compass {
      background: rgba(0,0,0,0.7);
      border: 4px solid #fff;
      border-radius: 5px;
      color: #fff;
      font-size: 20px;
      padding: 10px 15px;
      position: absolute;
      z-index: 10;
    }
    #ui        { top: 10px; left: 10px; }
    #ballCount { top: 10px; right: 10px; }
    #dialogue  { bottom: 10px; left: 10px; max-width: 600px; display: none; }
    #controls  { bottom: 10px; right: 10px; }
    #compass   { bottom: 50px; left: 50%; transform: translateX(-50%); }
    #toggleUIBtn {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      font-size: 24px;
      padding: 10px 20px;
      background: #333;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 5px;
      cursor: pointer;
    }
    #dpadContainer, #turnContainer, #actionContainer {
      position: absolute;
      z-index: 15;
    }
    #dpadContainer {
      bottom: 16vh;
      left: 5vw;
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
    }
    #btnUp    { grid-column: 2; grid-row: 1; }
    #btnDown  { grid-column: 2; grid-row: 3; }
    #btnLeft  { grid-column: 1; grid-row: 2; }
    #btnRight { grid-column: 3; grid-row: 2; }
    #dpadContainer button {
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
    }
    #turnContainer {
      bottom: 16vh;
      left: calc(5vw + 200px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #turnContainer button, #actionContainer button {
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px;
      color: #fff;
      cursor: pointer;
    }
    #actionContainer {
      bottom: 16vh;
      left: calc(5vw + 200px + 70px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    @media (max-width: 768px) {
      #ui, #ballCount, #dialogue, #controls, #compass {
        font-size: 14px;
        padding: 5px 10px;
      }
      #toggleUIBtn { font-size: 16px; }
      #dpadContainer {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
      }
      #dpadContainer button {
        width: 50px;
        height: 50px;
        font-size: 14px;
      }
      #turnContainer button, #actionContainer button {
        width: 50px;
        height: 50px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>
    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifacts: <span id="artifacts">0</span> |
      Health: <span id="health">100</span> |
      Score: <span id="score">0</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
    <div id="dialogue"></div>
    <div id="controls">
      Controls:<br>
      [Desktop] Arrow Keys = move/turn, Space = throw ball, B = jump, C = toggle collision boxes<br>
      [Mobile] D‑Pad = move, L/R = turn, A = throw ball, B = jump
    </div>
    <div id="compass">Compass: N</div>
    <div id="dpadContainer">
      <button id="btnUp">▲</button>
      <button id="btnDown">▼</button>
      <button id="btnLeft">◀</button>
      <button id="btnRight">▶</button>
    </div>
    <div id="turnContainer">
      <button id="btnTurnLeft">L</button>
      <button id="btnTurnRight">R</button>
    </div>
    <div id="actionContainer">
      <button id="btnThrow">A</button>
      <button id="btnJump">B</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Toggle UI
    document.getElementById('toggleUIBtn').addEventListener('click', () => {
      const ids = ["ui", "ballCount", "dialogue", "controls", "compass"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        el.style.display = (el.style.display === "none") ? "block" : "none";
      });
    });

    // Prevent text highlighting on mobile
    function disableHighlight(id) {
      const btn = document.getElementById(id);
      ["touchstart", "mousedown"].forEach(evt => {
        btn.addEventListener(evt, e => { e.preventDefault(); }, { passive: false });
      });
    }
    ["btnUp", "btnDown", "btnLeft", "btnRight", "btnTurnLeft", "btnTurnRight", "btnThrow", "btnJump"]
      .forEach(disableHighlight);

    // On-screen controller state
    const controllerState = {
      dpadUp: false, dpadDown: false, dpadLeft: false, dpadRight: false,
      turnLeft: false, turnRight: false
    };
    function setButtonListener(btnId, stateProp) {
      const btn = document.getElementById(btnId);
      ["mousedown", "touchstart"].forEach(evt => {
        btn.addEventListener(evt, e => {
          e.preventDefault();
          controllerState[stateProp] = true;
        }, { passive: false });
      });
      ["mouseup", "touchend", "mouseleave"].forEach(evt => {
        btn.addEventListener(evt, e => { controllerState[stateProp] = false; });
      });
    }
    setButtonListener('btnUp', 'dpadUp');
    setButtonListener('btnDown', 'dpadDown');
    setButtonListener('btnLeft', 'dpadLeft');
    setButtonListener('btnRight', 'dpadRight');
    setButtonListener('btnTurnLeft', 'turnLeft');
    setButtonListener('btnTurnRight', 'turnRight');

    // A/B button actions
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game) window.game.throwBall();
      }, { passive: false });
      document.getElementById("btnJump").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game) window.game.jump();
      }, { passive: false });
    });

    // Global variables
    let game = null;
    const keysPressed = {};
    const outsideScene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
    let activeScene = outsideScene;
    let gameTime = 0;

    // Main Game class
    class Game {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Player
        this.player = { 
          x: 5, y: 0.5, z: 5, 
          speedKeyboard: 0.25, 
          yaw: 0, 
          jumpVelocity: 0, 
          object: null, 
          health: 100,
          score: 0
        };

        // Stats
        this.ballCount = 0;
        this.thrownBalls = [];
        this.keysPressed = keysPressed;
        this.collisionBoxes = null;

        // Collision array
        this.outsideObjects = [];

        // Initialize scene
        this.initOutsideScene();
        activeScene = outsideScene;
        document.getElementById('location').textContent = "Town";

        // Set up input and animation
        this.initKeyboardMouse();
        this.startAnimation();
      }

      initOutsideScene() {
        outsideScene.background = new THREE.Color(0x87CEEB); // Clear blue sky
        const ground = new THREE.Mesh(
          new THREE.PlaneGeometry(300, 300),
          new THREE.MeshStandardMaterial({ color: 0x6bb26b, side: THREE.DoubleSide }) // Bright green grass
        );
        ground.rotation.x = Math.PI / 2;
        outsideScene.add(ground);
        this.outsideObjects.push({ mesh: ground, type: 'ground', x: 0, z: 0, boundingRadius: 150 });

        const ambient = new THREE.AmbientLight(0x404040, 0.6);
        outsideScene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        outsideScene.add(dirLight);

        // Add player
        this.createPlayerModel();
        outsideScene.add(this.player.object);

        // Add central platform (piazza)
        this.createPiazza(outsideScene);

        // Add NPCs
        this.createNPCs(outsideScene);

        // Add collectibles
        this.createCollectibles(outsideScene);

        // Add enemies
        this.createEnemies(outsideScene);

        camera.position.set(15, 15, 15);
        camera.lookAt(0, 1, 0);
      }

      createPlayerModel() {
        this.player.object = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1.5, 1),
          new THREE.MeshStandardMaterial({ color: 0x00ff00 }) // Green player
        );
        body.position.y = 0.75;
        this.player.object.add(body);
        this.player.object.position.set(this.player.x, this.player.y, this.player.z);
        this.player.object.body = body; // For health color change
      }

      createPiazza(sceneRef) {
        const platform = new THREE.Mesh(
          new THREE.BoxGeometry(20, 0.5, 20),
          new THREE.MeshStandardMaterial({ color: 0x808080 }) // Gray platform
        );
        platform.position.set(0, 0.25, 0);
        sceneRef.add(platform);
        this.outsideObjects.push({ mesh: platform, type: 'decoration', x: 0, z: 0, boundingRadius: 10 });

        // Add poles with lights
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2;
          const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 3, 16),
            new THREE.MeshStandardMaterial({ color: 0x000000 }) // Black poles
          );
          pole.position.set(Math.cos(angle) * 8, 1.5, Math.sin(angle) * 8);
          sceneRef.add(pole);
          this.outsideObjects.push({ mesh: pole, type: 'decoration', x: pole.position.x, z: pole.position.z, boundingRadius: 0.5 });

          const light = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00 }) // Yellow lights
          );
          light.position.set(Math.cos(angle) * 8, 3.5, Math.sin(angle) * 8);
          sceneRef.add(light);
        }
      }

      createNPCs(sceneRef) {
        const npcs = [
          { color: 0x800080, position: {x:5, y:0.75, z:5}, dialogue: "Welcome, Princess Donia!" },
          { color: 0x0000ff, position: {x:-5, y:0.75, z:5}, dialogue: "Explore the town and find all the collectibles!" },
          { color: 0xff0000, position: {x:10, y:0.75, z:10}, dialogue: "Have you found all the collectibles?" },
          { color: 0x00ff00, position: {x:-10, y:0.75, z:-10}, dialogue: "Watch out for enemies!" },
          { color: 0xffa500, position: {x:15, y:0.75, z:-15}, dialogue: "Collect potions to restore health!" }
        ];
        npcs.forEach(npc => {
          const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1.5, 1),
            new THREE.MeshStandardMaterial({ color: npc.color })
          );
          mesh.position.set(npc.position.x, npc.position.y, npc.position.z);
          sceneRef.add(mesh);
          this.outsideObjects.push({ mesh, type: 'npc', x: npc.position.x, z: npc.position.z, boundingRadius: 1, dialogue: npc.dialogue });
        });
      }

      createCollectibles(sceneRef) {
        const createFlower = () => {
          const stem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8),
            new THREE.MeshStandardMaterial({ color: 0x00ff00 }) // Green stem
          );
          stem.position.y = 0.25;
          const petals = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xff00ff }) // Magenta petals
          );
          petals.position.y = 0.5;
          const flower = new THREE.Group();
          flower.add(stem, petals);
          flower.position.set(Math.random() * 40 - 20, 0, Math.random() * 40 - 20);
          sceneRef.add(flower);
          this.outsideObjects.push({ mesh: flower, type: 'flower', x: flower.position.x, z: flower.position.z, boundingRadius: 0.3 });
        };

        const createCoin = () => {
          const coin = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xffff00 }) // Yellow coin
          );
          coin.position.set(Math.random() * 40 - 20, 0.5, Math.random() * 40 - 20);
          sceneRef.add(coin);
          this.outsideObjects.push({ mesh: coin, type: 'coin', x: coin.position.x, z: coin.position.z, boundingRadius: 0.3 });
        };

        const createGem = () => {
          const gem = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.4, 0),
            new THREE.MeshStandardMaterial({ color: 0x00ffff }) // Cyan gem
          );
          gem.position.set(Math.random() * 40 - 20, 0.5, Math.random() * 40 - 20);
          sceneRef.add(gem);
          this.outsideObjects.push({ mesh: gem, type: 'gem', x: gem.position.x, z: gem.position.z, boundingRadius: 0.4 });
        };

        const createPotion = () => {
          const potion = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 0.5, 16),
            new THREE.MeshStandardMaterial({ color: 0xff0000 }) // Red potion
          );
          potion.position.set(Math.random() * 40 - 20, 0.5, Math.random() * 40 - 20);
          sceneRef.add(potion);
          this.outsideObjects.push({ mesh: potion, type: 'potion', x: potion.position.x, z: potion.position.z, boundingRadius: 0.2 });
        };

        const createKey = () => {
          const handle = new THREE.Mesh(
            new THREE.TorusGeometry(0.2, 0.05, 8, 16),
            new THREE.MeshStandardMaterial({ color: 0xffd700 }) // Gold handle
          );
          const shaft = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8),
            new THREE.MeshStandardMaterial({ color: 0xffd700 }) // Gold shaft
          );
          shaft.position.y = 0.25;
          shaft.rotation.z = Math.PI / 2;
          const key = new THREE.Group();
          key.add(handle, shaft);
          key.position.set(Math.random() * 40 - 20, 0.5, Math.random() * 40 - 20);
          sceneRef.add(key);
          this.outsideObjects.push({ mesh: key, type: 'key', x: key.position.x, z: key.position.z, boundingRadius: 0.3 });
        };

        const createArtifact = () => {
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.1, 0.5),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 }) // Brown base
          );
          const crystal = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.3, 0),
            new THREE.MeshStandardMaterial({ color: 0x00ffff }) // Cyan crystal
          );
          crystal.position.y = 0.3;
          const artifact = new THREE.Group();
          artifact.add(base, crystal);
          artifact.position.set(Math.random() * 40 - 20, 0.05, Math.random() * 40 - 20);
          sceneRef.add(artifact);
          this.outsideObjects.push({ mesh: artifact, type: 'artifact', x: artifact.position.x, z: artifact.position.z, boundingRadius: 0.5 });
        };

        // Create multiple collectibles
        for (let i = 0; i < 10; i++) createFlower();
        for (let i = 0; i < 8; i++) createCoin();
        for (let i = 0; i < 5; i++) createGem();
        for (let i = 0; i < 3; i++) createPotion();
        for (let i = 0; i < 2; i++) createKey();
        for (let i = 0; i < 1; i++) createArtifact();
      }

      createEnemies(sceneRef) {
        const createEnemy = (position, range) => {
          const enemy = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xff0000 }) // Red enemy
          );
          enemy.position.set(position.x, position.y, position.z);
          sceneRef.add(enemy);
          this.outsideObjects.push({ mesh: enemy, type: 'enemy', x: position.x, z: position.z, boundingRadius: 0.5, range: range, direction: 1 });
        };

        // Create enemies with patrol ranges
        createEnemy({x: 10, y: 0.5, z: 10}, {min: 5, max: 15});
        createEnemy({x: -10, y: 0.5, z: -10}, {min: -15, max: -5});
        createEnemy({x: 0, y: 0.5, z: 20}, {min: 15, max: 25});
      }

      updateMovement() {
        let keyboardForward = 0, keyboardTurn = 0;
        if (this.keysPressed['ArrowUp']) keyboardForward++;
        if (this.keysPressed['ArrowDown']) keyboardForward--;
        if (this.keysPressed['ArrowLeft']) keyboardTurn++;
        if (this.keysPressed['ArrowRight']) keyboardTurn--;
        let touchForward = 0, touchStrafe = 0;
        if (controllerState.dpadUp) touchForward++;
        if (controllerState.dpadDown) touchForward--;
        if (controllerState.dpadLeft) touchStrafe++;
        if (controllerState.dpadRight) touchStrafe--;
        let finalForward = (keyboardForward !== 0 ? keyboardForward : touchForward);
        let finalStrafe = touchStrafe;
        let finalTurn = keyboardTurn;
        if (controllerState.turnLeft) finalTurn++;
        if (controllerState.turnRight) finalTurn--;

        const forwardVec = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
        const rightVec = new THREE.Vector3(Math.cos(this.player.yaw), 0, -Math.sin(this.player.yaw));
        const movement = forwardVec.clone().multiplyScalar(finalForward).add(rightVec.clone().multiplyScalar(finalStrafe));
        if (movement.length() > 1) movement.normalize();
        movement.multiplyScalar(this.player.speedKeyboard);

        const newX = this.player.x + movement.x;
        const newZ = this.player.z + movement.z;
        let canMove = true;
        for (const obj of this.outsideObjects) {
          if (obj.type !== 'ground') {
            const dx = newX - obj.x;
            const dz = newZ - obj.z;
            const minDist = (obj.boundingRadius || 1) + 1.5; // Increased tolerance to prevent sticking
            if (dx * dx + dz * dz < minDist * minDist) {
              if (obj.type === 'flower' || obj.type === 'coin' || obj.type === 'gem' || obj.type === 'potion' || obj.type === 'key' || obj.type === 'artifact') {
                this.collectItem(obj);
                canMove = true;
              } else if (obj.type === 'npc') {
                this.interactWithNPC(obj);
                canMove = false;
              } else if (obj.type === 'enemy') {
                this.player.health -= 1;
                document.getElementById('health').textContent = this.player.health;
                this.showDialogue("Ouch! Lost health!");
                canMove = false;
              } else {
                canMove = false;
              }
              break;
            }
          }
        }
        if (canMove) {
          this.player.x = newX;
          this.player.z = newZ;
        }
        this.player.yaw += finalTurn * 0.02;

        if (this.player.jumpVelocity > 0 || this.player.y > 0.5) {
          this.player.y += this.player.jumpVelocity;
          this.player.jumpVelocity -= 0.02;
          if (this.player.y <= 0.5) {
            this.player.y = 0.5;
            this.player.jumpVelocity = 0;
          }
        }
        this.player.object.position.set(this.player.x, this.player.y, this.player.z);
        this.player.object.rotation.y = this.player.yaw;

        // Update player color based on health
        if (this.player.health < 30) {
          this.player.object.body.material.color.set(0xff0000); // Red when low health
        } else {
          this.player.object.body.material.color.set(0x00ff00); // Green otherwise
        }
      }

      collectItem(obj) {
        activeScene.remove(obj.mesh);
        this.outsideObjects = this.outsideObjects.filter(o => o !== obj);
        if (obj.type === 'flower') {
          this.player.score += 10;
          document.getElementById('flowers').textContent = parseInt(document.getElementById('flowers').textContent) + 1;
          this.showDialogue("Collected a flower!");
        } else if (obj.type === 'coin') {
          this.player.score += 20;
          document.getElementById('coins').textContent = parseInt(document.getElementById('coins').textContent) + 1;
          this.showDialogue("Collected a coin!");
        } else if (obj.type === 'gem') {
          this.player.score += 50;
          document.getElementById('gems').textContent = parseInt(document.getElementById('gems').textContent) + 1;
          this.showDialogue("Collected a gem!");
        } else if (obj.type === 'potion') {
          this.player.health = Math.min(100, this.player.health + 10);
          document.getElementById('health').textContent = this.player.health;
          document.getElementById('potions').textContent = parseInt(document.getElementById('potions').textContent) + 1;
          this.showDialogue("Health restored!");
        } else if (obj.type === 'key') {
          this.player.score += 100;
          document.getElementById('keys').textContent = parseInt(document.getElementById('keys').textContent) + 1;
          this.showDialogue("Collected a key!");
        } else if (obj.type === 'artifact') {
          this.player.score += 200;
          document.getElementById('artifacts').textContent = parseInt(document.getElementById('artifacts').textContent) + 1;
          this.showDialogue("Collected an artifact!");
        }
        document.getElementById('score').textContent = this.player.score;
      }

      interactWithNPC(obj) {
        this.showDialogue(obj.dialogue);
      }

      updateBalls() {
        for (let i = this.thrownBalls.length - 1; i >= 0; i--) {
          const ball = this.thrownBalls[i];
          ball.position.add(ball.userData.velocity);
          ball.userData.velocity.y -= 0.01; // Gravity
          for (const obj of this.outsideObjects) {
            if (obj.type !== 'ground') {
              const dx = ball.position.x - obj.x;
              const dz = ball.position.z - obj.z;
              const r = (obj.boundingRadius || 1) + 0.3;
              if (dx * dx + dz * dz < r * r && ball.position.y < 10) {
                const normal = new THREE.Vector3(dx, 0, dz).normalize();
                const v = ball.userData.velocity.clone();
                const dot = v.dot(normal);
                ball.userData.velocity.sub(normal.multiplyScalar(2 * dot)).multiplyScalar(0.6); // Bounce
              }
            }
          }
          if (ball.position.y < 0) {
            ball.position.y = 0;
            ball.userData.velocity.y *= -0.7; // Bounce off ground
          }
          ball.userData.timer = (ball.userData.timer || 0) + 1;
          if (ball.userData.timer > 150) {
            activeScene.remove(ball);
            this.thrownBalls.splice(i, 1);
          }
        }
      }

      throwBall() {
        const direction = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
        const ball = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xff4500 }) // Orange ball
        );
        ball.position.set(this.player.x, this.player.y + 1, this.player.z);
        ball.userData = { velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0, 0.3, 0)), timer: 0 };
        activeScene.add(ball);
        this.thrownBalls.push(ball);
        this.ballCount++;
        document.getElementById('ballCountValue').textContent = this.ballCount;
        this.showDialogue("Threw a magic ball!");
      }

      jump() {
        if (this.player.y <= 0.5) {
          this.player.jumpVelocity = 0.3;
          this.showDialogue("Jump!");
        }
      }

      showDialogue(text) {
        const dialogue = document.getElementById('dialogue');
        dialogue.textContent = text;
        dialogue.style.display = 'block';
        setTimeout(() => { dialogue.style.display = 'none'; }, 2000);
      }

      toggleCollisionBoxes() {
        if (!this.collisionBoxes) {
          this.collisionBoxes = [];
          for (const obj of this.outsideObjects) {
            if (obj.type !== 'ground') {
              const box = new THREE.Mesh(
                new THREE.SphereGeometry(obj.boundingRadius, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
              );
              box.position.set(obj.x, obj.boundingRadius, obj.z);
              activeScene.add(box);
              this.collisionBoxes.push(box);
            }
          }
        } else {
          for (const box of this.collisionBoxes) {
            activeScene.remove(box);
          }
          this.collisionBoxes = null;
        }
      }

      updateEnemies() {
        for (const obj of this.outsideObjects) {
          if (obj.type === 'enemy') {
            obj.x += obj.direction * 0.05;
            if (obj.x > obj.range.max) {
              obj.direction = -1;
            } else if (obj.x < obj.range.min) {
              obj.direction = 1;
            }
            obj.mesh.position.x = obj.x;
          }
        }
      }

      updateCompass() {
        let nearest = null;
        let minDist = Infinity;
        for (const obj of this.outsideObjects) {
          if (obj.type === 'flower' || obj.type === 'coin' || obj.type === 'gem' || obj.type === 'potion' || obj.type === 'key' || obj.type === 'artifact') {
            const dx = obj.x - this.player.x;
            const dz = obj.z - this.player.z;
            const dist = dx * dx + dz * dz;
            if (dist < minDist) {
              minDist = dist;
              nearest = obj;
            }
          }
        }
        if (nearest) {
          const angle = Math.atan2(nearest.z - this.player.z, nearest.x - this.player.x) - this.player.yaw;
          const direction = Math.round((angle / (Math.PI / 4)) % 8);
          const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
          document.getElementById('compass').textContent = `Compass: ${directions[direction]}`;
        }
      }

      initKeyboardMouse() {
        document.addEventListener('keydown', e => {
          this.keysPressed[e.key] = true;
          if (e.key === ' ') this.throwBall();
          if (e.key === 'b' || e.key === 'B') this.jump();
          if (e.key === 'c' || e.key === 'C') this.toggleCollisionBoxes();
        });
        document.addEventListener('keyup', e => { this.keysPressed[e.key] = false; });
      }

      startAnimation() {
        const animate = () => {
          requestAnimationFrame(animate);
          this.update();
          this.renderer.render(activeScene, camera);
        };
        animate();
      }

      update() {
        gameTime += 1 / 60; // Assuming 60 FPS
        const dayCycle = (gameTime % 600) / 600; // 10 second cycle
        document.getElementById('time').textContent = dayCycle < 0.5 ? "Day" : "Night";
        this.updateMovement();
        this.updateBalls();
        this.updateEnemies();
        this.updateCompass();
        this.updateCamera();
      }

      updateCamera() {
        const offset = new THREE.Vector3(Math.sin(this.player.yaw) * -10, 5, Math.cos(this.player.yaw) * -10);
        camera.position.copy(this.player.object.position).add(offset);
        camera.lookAt(this.player.object.position);
      }
    }

    try {
      window.game = new Game();
    } catch (err) {
      console.error('Error initializing the game:', err);
    }
  </script>
</body>
</html>
