<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Princess Adventure - Enhanced SNES Style</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(to bottom, #87ceeb, #e0ffff);
        }
        canvas {
            border: 1px solid black;
            background-color: #228b22;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1024" height="768"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 32;
        let score = 0;
        let currentScene = 'town';
        let fadeAlpha = 0;
        let isFading = false;
        let fadeDirection = 1;
        let targetScene = '';

        // Maps with more detailed grids
        const townMap = {
            grid: Array.from({ length: 24 }, () => Array(32).fill(0)), // 0: grass, 1: wall, 2: door
            items: [
                {x: 4 * tileSize, y: 4 * tileSize, type: 'flower', points: 10, collected: false},
                {x: 6 * tileSize, y: 8 * tileSize, type: 'coin', points: 5, collected: false},
                {x: 12 * tileSize, y: 5 * tileSize, type: 'flower', points: 10, collected: false},
                {x: 14 * tileSize, y: 9 * tileSize, type: 'coin', points: 5, collected: false}
            ],
            doors: [
                {x: 2 * tileSize, y: 2 * tileSize, width: tileSize, height: tileSize, target: 'castle'},
                {x: 28 * tileSize, y: 2 * tileSize, width: tileSize, height: tileSize, target: 'house'}
            ]
        };

        const castleMap = {
            grid: Array.from({ length: 12 }, () => Array(16).fill(0)),
            items: [],
            doors: [
                {x: 8 * tileSize, y: 10 * tileSize, width: tileSize, height: tileSize, target: 'town'}
            ]
        };

        const houseMap = {
            grid: Array.from({ length: 8 }, () => Array(12).fill(0)),
            items: [],
            doors: [
                {x: 6 * tileSize, y: 6 * tileSize, width: tileSize, height: tileSize, target: 'town'}
            ]
        };

        // Princess object with animation
        let princess = {
            x: 5 * tileSize,
            y: 5 * tileSize,
            width: tileSize,
            height: tileSize,
            speed: 4,
            direction: 'down',
            frame: 0,
            animationCounter: 0
        };

        // Keyboard input
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Helper functions
        function getCurrentMap() {
            return currentScene === 'town' ? townMap : currentScene === 'castle' ? castleMap : houseMap;
        }

        function checkCollision(x, y) {
            const map = getCurrentMap().grid;
            const col = Math.floor(x / tileSize);
            const row = Math.floor(y / tileSize);
            return row < 0 || row >= map.length || col < 0 || col >= map[0].length || map[row][col] === 1;
        }

        function checkItemCollection() {
            const items = getCurrentMap().items;
            for (let item of items) {
                if (!item.collected &&
                    princess.x < item.x + tileSize &&
                    princess.x + princess.width > item.x &&
                    princess.y < item.y + tileSize &&
                    princess.y + princess.height > item.y) {
                    item.collected = true;
                    score += item.points;
                }
            }
        }

        function checkDoorInteraction() {
            const doors = getCurrentMap().doors;
            for (let door of doors) {
                if (princess.x < door.x + door.width &&
                    princess.x + princess.width > door.x &&
                    princess.y < door.y + door.height &&
                    princess.y + princess.height > door.y) {
                    targetScene = door.target;
                    isFading = true;
                    fadeDirection = 1;
                    return;
                }
            }
        }

        // Drawing functions with enhanced detail
        function drawMap() {
            const map = getCurrentMap().grid;
            for (let row = 0; row < map.length; row++) {
                for (let col = 0; col < map[row].length; col++) {
                    if (map[row][col] === 0) {
                        // Detailed grass
                        ctx.fillStyle = '#32cd32';
                        ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                        ctx.fillStyle = '#228b22';
                        ctx.fillRect(col * tileSize + 4, row * tileSize + 4, tileSize - 8, tileSize - 8);
                    } else if (map[row][col] === 1) {
                        // Detailed wall
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                        ctx.fillStyle = '#a9a9a9';
                        ctx.fillRect(col * tileSize + 2, row * tileSize + 2, tileSize - 4, tileSize - 4);
                    } else if (map[row][col] === 2) {
                        // Detailed door
                        ctx.fillStyle = '#0000ff';
                        ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                        ctx.fillStyle = '#00008b';
                        ctx.fillRect(col * tileSize + 4, row * tileSize + 4, tileSize - 8, tileSize - 8);
                    }
                }
            }
            // Add building details in town
            if (currentScene === 'town') {
                // Castle
                ctx.fillStyle = '#696969';
                ctx.fillRect(1 * tileSize, 1 * tileSize, tileSize * 4, tileSize * 4);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(1 * tileSize + 4, 1 * tileSize - 8, tileSize * 4 - 8, 8);
                // House
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(26 * tileSize, 1 * tileSize, tileSize * 4, tileSize * 4);
                ctx.fillStyle = '#cd853f';
                ctx.fillRect(26 * tileSize + 4, 1 * tileSize - 8, tileSize * 4 - 8, 8);
            }
        }

        function drawItems() {
            const items = getCurrentMap().items;
            for (let item of items) {
                if (!item.collected) {
                    if (item.type === 'flower') {
                        // Detailed flower
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(item.x + 8, item.y + 8, 16, 16);
                        ctx.fillStyle = '#ff4500';
                        ctx.fillRect(item.x + 12, item.y + 12, 8, 8);
                        ctx.fillStyle = '#006400';
                        ctx.fillRect(item.x + 14, item.y + 20, 4, 12);
                    } else {
                        // Detailed coin
                        ctx.fillStyle = '#ffa500';
                        ctx.fillRect(item.x + 8, item.y + 8, 16, 16);
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(item.x + 10, item.y + 10, 8, 8);
                    }
                }
            }
        }

        function drawPrincess() {
            princess.animationCounter++;
            if (princess.animationCounter % 10 === 0) {
                princess.frame = (princess.frame + 1) % 2;
            }
            // Dress
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(princess.x + 4, princess.y + 8, 24, 20);
            // Head
            ctx.fillStyle = '#ffdab9';
            ctx.fillRect(princess.x + 8, princess.y, 16, 12);
            // Crown
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(princess.x + 10, princess.y - 4, 12, 6);
            // Legs animation
            ctx.fillStyle = '#000000';
            if (princess.frame === 0) {
                ctx.fillRect(princess.x + 8, princess.y + 28, 4, 4);
                ctx.fillRect(princess.x + 20, princess.y + 28, 4, 4);
            } else {
                ctx.fillRect(princess.x + 12, princess.y + 28, 4, 4);
                ctx.fillRect(princess.x + 16, princess.y + 28, 4, 4);
            }
        }

        function handleFade() {
            if (isFading) {
                fadeAlpha += 0.05 * fadeDirection;
                if (fadeAlpha >= 1 && fadeDirection === 1) {
                    currentScene = targetScene;
                    if (currentScene === 'town') {
                        princess.x = targetScene === 'castle' ? 2 * tileSize : 28 * tileSize;
                        princess.y = 3 * tileSize;
                    } else if (currentScene === 'castle') {
                        princess.x = 8 * tileSize;
                        princess.y = 2 * tileSize;
                    } else if (currentScene === 'house') {
                        princess.x = 6 * tileSize;
                        princess.y = 2 * tileSize;
                    }
                    fadeDirection = -1;
                } else if (fadeAlpha <= 0 && fadeDirection === -1) {
                    isFading = false;
                    fadeAlpha = 0;
                }
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Game loop
        function gameLoop() {
            if (!isFading) {
                let dx = 0, dy = 0;
                if (keys['ArrowLeft']) { dx -= princess.speed; princess.direction = 'left'; }
                if (keys['ArrowRight']) { dx += princess.speed; princess.direction = 'right'; }
                if (keys['ArrowUp']) { dy -= princess.speed; princess.direction = 'up'; }
                if (keys['ArrowDown']) { dy += princess.speed; princess.direction = 'down'; }

                const newX = princess.x + dx;
                const newY = princess.y + dy;
                if (!checkCollision(newX, princess.y)) princess.x = newX;
                if (!checkCollision(princess.x, newY)) princess.y = newY;

                checkItemCollection();
                checkDoorInteraction();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMap();
            drawItems();
            drawPrincess();
            handleFade();

            ctx.fillStyle = '#ffffff';
            ctx.font = '20px "Press Start 2P", Arial';
            ctx.fillText(`Score: ${score}`, 10, 30);

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
