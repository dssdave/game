<!DOCTYPE html>
<html>
<head>
    <title>Simplified 3D Princess RPG</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
        #ballCount {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 5px;
            z-index: 10;
        }
        #dialogue {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 600px;
            z-index: 10;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #fff;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
        #errorMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 5px;
            z-index: 20;
            display: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            z-index: 20;
        }
        #joystickLeft, #joystickRight {
            position: absolute;
            width: 150px;
            height: 150px;
            opacity: 0.5;
            z-index: 15;
        }
        #joystickLeft { bottom: 20px; left: 20px; }
        #joystickRight { bottom: 20px; right: 20px; }
    </style>
    <!-- Include Three.js and NippleJS from CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            Flowers: <span id="flowers">0</span> | 
            Coins: <span id="coins">0</span> | 
            Gems: <span id="gems">0</span> | 
            Potions: <span id="potions">0</span> | 
            Keys: <span id="keys">0</span> | 
            Artifacts: <span id="artifacts">0</span> | 
            Health: <span id="health">100</span> | 
            Mana: <span id="mana">50</span> | 
            Time: <span id="time">Day</span> | 
            Location: <span id="location">Town</span>
        </div>
        <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
        <div id="dialogue"></div>
        <div id="controls">
            Controls:<br>
            Joysticks/Arrow Keys: Move<br>
            Joysticks/Mouse: Look Around<br>
            Tap Center/Space: Throw Ball
        </div>
        <div id="joystickLeft"></div>
        <div id="joystickRight"></div>
        <div id="errorMessage">WebGL is not supported in your browser. Please use a modern browser like Chrome, Firefox, or Edge.</div>
        <div id="loading">Loading game... Please wait.</div>
    </div>

    <script>
        // Error handling for WebGL and loading state
        try {
            const loadingElement = document.getElementById('loading');
            const errorMessage = document.getElementById('errorMessage');
            const gameCanvas = document.getElementById('gameCanvas');

            if (!window.WebGLRenderingContext) {
                errorMessage.style.display = 'block';
                loadingElement.style.display = 'none';
                gameCanvas.style.display = 'none';
                document.getElementById('ui').style.display = 'none';
                document.getElementById('ballCount').style.display = 'none';
                document.getElementById('dialogue').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                document.getElementById('joystickLeft').style.display = 'none';
                document.getElementById('joystickRight').style.display = 'none';
                throw new Error('WebGL not supported');
            }

            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Hide loading and show canvas immediately
            loadingElement.style.display = 'none';
            gameCanvas.style.display = 'block';

            // Game state
            let game;

            class Game {
                constructor() {
                    this.scene = 'town';
                    this.flowers = 0;
                    this.coins = 0;
                    this.gems = 0;
                    this.potions = 0;
                    this.keys = 0;
                    this.artifacts = 0;
                    this.health = 100;
                    this.mana = 50;
                    this.time = 'Day';
                    this.dayNightCycle = 0;
                    this.player = {
                        x: 0,
                        z: 0,
                        speed: 0.5,
                        yaw: 0,
                        pitch: 0,
                        object: null
                    };
                    this.dialogue = '';
                    this.dialogueTimer = 0;
                    this.objects = [];
                    this.npcs = [];
                    this.quests = {
                        townGuard: { active: false, completed: false },
                        castleKing: { active: false, completed: false },
                        villager: { active: false, completed: false },
                        storyteller: { active: false, completed: false }
                    };
                    this.ballCount = 0;
                    this.ballLimit = 1000000;
                    this.thrownBalls = [];
                    this.collectionGlow = null;
                    this.joystickLeft = null;
                    this.joystickRight = null;
                    this.keys = {};
                    this.initScene();
                    this.initJoysticks();
                    this.initKeyboardMouse();
                }
                showDialogue(text) {
                    this.dialogue = text;
                    this.dialogueTimer = 120;
                    document.getElementById('dialogue').textContent = this.dialogue;
                }
                updateDayNight() {
                    this.dayNightCycle = (this.dayNightCycle + 1) % 1200;
                    this.time = this.dayNightCycle < 600 ? 'Day' : 'Night';
                    document.getElementById('time').textContent = this.time;
                }
                throwBall() {
                    if (this.ballCount < this.ballLimit && this.mana >= 5) {
                        this.mana -= 5;
                        const ballGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                        const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xff4500, metalness: 0.1, roughness: 0.7 });
                        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
                        ball.position.copy(this.player.object.position);
                        ball.position.y += 1;
                        const direction = new THREE.Vector3(Math.cos(this.player.yaw), 0, Math.sin(this.player.yaw)).normalize();
                        ball.userData = { velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0, 0.3, 0)) };
                        scene.add(ball);
                        this.thrownBalls.push(ball);
                        this.ballCount++;
                        document.getElementById('ballCountValue').textContent = this.ballCount;
                        this.showDialogue('Threw a magic ball!');
                        document.getElementById('mana').textContent = this.mana;
                    } else if (this.ballCount >= this.ballLimit) {
                        this.showDialogue('Reached maximum ball throws (1,000,000)!');
                    } else {
                        this.showDialogue('Not enough mana to throw a ball!');
                    }
                }
                startCollectionGlow() {
                    if (this.collectionGlow) scene.remove(this.collectionGlow);
                    const glowGeometry = new THREE.SphereGeometry(1, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffff00, 
                        transparent: true, 
                        opacity: 0.5,
                        side: THREE.BackSide 
                    });
                    this.collectionGlow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.collectionGlow.position.copy(this.player.object.position);
                    this.collectionGlow.position.y += 0.5;
                    scene.add(this.collectionGlow);
                    setTimeout(() => {
                        if (this.collectionGlow) {
                            scene.remove(this.collectionGlow);
                            this.collectionGlow = null;
                        }
                    }, 1000);
                }
                initScene() {
                    // Ground
                    const groundGeometry = new THREE.PlaneGeometry(100, 100);
                    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x6bb26b, side: THREE.DoubleSide });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = Math.PI / 2;
                    ground.castShadow = true;
                    ground.receiveShadow = true;
                    scene.add(ground);

                    // Skybox
                    const skyGeometry = new THREE.SphereGeometry(500, 60, 40);
                    const skyMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            topColor: { value: new THREE.Color(0x87ceeb) },
                            bottomColor: { value: new THREE.Color(0x2f4f4f) },
                            offset: { value: 0.5 },
                            exponent: { value: 0.6 }
                        },
                        vertexShader: `
                            varying vec3 vWorldPosition;
                            void main() {
                                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                                vWorldPosition = worldPosition.xyz;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 topColor;
                            uniform vec3 bottomColor;
                            uniform float offset;
                            uniform float exponent;
                            varying vec3 vWorldPosition;
                            void main() {
                                float h = normalize(vWorldPosition + offset).y;
                                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                            }
                        `,
                        side: THREE.BackSide
                    });
                    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                    sky.material.uniforms.topColor.value.set(this.time === 'Day' ? 0x87ceeb : 0x2f4f4f);
                    sky.material.uniforms.bottomColor.value.set(this.time === 'Day' ? 0x87ceeb : 0x2f4f4f);
                    sky.name = 'sky';
                    scene.add(sky);

                    // Princess (Nintendo 64-style low-poly)
                    const princessGroup = new THREE.Group();
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff69b4, metalness: 0.1, roughness: 0.5 });
                    const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xffe4c4, metalness: 0.1, roughness: 0.5 });
                    const goldMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.2 });

                    // Torso
                    for (let i = 0; i < 3; i++) {
                        const torsoSegment = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), bodyMaterial);
                        torsoSegment.position.y = 0.6 + i * 0.4;
                        princessGroup.add(torsoSegment);
                    }

                    // Head
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), skinMaterial);
                    head.position.y = 1.5;
                    princessGroup.add(head);

                    // Facial features
                    const eyeSize = 0.05;
                    const leftEye = new THREE.Mesh(new THREE.BoxGeometry(eyeSize, eyeSize, eyeSize), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                    leftEye.position.set(-0.15, 1.6, 0.3);
                    const rightEye = new THREE.Mesh(new THREE.BoxGeometry(eyeSize, eyeSize, eyeSize), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                    rightEye.position.set(0.15, 1.6, 0.3);
                    const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.05), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                    mouth.position.set(0, 1.45, 0.3);
                    const leftBlush = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.05), new THREE.MeshStandardMaterial({ color: 0xff8c8c }));
                    leftBlush.position.set(-0.15, 1.5, 0.3);
                    const rightBlush = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.05), new THREE.MeshStandardMaterial({ color: 0xff8c8c }));
                    rightBlush.position.set(0.15, 1.5, 0.3);
                    head.add(leftEye, rightEye, mouth, leftBlush, rightBlush);

                    // Arms
                    const armSize = 0.2;
                    const leftArm = new THREE.Mesh(new THREE.BoxGeometry(armSize, armSize, armSize), bodyMaterial);
                    leftArm.position.set(-0.4, 1.0, 0);
                    const rightArm = new THREE.Mesh(new THREE.BoxGeometry(armSize, armSize, armSize), bodyMaterial);
                    rightArm.position.set(0.4, 1.0, 0);
                    princessGroup.add(leftArm, rightArm);

                    // Legs
                    const legSize = 0.2;
                    const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(legSize, legSize, legSize), bodyMaterial);
                    leftLeg.position.set(-0.15, 0.3, 0);
                    const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(legSize, legSize, legSize), bodyMaterial);
                    rightLeg.position.set(0.15, 0.3, 0);
                    princessGroup.add(leftLeg, rightLeg);

                    // Crown
                    const crownSize = 0.05;
                    const crownBase = new THREE.Mesh(new THREE.BoxGeometry(0.4, crownSize, 0.4), goldMaterial);
                    crownBase.position.y = 1.9;
                    const crownSpike1 = new THREE.Mesh(new THREE.BoxGeometry(crownSize, 0.2, crownSize), goldMaterial);
                    crownSpike1.position.set(0, 2.0, 0.2);
                    const crownSpike2 = new THREE.Mesh(new THREE.BoxGeometry(crownSize, 0.2, crownSize), goldMaterial);
                    crownSpike2.position.set(0, 2.0, -0.2);
                    const crownSpike3 = new THREE.Mesh(new THREE.BoxGeometry(crownSize, 0.2, crownSize), goldMaterial);
                    crownSpike3.position.set(0.2, 2.0, 0);
                    const crownSpike4 = new THREE.Mesh(new THREE.BoxGeometry(crownSize, 0.2, crownSize), goldMaterial);
                    crownSpike4.position.set(-0.2, 2.0, 0);
                    princessGroup.add(crownBase, crownSpike1, crownSpike2, crownSpike3, crownSpike4);

                    // Jewelry
                    const necklaceCube = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.05), goldMaterial);
                    necklaceCube.position.set(0, 1.0, 0.3);
                    const leftEarring = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.05), goldMaterial);
                    leftEarring.position.set(-0.4, 1.5, 0.3);
                    const rightEarring = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.05), goldMaterial);
                    rightEarring.position.set(0.4, 1.5, 0.3);
                    princessGroup.add(necklaceCube, leftEarring, rightEarring);

                    princessGroup.position.set(this.player.x, 0.5, this.player.z);
                    this.player.object = princessGroup;
                    scene.add(princessGroup);

                    // Walking animation
                    this.player.object.traverse(child => {
                        if (child.isMesh && child.material.color.equals(new THREE.Color(0xff69b4))) {
                            child.userData.originalRotation = child.rotation.clone();
                        }
                    });

                    // Lighting
                    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                    scene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(10, 20, 10);
                    directionalLight.castShadow = true;
                    directionalLight.shadow.mapSize.width = 1024;
                    directionalLight.shadow.mapSize.height = 1024;
                    directionalLight.shadow.camera.near = 0.5;
                    directionalLight.shadow.camera.far = 50;
                    scene.add(directionalLight);

                    // Simplified objects (fewer for performance)
                    const castleGeometry = new THREE.BoxGeometry(10, 5, 10);
                    const castleMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
                    const castle = new THREE.Mesh(castleGeometry, castleMaterial);
                    castle.position.set(30, 2.5, 30);
                    castle.castShadow = true;
                    castle.receiveShadow = true;
                    this.objects.push({ mesh: castle, type: 'building', x: 30, z: 30 });

                    const houseGeometry = new THREE.BoxGeometry(5, 3, 5);
                    const houseMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                    const house = new THREE.Mesh(houseGeometry, houseMaterial);
                    house.position.set(-30, 1.5, -30);
                    house.castShadow = true;
                    house.receiveShadow = true;
                    this.objects.push({ mesh: house, type: 'building', x: -30, z: -30 });

                    const storybookBaseGeometry = new THREE.BoxGeometry(4, 3, 4);
                    const storybookBaseMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
                    const storybookBase = new THREE.Mesh(storybookBaseGeometry, storybookBaseMaterial);
                    storybookBase.position.set(20, 1.5, 20);
                    storybookBase.castShadow = true;
                    storybookBase.receiveShadow = true;

                    const storybookRoofGeometry = new THREE.ConeGeometry(2.5, 3, 32);
                    const storybookRoofMaterial = new THREE.MeshStandardMaterial({ color: 0x800000 });
                    const storybookRoof = new THREE.Mesh(storybookRoofGeometry, storybookRoofMaterial);
                    storybookRoof.position.set(20, 4, 20);
                    storybookRoof.castShadow = true;
                    storybookRoof.receiveShadow = true;

                    const storybookGroup = new THREE.Group();
                    storybookGroup.add(storybookBase, storybookRoof);
                    this.objects.push({ mesh: storybookGroup, type: 'building', x: 20, z: 20 });

                    const flowerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xff00ff });
                    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.set(5, 0.3, 5);
                    flower.castShadow = true;
                    this.objects.push({ mesh: flower, type: 'flower', x: 5, z: 5 });

                    this.objects.forEach(obj => scene.add(obj.mesh));
                }
                initJoysticks() {
                    this.joystickLeft = nipplejs.create({
                        zone: document.getElementById('joystickLeft'),
                        mode: 'static',
                        position: { left: '50px', bottom: '50px' },
                        color: 'white',
                        size: 100
                    });

                    this.joystickLeft.on('move', (evt, data) => {
                        if (data.force > 0) {
                            const angle = data.angle.radian;
                            const speed = data.force * this.player.speed;
                            const dx = Math.cos(angle) * speed;
                            const dz = Math.sin(angle) * speed;
                            const newX = this.player.x + dx;
                            const newZ = this.player.z - dz;

                            if (!this.objects.some(obj => {
                                const distX = Math.abs(obj.x - newX);
                                const distZ = Math.abs(obj.z - newZ);
                                return (obj.type === 'building' || obj.type === 'boundary') && distX < 3 && distZ < 3;
                            })) {
                                this.player.x = newX;
                                this.player.z = newZ;
                            }
                        }
                    });

                    this.joystickLeft.on('end', () => {});

                    this.joystickRight = nipplejs.create({
                        zone: document.getElementById('joystickRight'),
                        mode: 'static',
                        position: { right: '50px', bottom: '50px' },
                        color: 'white',
                        size: 100
                    });

                    this.joystickRight.on('move', (evt, data) => {
                        if (data.force > 0) {
                            const sensitivity = 0.002;
                            this.player.yaw += data.vector.x * sensitivity * data.force;
                            this.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.player.pitch + data.vector.y * sensitivity * data.force));
                        }
                    });

                    this.joystickRight.on('end', () => {});

                    document.getElementById('gameContainer').addEventListener('click', (e) => {
                        const rect = document.getElementById('gameContainer').getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        if (x > rect.width / 4 && x < rect.width * 3 / 4 && y > rect.height / 4 && y < rect.height * 3 / 4) {
                            this.throwBall();
                        }
                    });
                }
                initKeyboardMouse() {
                    document.addEventListener('keydown', (e) => {
                        this.keys[e.key] = true;
                        if (e.key === ' ') this.throwBall();
                    });
                    document.addEventListener('keyup', (e) => {
                        this.keys[e.key] = false;
                    });

                    document.addEventListener('mousedown', () => {
                        document.body.requestPointerLock();
                    });

                    document.addEventListener('mousemove', (event) => {
                        if (document.pointerLockElement === document.body) {
                            const movementX = event.movementX || 0;
                            const movementY = event.movementY || 0;
                            this.player.yaw += movementX * 0.002;
                            this.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.player.pitch + movementY * 0.002));
                        }
                    });
                }
                createNPCs(scene) {
                    const npcs = [];
                    if (scene === 'town') {
                        const npcGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
                        const npcMaterial = new THREE.MeshStandardMaterial({ color: 0x00008b });
                        const guard = new THREE.Mesh(npcGeometry, npcMaterial);
                        guard.position.set(0, 1, 0);
                        guard.castShadow = true;
                        npcs.push({ mesh: guard, x: 0, z: 0, role: 'guard' });
                    }
                    return npcs;
                }
                updateObjects() {
                    scene.remove(...this.objects.map(obj => obj.mesh));
                    scene.remove(...this.npcs.map(npc => npc.mesh));
                    this.objects = [];
                    this.npcs = this.createNPCs(this.scene);
                    this.objects.push({ mesh: this.player.object, type: 'player', x: this.player.x, z: this.player.z });
                    this.objects.push(...this.createBuildings());
                    this.npcs.forEach(npc => scene.add(npc.mesh));
                    this.objects.forEach(obj => scene.add(obj.mesh));
                }
                createBuildings() {
                    const buildings = [];
                    const castleGeometry = new THREE.BoxGeometry(10, 5, 10);
                    const castleMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
                    const castle = new THREE.Mesh(castleGeometry, castleMaterial);
                    castle.position.set(30, 2.5, 30);
                    castle.castShadow = true;
                    castle.receiveShadow = true;
                    buildings.push({ mesh: castle, type: 'building', x: 30, z: 30 });

                    const houseGeometry = new THREE.BoxGeometry(5, 3, 5);
                    const houseMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                    const house = new THREE.Mesh(houseGeometry, houseMaterial);
                    house.position.set(-30, 1.5, -30);
                    house.castShadow = true;
                    house.receiveShadow = true;
                    buildings.push({ mesh: house, type: 'building', x: -30, z: -30 });

                    const storybookBaseGeometry = new THREE.BoxGeometry(4, 3, 4);
                    const storybookBaseMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
                    const storybookBase = new THREE.Mesh(storybookBaseGeometry, storybookBaseMaterial);
                    storybookBase.position.set(20, 1.5, 20);
                    storybookBase.castShadow = true;
                    storybookBase.receiveShadow = true;

                    const storybookRoofGeometry = new THREE.ConeGeometry(2.5, 3, 32);
                    const storybookRoofMaterial = new THREE.MeshStandardMaterial({ color: 0x800000 });
                    const storybookRoof = new THREE.Mesh(storybookRoofGeometry, storybookRoofMaterial);
                    storybookRoof.position.set(20, 4, 20);
                    storybookRoof.castShadow = true;
                    storybookRoof.receiveShadow = true;

                    const storybookGroup = new THREE.Group();
                    storybookGroup.add(storybookBase, storybookRoof);
                    buildings.push({ mesh: storybookGroup, type: 'building', x: 20, z: 20 });

                    const flowerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xff00ff });
                    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.set(5, 0.3, 5);
                    flower.castShadow = true;
                    buildings.push({ mesh: flower, type: 'flower', x: 5, z: 5 });

                    return buildings;
                }
            }

            // Initialize game
            game = new Game();

            // Camera setup
            camera.position.set(0, 10, 20);
            camera.lookAt(0, 0, 0);

            // Update and render loop
            function update() {
                game.updateDayNight();

                let dx = 0, dz = 0;
                if (game.keys['ArrowUp'] || (game.joystickLeft && game.joystickLeft.getActiveIds().length > 0)) {
                    dz -= game.player.speed;
                }
                if (game.keys['ArrowDown']) {
                    dz += game.player.speed;
                }
                if (game.keys['ArrowLeft']) {
                    dx -= game.player.speed;
                }
                if (game.keys['ArrowRight']) {
                    dx += game.player.speed;
                }

                const newX = game.player.x + dx * Math.cos(game.player.yaw) + dz * Math.sin(game.player.yaw);
                const newZ = game.player.z - dx * Math.sin(game.player.yaw) + dz * Math.cos(game.player.yaw);

                if (!game.objects.some(obj => {
                    const distX = Math.abs(obj.x - newX);
                    const distZ = Math.abs(obj.z - newZ);
                    return (obj.type === 'building' || obj.type === 'boundary') && distX < 3 && distZ < 3;
                })) {
                    game.player.x = newX;
                    game.player.z = newZ;
                }

                game.player.object.position.set(game.player.x, 0.5, game.player.z);
                game.player.object.rotation.y = -game.player.yaw;

                if (Object.values(game.keys).some(k => k) || (game.joystickLeft && game.joystickLeft.getActiveIds().length > 0)) {
                    game.player.object.traverse(child => {
                        if (child.isMesh && child.material.color.equals(new THREE.Color(0xff69b4))) {
                            child.rotation.z = Math.sin(Date.now() * 0.005) * 0.1;
                        }
                    });
                } else {
                    game.player.object.traverse(child => {
                        if (child.isMesh && child.material.color.equals(new THREE.Color(0xff69b4))) {
                            child.rotation.copy(child.userData.originalRotation || new THREE.Euler());
                        }
                    });
                }

                camera.position.set(
                    game.player.x + 15 * Math.sin(game.player.yaw) * Math.cos(game.player.pitch),
                    15 + 15 * Math.sin(game.player.pitch),
                    game.player.z + 15 * Math.cos(game.player.yaw) * Math.cos(game.player.pitch)
                );
                camera.lookAt(game.player.x, 0.5, game.player.z);

                game.thrownBalls.forEach((ball, index) => {
                    ball.position.add(ball.userData.velocity);
                    ball.userData.velocity.y -= 0.01;
                    if (ball.position.y < 0) {
                        scene.remove(ball);
                        game.thrownBalls.splice(index, 1);
                    }
                });

                game.npcs.forEach(npc => {
                    const distX = Math.abs(npc.x - game.player.x);
                    const distZ = Math.abs(npc.z - game.player.z);
                    if (distX < 2 && distZ < 2) {
                        if (npc.role === 'guard' && !game.quests.townGuard.completed) {
                            if (!game.quests.townGuard.active) {
                                game.showDialogue('Town Guard: Princess, the king needs a flower for his crown. Bring one to the castle!');
                                game.quests.townGuard.active = true;
                            } else if (game.flowers > 0) {
                                game.showDialogue('Town Guard: Thank you! Hereâ€™s a key.');
                                game.keys++;
                                game.flowers--;
                                game.quests.townGuard.completed = true;
                            } else {
                                game.showDialogue('Town Guard: Do you have a flower for the king?');
                            }
                        }
                    }
                });

                game.objects.forEach(obj => {
                    const distX = Math.abs(obj.x - game.player.x);
                    const distZ = Math.abs(obj.z - game.player.z);
                    if (distX < 1 && distZ < 1) {
                        if (obj.type === 'flower') {
                            game.flowers++;
                            scene.remove(obj.mesh);
                            game.objects = game.objects.filter(o => o !== obj);
                            game.showDialogue('You picked a radiant flower! *Sparkle*');
                            game.startCollectionGlow();
                            document.getElementById('flowers').textContent = game.flowers;
                        }
                    }
                });

                const sky = scene.getObjectByName('sky');
                if (sky) {
                    sky.material.uniforms.topColor.value.set(game.time === 'Day' ? 0x87ceeb : 0x2f4f4f);
                    sky.material.uniforms.bottomColor.value.set(game.time === 'Day' ? 0x87ceeb : 0x2f4f4f);
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                update();
                renderer.render(scene, camera);
            }

            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        } catch (error) {
            console.error('WebGL Error:', error);
            const loadingElement = document.getElementById('loading');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.style.display = 'block';
            loadingElement.style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('ballCount').style.display = 'none';
            document.getElementById('dialogue').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('joystickLeft').style.display = 'none';
            document.getElementById('joystickRight').style.display = 'none';
        }
    </script>
</body>
</html>
