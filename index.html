<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Prevent iPhone from zooming on taps, etc. -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Princess Donia’s Town – SNES-Style Controller</title>
    <style>
      /* Basic resets to avoid text selection highlighting on iOS */
      html, body {
        margin: 0;
        padding: 0;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        user-select: none;
        touch-action: manipulation;
        background: #000;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas { display: block; }

      /* UI boxes (desktop scale) */
      #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
        background: rgba(0,0,0,0.7);
        border: 4px solid #fff;
        border-radius: 5px;
        color: #fff;
        font-size: 28px;
        padding: 40px 80px;
        position: absolute;
        z-index: 10;
      }
      #ui { top: 10px; left: 10px; }
      #ballCount { top: 10px; right: 10px; }
      #dialogue { bottom: 10px; left: 10px; max-width: 600px; }
      #controls { bottom: 10px; right: 10px; }
      #errorMessage {
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        display: none;
        z-index: 20;
      }
      #guardPopup {
        bottom: 50%;
        left: 50%;
        transform: translate(-50%,50%);
        display: none;
        z-index: 50;
        text-align: center;
      }

      /* SNES-Style On-Screen Controller */
      /* D-Pad container: bottom-left */
      #dpadContainer {
        position: absolute;
        bottom: 10vh;
        left: 6vw;
        width: 120px;
        height: 120px;
        z-index: 15;
      }
      #dpadContainer button {
        position: absolute;
        width: 40px;
        height: 40px;
        background: rgba(255,255,255,0.3);
        border: 2px solid #fff;
        border-radius: 5px;
        font-size: 18px;
        color: #fff;
        cursor: pointer;
      }
      #btnUp    { top: 0;    left: 40px; }
      #btnDown  { bottom: 0; left: 40px; }
      #btnLeft  { left: 0;   top: 40px; }
      #btnRight { right: 0;  top: 40px; }

      /* Turn buttons: bottom-right, stacked */
      #turnContainer {
        position: absolute;
        bottom: 10vh;
        right: 12vw;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 15;
      }
      #turnContainer button {
        width: 60px;
        height: 60px;
        background: rgba(255,255,255,0.3);
        border: 2px solid #fff;
        border-radius: 50%;
        font-size: 16px;
        color: #fff;
        cursor: pointer;
      }

      /* Action buttons: next to turn buttons, SNES style */
      #actionContainer {
        position: absolute;
        bottom: 10vh;
        right: 4vw;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 15;
      }
      #actionContainer button {
        width: 60px;
        height: 60px;
        background: rgba(255,255,255,0.3);
        border: 2px solid #fff;
        border-radius: 50%;
        font-size: 16px;
        color: #fff;
        cursor: pointer;
      }

      /* Toggle UI button (top center) */
      #toggleUIBtn {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 11;
        font-size: 24px;
        padding: 10px 20px;
        background: #333;
        color: #fff;
        border: 2px solid #fff;
        border-radius: 5px;
        cursor: pointer;
      }

      /* Scale down on narrower screens */
      @media (max-width: 768px) {
        #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
          font-size: 16px;
          padding: 20px 30px;
        }
        #toggleUIBtn { font-size: 16px; }
        #dpadContainer {
          width: 90px; height: 90px;
        }
        #dpadContainer button {
          width: 30px; height: 30px; font-size: 14px;
        }
        #turnContainer button, #actionContainer button {
          width: 50px; height: 50px; font-size: 14px;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <button id="toggleUIBtn">Toggle UI</button>

      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>
      <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
      <div id="dialogue"></div>
      <div id="controls">
        Controls:<br>
        D-Pad: Move<br>
        Turn Buttons: Rotate<br>
        Action Buttons: Throw Ball / Big Ball
      </div>
      <div id="errorMessage">WebGL not supported in your browser. Please use a modern browser.</div>
      <div id="guardPopup"></div>

      <!-- SNES-Style Controller -->
      <div id="dpadContainer">
        <button id="btnUp">▲</button>
        <button id="btnDown">▼</button>
        <button id="btnLeft">◀</button>
        <button id="btnRight">▶</button>
      </div>
      <div id="turnContainer">
        <button id="btnTurnLeft">L</button>
        <button id="btnTurnRight">R</button>
      </div>
      <div id="actionContainer">
        <button id="btnThrow">A</button>
        <button id="btnBigThrow">B</button>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Toggle UI button
      document.getElementById('toggleUIBtn').addEventListener('click', () => {
        for (const id of ["ui","ballCount","dialogue","controls","guardPopup","errorMessage"]) {
          const el = document.getElementById(id);
          el.style.display = (el.style.display==="none") ? "block" : "none";
        }
      });

      // Prevent iPhone from focusing / highlighting
      function disableHighlight(elId) {
        const btn = document.getElementById(elId);
        ["touchstart","mousedown"].forEach(evtType => {
          btn.addEventListener(evtType, e => e.preventDefault(), { passive:false });
        });
      }
      ["btnUp","btnDown","btnLeft","btnRight","btnTurnLeft","btnTurnRight","btnThrow","btnBigThrow"].forEach(disableHighlight);

      // Controller state
      const controllerState = {
        dpadUp: false,
        dpadDown: false,
        dpadLeft: false,
        dpadRight: false,
        turnLeft: false,
        turnRight: false
      };

      // Set up D-Pad/Turn button event listeners
      function setButtonListener(btnId, stateProp) {
        const btn = document.getElementById(btnId);
        // For both mouse and touch
        btn.addEventListener('mousedown',   () => { controllerState[stateProp]=true; });
        btn.addEventListener('touchstart', () => { controllerState[stateProp]=true; }, {passive:false});
        btn.addEventListener('mouseup',    () => { controllerState[stateProp]=false; });
        btn.addEventListener('touchend',   () => { controllerState[stateProp]=false; });
        btn.addEventListener('mouseleave', () => { controllerState[stateProp]=false; });
      }
      setButtonListener('btnUp','dpadUp');
      setButtonListener('btnDown','dpadDown');
      setButtonListener('btnLeft','dpadLeft');
      setButtonListener('btnRight','dpadRight');
      setButtonListener('btnTurnLeft','turnLeft');
      setButtonListener('btnTurnRight','turnRight');

      // We'll define game as a global variable so the action buttons can call game methods
      let game = null;

      // Action buttons
      document.getElementById('btnThrow').addEventListener('mousedown',  () => game?.throwBall());
      document.getElementById('btnThrow').addEventListener('touchstart', () => game?.throwBall(), {passive:false});
      document.getElementById('btnBigThrow').addEventListener('mousedown',  () => game?.throwBigBall());
      document.getElementById('btnBigThrow').addEventListener('touchstart', () => game?.throwBigBall(), {passive:false});

      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');
        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          throw new Error('WebGL not supported');
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameCanvas.style.display='block';

        class Game {
          constructor() {
            this.scene=scene;
            this.camera=camera;
            this.renderer=renderer;
            this.time='Day';
            this.dayNightCycle=0;
            this.player={
              x:0, z:0,
              speedKeyboard:0.1,
              speedController:0.08,
              yaw:0, pitch:-0.2,
              object:null,
              lastMoveVec:new THREE.Vector3(0,0,0),
              waterSplashTimer:0
            };
            this.flowers=0; this.coins=0; this.gems=0; this.potions=0; this.keys=0; this.artifacts=0;
            this.health=100;
            this.dialogue='';
            this.dialogueTimer=0;
            this.objects=[];
            this.buildingPositions=[];
            this.ballCount=0;
            this.thrownBalls=[];
            this.collectionGlow=null;
            this.keysPressed={};
            this.itemRange=80;
            // Day/Night
            this.sunMesh=null;
            this.moonMesh=null;
            this.starsMesh=null;
            // NPCs
            this.npcBlueData={ angle:0, speed:0.001, radius:120, object:null };
            this.npcYellowData={ object:null, speed:0.03, target:null };
            this.guardData={
              object:null,
              state:'idle',
              timer:0,
              route:[{x:30,z:40},{x:30,z:50},{x:50,z:50},{x:50,z:40},{x:40,z:40}],
              routeIndex:0,
              speed:0.02
            };
            this.mermaidData={ object:null, route:[{x:-15,z:-70},{x:15,z:-70}], routeIndex:0, speed:0.02, splashTimer:0 };
            // Bird
            this.birdData={ angle:0, speed:0.002, radius:140, object:null };
            // Interactions
            this.guardObject=null;
            this.guardMessageShown=false;
            this.npcBlueMessageShown=false;
            this.mermaidMessageShown=false;
            this.npcYellowMessageShown=false;

            this.initScene();
            this.initKeyboardMouse();
            this.startAnimation();
          }

          initScene(){
            // Ground
            const groundGeo=new THREE.PlaneGeometry(300,300);
            const groundMat=new THREE.MeshStandardMaterial({ color:0x6bb26b, side:THREE.DoubleSide });
            const ground=new THREE.Mesh(groundGeo,groundMat);
            ground.rotation.x=Math.PI/2;
            this.scene.add(ground);

            // Rolling hills
            for(let i=0;i<100;i++){
              const r=80+Math.random()*60;
              const x=(Math.random()>0.5?1:-1)*(300+Math.random()*500);
              const z=(Math.random()>0.5?1:-1)*(300+Math.random()*500);
              const hillGeo=new THREE.SphereGeometry(r,16,16);
              const hillMat=new THREE.MeshStandardMaterial({ color:0x228b22, roughness:0.9 });
              const hill=new THREE.Mesh(hillGeo,hillMat);
              hill.position.set(x,-r/2,z);
              this.scene.add(hill);
            }

            // Boundary ±130
            for(let x=-130;x<=130;x+=4){
              this.addShrub(x,-130);
              this.addShrub(x,130);
            }
            for(let z=-130;z<=130;z+=4){
              this.addShrub(-130,z);
              this.addShrub(130,z);
            }

            // Beach + water
            this.createBeach();

            // Lighting
            const ambient=new THREE.AmbientLight(0x404040,0.6);
            this.scene.add(ambient);
            const dirLight=new THREE.DirectionalLight(0xffffff,0.8);
            dirLight.position.set(10,20,10);
            this.scene.add(dirLight);

            // Sun, Moon, Stars
            this.createSun();
            this.createMoon();
            this.createStars();

            // Player (princess)
            this.createPlayerModel();

            // Buildings
            this.createCastle();
            this.createHouse();
            this.createCafe();
            this.createFountain();

            // NPCs
            this.createBlueNPC();
            this.createYellowNPC();
            this.createGuardAtCastle();
            this.createMermaid();
            this.createBird();

            // Items
            this.createFlowers(10);
            this.createCoins(8);
            this.createGems(4);
            this.createPotions(3);
            this.createKeys(2);
            this.createArtifacts(2);

            // Camera behind player
            this.camera.position.set(this.player.x+15,15,this.player.z+15);
            this.camera.lookAt(this.player.x,0.5,this.player.z);
          }
          addShrub(x,z){
            const geo=new THREE.CylinderGeometry(1,1,2,8);
            const mat=new THREE.MeshStandardMaterial({ color:0x228b22 });
            const shrub=new THREE.Mesh(geo,mat);
            shrub.position.set(x,1,z);
            this.scene.add(shrub);
            this.objects.push({ mesh:shrub, type:'boundary', x, z, boundingRadius:2 });
          }
          createBeach(){
            const beachGeo=new THREE.PlaneGeometry(300,30);
            const beachMat=new THREE.MeshStandardMaterial({ color:0xD2B48C, polygonOffset:true, polygonOffsetFactor:-1, polygonOffsetUnits:1 });
            const beach=new THREE.Mesh(beachGeo,beachMat);
            beach.rotation.x=-Math.PI/2;
            beach.position.set(0,0.01,-40);
            this.scene.add(beach);
            this.objects.push({ mesh:beach, type:'beach', x:0, z:-40, boundingRadius:0 });

            const waterGeo=new THREE.PlaneGeometry(300,30);
            const waterMat=new THREE.MeshStandardMaterial({ color:0x1E90FF, transparent:true, opacity:0.8, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:1 });
            const water=new THREE.Mesh(waterGeo,waterMat);
            water.rotation.x=-Math.PI/2;
            water.position.set(0,0.02,-70);
            this.scene.add(water);
            this.objects.push({ mesh:water, type:'water', x:0, z:-70, boundingRadius:0 });
          }
          createSun(){
            const sunGeo=new THREE.SphereGeometry(3,16,16);
            const sunMat=new THREE.MeshBasicMaterial({ color:0xffee00 });
            this.sunMesh=new THREE.Mesh(sunGeo,sunMat);
            this.sunMesh.position.set(0,200,-200);
            this.sunMesh.visible=true;
            this.scene.add(this.sunMesh);
          }
          createMoon(){
            const moonGeo=new THREE.SphereGeometry(2,16,16);
            const moonMat=new THREE.MeshBasicMaterial({ color:0xcccccc });
            this.moonMesh=new THREE.Mesh(moonGeo,moonMat);
            this.moonMesh.position.set(-100,150,100);
            this.moonMesh.visible=false;
            this.scene.add(this.moonMesh);
          }
          createStars(){
            const starCount=300;
            const positions=new Float32Array(starCount*3);
            for(let i=0;i<starCount;i++){
              const radius=300+Math.random()*200;
              const angle=Math.random()*Math.PI*2;
              const ySpread=Math.random()*200-50;
              positions[i*3]=Math.cos(angle)*radius;
              positions[i*3+1]=50+ySpread;
              positions[i*3+2]=Math.sin(angle)*radius;
            }
            const starGeo=new THREE.BufferGeometry();
            starGeo.setAttribute('position',new THREE.BufferAttribute(positions,3));
            const starMat=new THREE.PointsMaterial({ color:0xffffff, size:1.2, depthTest:false });
            const starField=new THREE.Points(starGeo,starMat);
            starField.visible=false;
            this.scene.add(starField);
            this.starsMesh=starField;
          }
          createPlayerModel(){
            const group=new THREE.Group();
            // Body
            const body=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16), new THREE.MeshStandardMaterial({ color:0xff69b4 }));
            body.position.set(0,0.6,0);
            body.userData={ isBodyPart:true };
            group.add(body);
            // Head
            const head=new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({ color:0xffddc1 }));
            head.position.set(0,1.4,0);
            head.userData={ isBodyPart:true };
            group.add(head);
            // Hair
            const hair=new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16), new THREE.MeshStandardMaterial({ color:0x4b2e05 }));
            hair.position.set(0,1.75,0);
            group.add(hair);
            // Crown
            const crown=new THREE.Mesh(new THREE.TorusGeometry(0.25,0.09,8,16), new THREE.MeshStandardMaterial({ color:0xffd700 }));
            crown.rotation.x=Math.PI/2;
            crown.position.set(0,1.95,0);
            group.add(crown);
            // Arms
            const armGeo=new THREE.CylinderGeometry(0.1,0.1,0.8,8);
            const skinMat=new THREE.MeshStandardMaterial({ color:0xffddc1 });
            const leftArm=new THREE.Mesh(armGeo,skinMat);
            leftArm.position.set(-0.5,1.0,0);
            leftArm.userData={ isBodyPart:true, isArm:true };
            group.add(leftArm);
            const rightArm=new THREE.Mesh(armGeo,skinMat);
            rightArm.position.set(0.5,1.0,0);
            rightArm.userData={ isBodyPart:true, isArm:true };
            group.add(rightArm);
            // Legs
            const legGeo=new THREE.CylinderGeometry(0.12,0.12,0.8,8);
            const leftLeg=new THREE.Mesh(legGeo,skinMat);
            leftLeg.position.set(-0.2,0.2,0);
            leftLeg.userData={ isBodyPart:true };
            group.add(leftLeg);
            const rightLeg=new THREE.Mesh(legGeo,skinMat);
            rightLeg.position.set(0.2,0.2,0);
            rightLeg.userData={ isBodyPart:true };
            group.add(rightLeg);
            group.position.set(0,0.5,0);
            this.player.object=group;
            this.scene.add(group);
          }
          createCastle(){/* omitted for brevity, same as earlier code */}
          createHouse(){/* omitted for brevity */}
          createCafe(){/* omitted for brevity */}
          createFountain(){/* omitted for brevity */}
          createBlueNPC(){/* omitted for brevity */}
          createYellowNPC(){/* omitted for brevity */}
          createGuardAtCastle(){/* omitted for brevity */}
          createMermaid(){/* omitted for brevity */}
          createBird(){
            const bird=new THREE.Mesh(new THREE.SphereGeometry(0.5,8,8),new THREE.MeshStandardMaterial({ color:0xffffff }));
            bird.position.set(0,60,0);
            this.scene.add(bird);
            this.birdData.object=bird;
          }
          createFlowers(count){/* omitted for brevity */}
          createCoins(count){/* omitted for brevity */}
          createGems(count){/* omitted for brevity */}
          createPotions(count){/* omitted for brevity */}
          createKeys(count){/* omitted for brevity */}
          createArtifacts(count){/* omitted for brevity */}

          startAnimation(){
            const animate=()=>{
              requestAnimationFrame(animate);
              this.update();
              this.renderer.render(this.scene,this.camera);
            };
            animate();
          }

          update(){
            this.updateDayNight();
            this.updateBalls();
            this.updatePlayer();
            this.updateBlueNPC();
            this.updateYellowNPC();
            this.updateBird();
            this.updateCollisions();
            this.updateCamera();
            this.updatePickups();
            this.processController();
          }

          updateDayNight(){
            this.dayNightCycle=(this.dayNightCycle+1)%1200;
            this.time=this.dayNightCycle<600?'Day':'Night';
            document.getElementById('time').textContent=this.time;
            if(this.sunMesh&&this.moonMesh&&this.starsMesh){
              if(this.time==='Day'){
                this.sunMesh.visible=true;
                this.moonMesh.visible=false;
                this.starsMesh.visible=false;
              } else {
                this.sunMesh.visible=false;
                this.moonMesh.visible=true;
                this.starsMesh.visible=true;
              }
            }
          }

          updateBalls(){
            for(let i=this.thrownBalls.length-1;i>=0;i--){
              const ball=this.thrownBalls[i];
              ball.position.add(ball.userData.velocity);
              ball.userData.velocity.y-=0.01;
              // building bounce
              for(const obj of this.objects){
                if(obj.type==='building'||obj.type==='decoration'){
                  const dxB=ball.position.x-obj.x;
                  const dzB=ball.position.z-obj.z;
                  const distSq=dxB*dxB+dzB*dzB;
                  const r=(obj.boundingRadius||5);
                  if(distSq<r*r&&ball.position.y<10){
                    const normal=new THREE.Vector3(dxB,0,dzB).normalize();
                    const v=ball.userData.velocity.clone();
                    const dot=v.dot(normal);
                    const reflection=v.sub(normal.multiplyScalar(2*dot)).multiplyScalar(0.6);
                    ball.userData.velocity.copy(reflection);
                  }
                }
              }
              if(ball.position.y<0){
                if(!ball.userData.bounced){
                  ball.position.y=0;
                  ball.userData.velocity.y*=-0.7;
                  ball.userData.bounced=true;
                } else if(ball.position.y<-0.5){
                  this.scene.remove(ball);
                  this.thrownBalls.splice(i,1);
                }
              }
            }
          }

          spawnRipple(x,z){
            const rippleGeo=new THREE.RingGeometry(0.2,0.4,16);
            const rippleMat=new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.5 });
            const ripple=new THREE.Mesh(rippleGeo,rippleMat);
            ripple.rotation.x=-Math.PI/2;
            ripple.position.set(x,0.05,z);
            this.scene.add(ripple);
            setTimeout(()=>{this.scene.remove(ripple);},1000);
          }

          updatePlayer(){
            // Keyboard movement
            let moveForward=0, moveStrafe=0;
            if(this.keysPressed['ArrowUp'])    moveForward+=1;
            if(this.keysPressed['ArrowDown'])  moveForward-=1;
            if(this.keysPressed['ArrowLeft'])  moveStrafe-=1;
            if(this.keysPressed['ArrowRight']) moveStrafe+=1;

            // D-pad movement from processController is added below, so we do it in processController

            // We'll do arm-swing animation if moving
            const isMoving=(moveForward!==0||moveStrafe!==0);
            this.animateArms(isMoving);
          }

          animateArms(isMoving){
            if(!this.player.object)return;
            this.player.object.traverse(child=>{
              if(child.userData&&child.userData.isArm){
                if(isMoving){
                  // Swing arms: small rotation around X
                  child.rotation.x=Math.sin(Date.now()*0.01)*0.5;
                } else {
                  child.rotation.x=0;
                }
              }
            });
          }

          updateBlueNPC(){/* omitted */}
          updateYellowNPC(){/* omitted */}
          getRandomBuildingTarget(){/* omitted */}
          updateBird(){
            this.birdData.angle+=this.birdData.speed;
            const bx=this.birdData.radius*Math.cos(this.birdData.angle);
            const bz=this.birdData.radius*Math.sin(this.birdData.angle);
            if(this.birdData.object){
              this.birdData.object.position.set(bx,60,bz);
              this.birdData.object.rotation.y=-this.birdData.angle;
            }
          }
          updateCollisions(){/* omitted */}
          updateCamera(){
            const camDist=15;
            // forward is -sin(yaw), -cos(yaw) if we define yaw=0 facing up
            const offsetX=camDist*Math.sin(this.player.yaw);
            const offsetZ=camDist*Math.cos(this.player.yaw);
            const offsetY=camDist*Math.sin(this.player.pitch)+15;
            this.camera.position.set(this.player.x+offsetX, offsetY, this.player.z-offsetZ);
            this.camera.lookAt(this.player.x, 0.5, this.player.z);
          }
          updatePickups(){/* omitted */}

          /*-----------------------------------------
            Throw Ball / Big Ball
          -----------------------------------------*/
          throwBall(){
            if(!this.player.object)return;
            // direction forward
            const direction=new THREE.Vector3(-Math.sin(this.player.yaw),0,-Math.cos(this.player.yaw));
            const ballGeo=new THREE.SphereGeometry(0.3,16,16);
            const ballMat=new THREE.MeshStandardMaterial({ color:0xff4500 });
            const ball=new THREE.Mesh(ballGeo,ballMat);
            ball.position.copy(this.player.object.position);
            ball.position.y+=1;
            ball.userData={
              velocity:direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
              bounced:false
            };
            this.scene.add(ball);
            this.thrownBalls.push(ball);
            this.ballCount++;
            document.getElementById('ballCountValue').textContent=this.ballCount;
            this.showDialogue("Threw a magic ball!");
          }
          throwBigBall(){
            if(!this.player.object)return;
            const direction=new THREE.Vector3(-Math.sin(this.player.yaw),0,-Math.cos(this.player.yaw));
            const ballGeo=new THREE.SphereGeometry(0.6,16,16);
            const ballMat=new THREE.MeshStandardMaterial({ color:0x0000ff });
            const ball=new THREE.Mesh(ballGeo,ballMat);
            ball.position.copy(this.player.object.position);
            ball.position.y+=1;
            ball.userData={
              velocity:direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
              bounced:false
            };
            this.scene.add(ball);
            this.thrownBalls.push(ball);
            this.ballCount++;
            document.getElementById('ballCountValue').textContent=this.ballCount;
            this.showDialogue("Threw a BIG magic ball!");
          }

          showDialogue(text){
            document.getElementById('dialogue').textContent=text;
          }
          showGuardPopup(text){
            const popup=document.getElementById('guardPopup');
            popup.style.display='block';
            popup.textContent=text;
            setTimeout(()=>{
              popup.style.display='none';
              popup.textContent='';
            },2000);
          }

          /*-----------------------------------------
            processController: D-Pad => forward/strafe,
            Turn => yaw changes
          -----------------------------------------*/
          processController(){
            // Movement
            let moveForward=0, moveStrafe=0;
            if(controllerState.dpadUp)    moveForward+=1;
            if(controllerState.dpadDown)  moveForward-=1;
            if(controllerState.dpadLeft)  moveStrafe-=1;
            if(controllerState.dpadRight) moveStrafe+=1;
            if(moveForward!==0||moveStrafe!==0){
              // Yaw=0 => facing up => forward => negative z
              const forwardX=-Math.sin(this.player.yaw);
              const forwardZ=-Math.cos(this.player.yaw);
              const rightX=Math.cos(this.player.yaw);
              const rightZ=-Math.sin(this.player.yaw);
              const dx=(forwardX*moveForward + rightX*moveStrafe)*this.player.speedController;
              const dz=(forwardZ*moveForward + rightZ*moveStrafe)*this.player.speedController;
              const newX=this.player.x+dx;
              const newZ=this.player.z+dz;
              let blocked=false;
              for(const obj of this.objects){
                if(obj.type==='building'||obj.type==='boundary'||obj.type==='decoration'||obj.type==='npc'){
                  const dxObj=newX-obj.x;
                  const dzObj=newZ-obj.z;
                  const distSq=dxObj*dxObj+dzObj*dzObj;
                  const r=(obj.boundingRadius||5);
                  if(distSq<r*r){ blocked=true; break; }
                }
              }
              if(!blocked){
                this.player.x=newX;
                this.player.z=newZ;
              }
              if(this.player.object){
                this.player.object.position.set(this.player.x,0.5,this.player.z);
              }
              // Animate arms if moving
              this.animateArms(true);
            } else {
              this.animateArms(false);
            }

            // Turn
            if(controllerState.turnLeft)  this.player.yaw-=0.02;
            if(controllerState.turnRight) this.player.yaw+=0.02;
          }

          initKeyboardMouse(){
            document.addEventListener('keydown', e=>{
              this.keysPressed[e.key]=true;
              if(e.key===' ') this.throwBall();
            });
            document.addEventListener('keyup', e=>{
              this.keysPressed[e.key]=false;
            });
            document.addEventListener('mousedown', ()=>{
              try{
                document.body.requestPointerLock();
              } catch(err){
                console.warn('Pointer lock request failed:',err);
              }
            });
            document.addEventListener('mousemove', evt=>{
              if(document.pointerLockElement===document.body){
                const movementX=evt.movementX||0;
                const movementY=evt.movementY||0;
                const sensitivity=0.001;
                this.player.yaw-=movementX*sensitivity;
                this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch-(movementY*sensitivity)));
              }
            });
          }
        }

        // Create the global game
        window.game=new Game();
      } catch(err){
        console.error('Error initializing the game:',err);
      }
    </script>
  </body>
</html>
