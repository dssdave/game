<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw; height: 100vh;
    }
    canvas { display: block; }
    /* UI styles here … */
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <!-- UI elements and on-screen controllers go here -->
  </div>

  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Example: Attach simple UI toggle and button listeners here.
    // (Omitted for brevity – use your existing UI code.)

    class Game {
      constructor() {
        // Set up scene, camera, renderer, etc.
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87CEEB);
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Initialize game state variables
        this.player = { x: 0, y: 0.5, z: 0, speed: 0.25, yaw: 0, jumpVelocity: 0, collisionRadius: 0.5, object: null };
        this.npcBlueData = { angle: 0, speed: 0.001, radius: 120, object: null };
        // (Other state variables, pickups, objects, etc.)
        this.objects = [];
        this.buildingPositions = [];
        this.thrownBalls = [];
        this.ballCount = 0;
        this.keysPressed = {};

        // Bind methods (if needed)
        this.updateMovement = this.updateMovement.bind(this);
        this.animateArms = this.animateArms.bind(this);

        this.initScene();
        this.initKeyboardMouse();
        this.startAnimation();
      }

      initScene() {
        // Create a ground
        const groundGeo = new THREE.PlaneGeometry(300, 300);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x6bb26b, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = Math.PI / 2;
        this.scene.add(ground);

        // Create some buildings and add them to the scene and objects array.
        this.createCastle();
        this.createHouse();
        // (Other scene objects…)

        // Create NPCs – note: createBlueNPC is defined below!
        this.createBlueNPC();
        this.createYellowNPC();
        // (Other NPCs…)

        // Create player model
        this.createPlayerModel();

        // Set initial camera position behind the player
        this.camera.position.set(this.player.x + 15, this.player.y + 15, this.player.z + 15);
        this.camera.lookAt(this.player.x, this.player.y + 1, this.player.z);
      }

      createPlayerModel() {
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16),
          new THREE.MeshStandardMaterial({ color: 0xff69b4 })
        );
        body.position.set(0, 0.6, 0);
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 })
        );
        head.position.set(0, 1.4, 0);
        group.add(head);
        // Add arms, legs, etc.
        const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5, 1.0, 0);
        leftArm.userData = { isArm: true, side: 'left' };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5, 1.0, 0);
        rightArm.userData = { isArm: true, side: 'right' };
        group.add(rightArm);
        // Legs…
        group.position.set(this.player.x, this.player.y, this.player.z);
        this.player.object = group;
        this.scene.add(group);
      }

      createCastle() {
        // Example: a simple castle with a door and a lamp post.
        const group = new THREE.Group();
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(20, 10, 20),
          new THREE.MeshStandardMaterial({ color: 0xcccccc })
        );
        base.position.set(0, 5, 0);
        group.add(base);
        // (Add towers, door, sign, etc.)
        group.position.set(40, 0, 40);
        this.scene.add(group);
        this.objects.push({ mesh: group, type: 'building', x: 40, z: 40, boundingRadius: 15 });
      }

      createHouse() {
        // Create a simple house similarly…
        const group = new THREE.Group();
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(12, 8, 10),
          new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        base.position.set(0, 4, 0);
        group.add(base);
        group.position.set(-40, 0, -40);
        this.scene.add(group);
        this.objects.push({ mesh: group, type: 'building', x: -40, z: -40, boundingRadius: 10 });
      }

      createBlueNPC() {
        // This method must be defined inside the class.
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16),
          new THREE.MeshStandardMaterial({ color: 0x0000ff })
        );
        body.position.set(0, 0.6, 0);
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 })
        );
        head.position.set(0, 1.4, 0);
        group.add(head);
        // Add arms
        const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5, 1.0, 0);
        leftArm.userData = { isArm: true, side: 'left' };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5, 1.0, 0);
        rightArm.userData = { isArm: true, side: 'right' };
        group.add(rightArm);
        group.position.set(120, 0.5, 0);
        this.scene.add(group);
        this.npcBlueData.object = group;
        this.objects.push({ mesh: group, type: 'npc', x: 120, z: 0, boundingRadius: 1 });
      }

      createYellowNPC() {
        // Similar to createBlueNPC
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 1.0, 16),
          new THREE.MeshStandardMaterial({ color: 0xffff00 })
        );
        body.position.set(0, 0.5, 0);
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 })
        );
        head.position.set(0, 1.1, 0);
        group.add(head);
        const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5, 0.8, 0);
        leftArm.userData = { isArm: true, side: 'left' };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5, 0.8, 0);
        rightArm.userData = { isArm: true, side: 'right' };
        group.add(rightArm);
        group.position.set(-30, 0.3, 30);
        this.scene.add(group);
        this.npcYellowData.object = group;
        this.objects.push({ mesh: group, type: 'npc', x: -30, z: 30, boundingRadius: 1 });
      }

      // (Define additional methods such as createGuardAtCastle, createMermaid, createBird, createPiazza, etc.)
      // For brevity, you can add similar method definitions below.
      
      initKeyboardMouse() {
        document.addEventListener('keydown', e => {
          this.keysPressed[e.key] = true;
          if (e.key === ' ') this.throwBall();
        });
        document.addEventListener('keyup', e => {
          this.keysPressed[e.key] = false;
        });
        document.addEventListener('mousedown', () => {
          try { document.body.requestPointerLock(); }
          catch (err) { console.warn('Pointer lock failed:', err); }
        });
        document.addEventListener('mousemove', evt => {
          if (document.pointerLockElement === document.body) {
            const movementX = evt.movementX || 0;
            const sensitivity = 0.001;
            this.player.yaw += movementX * sensitivity;
          }
        });
      }
      
      updateMovement() {
        // Compute movement vectors from keyboard and controller state.
        // (Your updateMovement code here.)
      }
      
      animateArms(obj, isMoving) {
        if (!obj) return;
        const t = Date.now() * 0.002;
        obj.traverse(child => {
          if (child.userData && child.userData.isArm) {
            child.rotation.x = isMoving 
              ? (child.userData.side === 'left' ? Math.sin(t) * 0.5 : -Math.sin(t) * 0.5)
              : 0;
          }
        });
      }
      
      throwBall() {
        const direction = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
        const ballGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4500 });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.position.set(this.player.x, this.player.y, this.player.z);
        ball.position.y += 1;
        ball.userData = {
          velocity: direction.multiplyScalar(0.3).add(new THREE.Vector3(0, 0.2, 0)),
          bounced: false,
          timer: 0
        };
        this.scene.add(ball);
        this.thrownBalls.push(ball);
        this.ballCount++;
        document.getElementById('ballCountValue').textContent = this.ballCount;
        // Show a dialogue message.
      }
      
      jump() {
        if (this.player.y <= 0.5) {
          this.player.jumpVelocity = 0.3;
          // Show a dialogue message.
        }
      }
      
      startAnimation() {
        const animate = () => {
          requestAnimationFrame(animate);
          // Call update functions
          this.updateMovement();
          // Other update methods...
          this.renderer.render(this.scene, this.camera);
        };
        animate();
      }
    }

    window.game = new Game();
  </script>
</body>
</html>
