<!DOCTYPE html>
<html>
<head>
    <title>Princess RPG - Ultimate Edition</title>
    <style>
        #gameContainer {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid black;
        }
        #ui {
            margin-top: 10px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            Flowers: <span id="flowers">0</span> |
            Coins: <span id="coins">0</span> |
            Location: <span id="location">Town</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported!');
            throw new Error('WebGL not supported');
        }

        // Game state
        class Game {
            constructor() {
                this.scene = 'town';
                this.flowers = 0;
                this.coins = 0;
                this.player = {
                    x: 0,
                    y: 0,
                    z: 10,
                    speed: 0.5,
                    yaw: 0,
                    pitch: 0,
                    model: null // Will hold player geometry
                };
                this.camera = {
                    x: 0,
                    y: -50,
                    z: 30,
                    yaw: 0,
                    pitch: -Math.PI / 6,
                    roll: 0
                };
                this.light = {
                    x: 50,
                    y: 50,
                    z: 100,
                    color: [1, 1, 1]
                };
            }
        }

        let game = new Game();

        // Shaders with lighting and textures
        const vertexShaderSource = `
            attribute vec3 a_position;
            attribute vec3 a_normal;
            attribute vec2 a_texcoord;
            uniform mat4 u_projection;
            uniform mat4 u_view;
            uniform mat4 u_model;
            uniform vec3 u_lightPos;
            varying vec3 v_normal;
            varying vec3 v_lightDir;
            varying vec2 v_texcoord;
            void main() {
                vec4 worldPos = u_model * vec4(a_position, 1.0);
                gl_Position = u_projection * u_view * worldPos;
                v_normal = mat3(u_model) * a_normal;
                v_lightDir = normalize(u_lightPos - worldPos.xyz);
                v_texcoord = a_texcoord;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 v_normal;
            varying vec3 v_lightDir;
            varying vec2 v_texcoord;
            uniform sampler2D u_texture;
            uniform vec3 u_lightColor;
            void main() {
                vec3 normal = normalize(v_normal);
                float diff = max(dot(normal, v_lightDir), 0.0);
                vec3 diffuse = diff * u_lightColor;
                vec4 texColor = texture2D(u_texture, v_texcoord);
                gl_FragColor = vec4(texColor.rgb * diffuse, texColor.a);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Uniforms and attributes
        const positionLoc = gl.getAttribLocation(program, 'a_position');
        const normalLoc = gl.getAttribLocation(program, 'a_normal');
        const texcoordLoc = gl.getAttribLocation(program, 'a_texcoord');
        const projLoc = gl.getUniformLocation(program, 'u_projection');
        const viewLoc = gl.getUniformLocation(program, 'u_view');
        const modelLoc = gl.getUniformLocation(program, 'u_model');
        const lightPosLoc = gl.getUniformLocation(program, 'u_lightPos');
        const lightColorLoc = gl.getUniformLocation(program, 'u_lightColor');
        const textureLoc = gl.getUniformLocation(program, 'u_texture');

        // Matrix math
        function mat4() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        function perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
            return out;
        }

        function multiply(out, a, b) {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    out[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        out[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return out;
        }

        function translate(out, x, y, z) {
            out[12] = x; out[13] = y; out[14] = z;
            return out;
        }

        function rotateX(out, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            out[5] = c; out[6] = s;
            out[9] = -s; out[10] = c;
            return out;
        }

        function rotateY(out, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            out[0] = c; out[2] = -s;
            out[8] = s; out[10] = c;
            return out;
        }

        // Procedural terrain generation
        function generateTerrain() {
            const vertices = [];
            const normals = [];
            const texcoords = [];
            const indices = [];
            for (let x = -50; x < 50; x += 2) {
                for (let z = -50; z < 50; z += 2) {
                    const y = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5;
                    vertices.push(x, y, z);
                    normals.push(0, 1, 0); // Simplified
                    texcoords.push(x / 100 + 0.5, z / 100 + 0.5);
                }
            }
            for (let i = 0; i < 49; i++) {
                for (let j = 0; j < 49; j++) {
                    const a = i * 50 + j;
                    indices.push(a, a + 1, a + 50);
                    indices.push(a + 1, a + 51, a + 50);
                }
            }
            return { vertices, normals, texcoords, indices };
        }

        // Simple 3D model for princess (cube-like with dress)
        function generatePlayerModel() {
            return {
                vertices: [
                    // Body
                    -1, 0, -1,  1, 0, -1,  1, 2, -1, -1, 2, -1,
                    -1, 0,  1,  1, 0,  1,  1, 2,  1, -1, 2,  1,
                    // Dress
                    -2, 0, -2,  2, 0, -2,  2, 1, -2, -2, 1, -2,
                    -2, 0,  2,  2, 0,  2,  2, 1,  2, -2, 1,  2
                ],
                normals: [
                    0, 0, -1,  0, 0, -1,  0, 0, -1,  0, 0, -1,
                    0, 0,  1,  0, 0,  1,  0, 0,  1,  0, 0,  1,
                    0, 0, -1,  0, 0, -1,  0, 0, -1,  0, 0, -1,
                    0, 0,  1,  0, 0,  1,  0, 0,  1,  0, 0,  1
                ],
                texcoords: [
                    0, 0,  1, 0,  1, 1,  0, 1,
                    0, 0,  1, 0,  1, 1,  0, 1,
                    0, 0,  1, 0,  1, 1,  0, 1,
                    0, 0,  1, 0,  1, 1,  0, 1
                ],
                indices: [
                    0, 1, 2,  0, 2, 3,
                    4, 5, 6,  4, 6, 7,
                    8, 9, 10, 8, 10, 11,
                    12, 13, 14, 12, 14, 15
                ]
            };
        }

        // Game objects
        const objects = {
            town: [
                {type: 'terrain', x: 0, y: 0, z: 0, model: generateTerrain()},
                {type: 'building', x: 20, y: 0, z: 20, width: 10, height: 15, depth: 10, color: [0.5, 0.5, 0.5]},
                {type: 'building', x: -20, y: 0, z: -20, width: 8, height: 6, depth: 8, color: [0.5, 0.5, 0.5]},
                {type: 'flower', x: 10, y: 0, z: 10, width: 2, height: 2, depth: 2, color: [1, 0, 1]},
                {type: 'coin', x: -10, y: 0, z: -10, width: 2, height: 2, depth: 2, color: [1, 0.84, 0]}
            ],
            castle: [
                {type: 'terrain', x: 0, y: 0, z: 0, model: generateTerrain()},
                {type: 'door', x: 0, y: 0, z: 0, width: 4, height: 4, depth: 1, color: [0.55, 0.27, 0.07]}
            ],
            house: [
                {type: 'terrain', x: 0, y: 0, z: 0, model: generateTerrain()},
                {type: 'door', x: 0, y: 0, z: 0, width: 4, height: 4, depth: 1, color: [0.55, 0.27, 0.07]}
            ]
        };

        game.player.model = generatePlayerModel();

        // Texture loader (simulated - replace with real images)
        function createTexture(color) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([...color.map(c => c * 255), 255]));
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            return texture;
        }

        const textures = {
            terrain: createTexture([0.56, 0.93, 0.56]),
            player: createTexture([1, 0.41, 0.71]),
            building: createTexture([0.5, 0.5, 0.5]),
            flower: createTexture([1, 0, 1]),
            coin: createTexture([1, 0.84, 0]),
            door: createTexture([0.55, 0.27, 0.07])
        };

        // Buffers
        const positionBuffer = gl.createBuffer();
        const normalBuffer = gl.createBuffer();
        const texcoordBuffer = gl.createBuffer();
        const indexBuffer = gl.createBuffer();

        // Input handling
        const keys = {};
        let mouseDown = false;
        let lastX, lastY;
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);
        canvas.addEventListener('mousedown', (e) => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const dx = (e.clientX - lastX) * 0.005;
                const dy = (e.clientY - lastY) * 0.005;
                game.camera.yaw += dx;
                game.camera.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, game.camera.pitch + dy));
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        function update() {
            // Player movement
            const forward = [Math.sin(game.player.yaw), 0, Math.cos(game.player.yaw)];
            const right = [Math.cos(game.player.yaw), 0, -Math.sin(game.player.yaw)];
            if (keys['w']) {
                game.player.x += forward[0] * game.player.speed;
                game.player.z += forward[2] * game.player.speed;
            }
            if (keys['s']) {
                game.player.x -= forward[0] * game.player.speed;
                game.player.z -= forward[2] * game.player.speed;
            }
            if (keys['a']) {
                game.player.x -= right[0] * game.player.speed;
                game.player.z -= right[2] * game.player.speed;
            }
            if (keys['d']) {
                game.player.x += right[0] * game.player.speed;
                game.player.z += right[2] * game.player.speed;
            }
            if (keys['ArrowLeft']) game.player.yaw += 0.05;
            if (keys['ArrowRight']) game.player.yaw -= 0.05;

            // Camera follows player
            game.camera.x = game.player.x;
            game.camera.z = game.player.z + 30 * Math.cos(game.camera.pitch);

            // Object interactions
            const currentObjects = objects[game.scene];
            for (let i = currentObjects.length - 1; i >= 0; i--) {
                const obj = currentObjects[i];
                if (obj.type !== 'terrain' && Math.abs(game.player.x - obj.x) < 5 && Math.abs(game.player.z - obj.z) < 5) {
                    if (obj.type === 'flower') {
                        game.flowers++;
                        currentObjects.splice(i, 1);
                    } else if (obj.type === 'coin') {
                        game.coins++;
                        currentObjects.splice(i, 1);
                    } else if (obj.type === 'building') {
                        game.scene = obj.x > 0 ? 'castle' : 'house';
                        game.player.x = 0;
                        game.player.z = 0;
                    } else if (obj.type === 'door') {
                        game.scene = 'town';
                        game.player.x = 0;
                        game.player.z = 0;
                    }
                }
            }
        }

        function drawObject(obj) {
            let vertices, normals, texcoords, indices;
            if (obj.model) {
                ({ vertices, normals, texcoords, indices } = obj.model);
            } else {
                vertices = [
                    obj.x - obj.width/2, obj.y, obj.z - obj.depth/2,
                    obj.x + obj.width/2, obj.y, obj.z - obj.depth/2,
                    obj.x + obj.width/2, obj.y + obj.height, obj.z - obj.depth/2,
                    obj.x - obj.width/2, obj.y + obj.height, obj.z - obj.depth/2,
                    obj.x - obj.width/2, obj.y, obj.z + obj.depth/2,
                    obj.x + obj.width/2, obj.y, obj.z + obj.depth/2,
                    obj.x + obj.width/2, obj.y + obj.height, obj.z + obj.depth/2,
                    obj.x - obj.width/2, obj.y + obj.height, obj.z + obj.depth/2
                ];
                normals = [
                    0, 0, -1,  0, 0, -1,  0, 0, -1,  0, 0, -1,
                    0, 0, 1,   0, 0, 1,   0, 0, 1,   0, 0, 1
                ];
                texcoords = [
                    0, 0,  1, 0,  1, 1,  0, 1,
                    0, 0,  1, 0,  1, 1,  0, 1
                ];
                indices = [
                    0, 1, 2,  0, 2, 3,
                    4, 5, 6,  4, 6, 7,
                    0, 4, 7,  0, 7, 3,
                    1, 5, 6,  1, 6, 2
                ];
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionLoc);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(normalLoc);

            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
            gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(texcoordLoc);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindTexture(gl.TEXTURE_2D, textures[obj.type]);
            let model = mat4();
            model = translate(model, obj.x, obj.y, obj.z);
            gl.uniformMatrix4fv(modelLoc, false, model);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        function drawPlayer() {
            const { vertices, normals, texcoords, indices } = game.player.model;

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionLoc);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(normalLoc);

            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
            gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(texcoordLoc);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindTexture(gl.TEXTURE_2D, textures.player);
            let model = mat4();
            model = translate(model, game.player.x, game.player.y, game.player.z);
            model = multiply(mat4(), rotateY(mat4(), game.player.yaw), model);
            gl.uniformMatrix4fv(modelLoc, false, model);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        function draw() {
            gl.clearColor(0.53, 0.81, 0.98, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            // Projection
            let projection = mat4();
            perspective(projection, Math.PI / 3, canvas.width / canvas.height, 0.1, 1000);
            gl.uniformMatrix4fv(projLoc, false, projection);

            // View
            let view = mat4();
            view = translate(view, -game.camera.x, -game.camera.y, -game.camera.z);
            view = multiply(mat4(), rotateX(mat4(), game.camera.pitch), view);
            view = multiply(mat4(), rotateY(mat4(), game.camera.yaw), view);
            gl.uniformMatrix4fv(viewLoc, false, view);

            // Lighting
            gl.uniform3fv(lightPosLoc, [game.light.x, game.light.y, game.light.z]);
            gl.uniform3fv(lightColorLoc, game.light.color);

            // Draw scene
            objects[game.scene].forEach(drawObject);
            drawPlayer();

            // Update UI
            document.getElementById('flowers').textContent = game.flowers;
            document.getElementById('coins').textContent = game.coins;
            document.getElementById('location').textContent = game.scene.charAt(0).toUpperCase() + game.scene.slice(1);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
