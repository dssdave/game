<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Princess Doniaâ€™s Town - Enhanced 3D RPG</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-size: 16px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
      #ballCount {
        position: absolute;
        top: 10px;
        right: 10px;
        color: #fff;
        font-size: 16px;
        background: rgba(0,0,0,0.7);
        padding: 5px;
        border-radius: 5px;
        z-index: 10;
      }
      #dialogue {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: #fff;
        font-size: 14px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
        max-width: 600px;
        z-index: 10;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        color: #fff;
        font-size: 14px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
      #errorMessage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 20px;
        background: rgba(0,0,0,0.8);
        padding: 20px;
        border-radius: 5px;
        z-index: 20;
        display: none;
      }
      /* Joystick containers */
      #joystickLeft,
      #joystickRight {
        position: absolute;
        width: 15vw;
        height: 15vw;
        min-width: 80px;
        min-height: 80px;
        max-width: 100px;
        max-height: 100px;
        opacity: 0.5;
        z-index: 15;
      }
      #joystickLeft {
        bottom: 6vh;
        left: 2vw;
      }
      #joystickRight {
        bottom: 6vh;
        right: 2vw;
      }
      /* Bigger pop-up for guard & NPC */
      #guardPopup {
        position: absolute;
        bottom: 50%;
        left: 50%;
        transform: translate(-50%, 50%);
        color: #fff;
        font-size: 48px; /* 3x bigger */
        font-family: 'Press Start 2P', monospace; /* retro style */
        background: rgba(0,0,0,0.8);
        border: 2px solid #fff;
        padding: 20px;
        border-radius: 5px;
        display: none;
        z-index: 50;
        text-align: center;
      }
    </style>
    <!-- Include Three.js and NippleJS from CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>
      <div id="ballCount">
        Balls Thrown: <span id="ballCountValue">0</span>
      </div>
      <div id="dialogue"></div>
      <div id="controls">
        Controls:<br>
        Joysticks/Arrow Keys: Move<br>
        Joysticks/Mouse: Look Around<br>
        Tap Center/Space: Throw Ball
      </div>
      <div id="joystickLeft"></div>
      <div id="joystickRight"></div>
      <div id="errorMessage">
        WebGL is not supported in your browser. Please use a modern browser.
      </div>
      <div id="guardPopup"></div> <!-- Large pop-up for guard / NPC -->
    </div>

    <script>
      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');
        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          throw new Error('WebGL not supported');
        }

        // Basic Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameCanvas.style.display = 'block';

        // We'll store references for the NPC, bird, etc.
        let npcData = { angle: 0, speed: 0.001, radius: 120, object: null };
        let birdData = { angle: 0, speed: 0.002, radius: 140, object: null };

        class Game {
          constructor() {
            this.scene = 'town';
            this.flowers = 0;
            this.coins = 0;
            this.gems = 0;
            this.potions = 0;
            this.keys = 0;
            this.artifacts = 0;
            this.health = 100;
            this.time = 'Day';
            this.dayNightCycle = 0;

            // Player data
            this.player = {
              x: 0,
              z: 0,
              speedKeyboard: 0.1,
              speedJoystick: 0.05,
              yaw: 0,
              pitch: -0.2,
              object: null,
              lastMoveVec: new THREE.Vector3(1,0,0)
            };

            this.dialogue = '';
            this.dialogueTimer = 0;
            this.objects = [];
            this.npcs = [];
            this.ballCount = 0;
            this.thrownBalls = [];
            this.collectionGlow = null;
            this.joystickLeft = null;
            this.joystickRight = null;
            this.keysPressed = {};
            this.sceneObj = scene;
            this.camera = camera;
            this.renderer = renderer;
            this.itemRange = 80;

            this.sunMesh = null;
            this.moonMesh = null;
            this.starsMesh = null;
            this.guardObject = null;
            this.guardMessageShown = false;
            this.npcMessageShown = false; // for NPC pop-up

            this.initScene();
            this.initJoysticks();
            this.initKeyboardMouse();
            this.startAnimation();
          }

          /*-----------------------------------------
            Item creation methods
          -----------------------------------------*/
          createFlowers(count) {
            for (let i = 0; i < count; i++) {
              const fx = Math.random() * this.itemRange * 2 - this.itemRange;
              const fz = Math.random() * this.itemRange * 2 - this.itemRange;
              const stemGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
              const stemMat = new THREE.MeshStandardMaterial({ color: 0x008000 });
              const stem = new THREE.Mesh(stemGeo, stemMat);
              stem.position.set(0, 0.5, 0);

              const bloomGeo = new THREE.SphereGeometry(0.2, 8, 8);
              const bloomMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
              const bloom = new THREE.Mesh(bloomGeo, bloomMat);
              bloom.position.set(0, 1, 0);

              const flowerGroup = new THREE.Group();
              flowerGroup.add(stem, bloom);
              flowerGroup.position.set(fx, 0, fz);
              flowerGroup.castShadow = true;
              flowerGroup.receiveShadow = true;
              this.sceneObj.add(flowerGroup);
              this.objects.push({
                mesh: flowerGroup,
                type: 'flower',
                isPickup: true,
                x: fx,
                z: fz
              });
            }
          }

          createCoins(count) {
            for (let i = 0; i < count; i++) {
              const cx = Math.random() * this.itemRange * 2 - this.itemRange;
              const cz = Math.random() * this.itemRange * 2 - this.itemRange;
              const coinGeo = new THREE.CircleGeometry(0.3, 16);
              const coinMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
              const coinMesh = new THREE.Mesh(coinGeo, coinMat);
              coinMesh.rotation.x = -Math.PI / 2;
              coinMesh.position.set(cx, 0.01, cz);
              coinMesh.castShadow = true;
              coinMesh.receiveShadow = true;
              this.sceneObj.add(coinMesh);
              this.objects.push({
                mesh: coinMesh,
                type: 'coin',
                isPickup: true,
                x: cx,
                z: cz
              });
            }
          }

          createGems(count) {
            for (let i = 0; i < count; i++) {
              const gx = Math.random() * this.itemRange * 2 - this.itemRange;
              const gz = Math.random() * this.itemRange * 2 - this.itemRange;
              const gemGeo = new THREE.OctahedronGeometry(0.5, 0);
              const gemMat = new THREE.MeshStandardMaterial({ color: 0x00ffff });
              const gemMesh = new THREE.Mesh(gemGeo, gemMat);
              gemMesh.position.set(gx, 0.5, gz);
              gemMesh.castShadow = true;
              gemMesh.receiveShadow = true;
              this.sceneObj.add(gemMesh);
              this.objects.push({
                mesh: gemMesh,
                type: 'gem',
                isPickup: true,
                x: gx,
                z: gz
              });
            }
          }

          createPotions(count) {
            for (let i = 0; i < count; i++) {
              const px = Math.random() * this.itemRange * 2 - this.itemRange;
              const pz = Math.random() * this.itemRange * 2 - this.itemRange;
              const potionBaseGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16);
              const potionBaseMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
              const potionBase = new THREE.Mesh(potionBaseGeo, potionBaseMat);
              potionBase.position.y = 0.4;

              const potionLiquidGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.6, 16);
              const potionLiquidMat = new THREE.MeshStandardMaterial({ color: 0xff4500 });
              const potionLiquid = new THREE.Mesh(potionLiquidGeo, potionLiquidMat);
              potionLiquid.position.y = 0.4;

              const potionGroup = new THREE.Group();
              potionGroup.add(potionBase, potionLiquid);
              potionGroup.position.set(px, 0, pz);
              potionGroup.castShadow = true;
              potionGroup.receiveShadow = true;
              this.sceneObj.add(potionGroup);
              this.objects.push({
                mesh: potionGroup,
                type: 'potion',
                isPickup: true,
                x: px,
                z: pz
              });
            }
          }

          createKeys(count) {
            for (let i = 0; i < count; i++) {
              const kx = Math.random() * this.itemRange * 2 - this.itemRange;
              const kz = Math.random() * this.itemRange * 2 - this.itemRange;
              const keyHandleGeo = new THREE.SphereGeometry(0.2, 16, 16);
              const keyShaftGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
              const keyMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
              const keyHandle = new THREE.Mesh(keyHandleGeo, keyMat);
              const keyShaft = new THREE.Mesh(keyShaftGeo, keyMat);
              keyShaft.position.y = -0.4;
              const keyGroup = new THREE.Group();
              keyGroup.add(keyHandle, keyShaft);
              keyGroup.position.set(kx, 0.5, kz);
              keyGroup.rotation.x = Math.PI / 2;
              keyGroup.castShadow = true;
              keyGroup.receiveShadow = true;
              this.sceneObj.add(keyGroup);
              this.objects.push({
                mesh: keyGroup,
                type: 'key',
                isPickup: true,
                x: kx,
                z: kz
              });
            }
          }

          createArtifacts(count) {
            for (let i = 0; i < count; i++) {
              const ax = Math.random() * this.itemRange * 2 - this.itemRange;
              const az = Math.random() * this.itemRange * 2 - this.itemRange;
              const artifactGeo = new THREE.SphereGeometry(0.5, 16, 16);
              const artifactMat = new THREE.MeshStandardMaterial({ color: 0x9400d3 });
              const artifact = new THREE.Mesh(artifactGeo, artifactMat);
              artifact.castShadow = true;
              artifact.receiveShadow = true;

              const glowGeo = new THREE.SphereGeometry(0.6, 16, 16);
              const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffeb3b,
                transparent: true,
                opacity: 0.5,
                side: THREE.BackSide
              });
              const glow = new THREE.Mesh(glowGeo, glowMat);
              const artifactGroup = new THREE.Group();
              artifactGroup.add(artifact, glow);
              artifactGroup.position.set(ax, 0.5, az);
              this.sceneObj.add(artifactGroup);
              this.objects.push({
                mesh: artifactGroup,
                type: 'artifact',
                isPickup: true,
                x: ax,
                z: az
              });
            }
          }

          /*-----------------------------------------
            Scene creation methods
          -----------------------------------------*/
          initScene() {
            // Larger ground for boundary
            const groundGeo = new THREE.PlaneGeometry(300, 300, 50, 50);
            const groundMat = new THREE.MeshStandardMaterial({
              color: 0x6bb26b,
              side: THREE.DoubleSide,
              roughness: 0.8,
              metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = Math.PI/2;
            ground.receiveShadow = true;
            this.sceneObj.add(ground);

            // Sky
            const skyGeo = new THREE.SphereGeometry(700, 60, 40);
            const skyMat = new THREE.ShaderMaterial({
              uniforms: {
                topColor: { value: new THREE.Color(0x87ceeb) },
                bottomColor: { value: new THREE.Color(0x2f4f4f) },
                offset: { value: 0.5 },
                exponent: { value: 0.6 }
              },
              vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                  vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                  vWorldPosition = worldPosition.xyz;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                  float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
                  gl_FragColor = vec4(
                    mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)),
                    1.0
                  );
                }
              `,
              side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.name = 'sky';
            this.sceneObj.add(sky);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            this.sceneObj.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            this.sceneObj.add(dirLight);

            // Beach
            this.createBeach();
            // Mermaid
            this.createMermaid();
            // Bird
            this.createBird();
            // Player
            this.createPlayerModel();
            // NPC
            this.createBlueNPC();
            // Guard
            this.createGuardAtCastle();
            // Boundary
            this.createBoundary();
            // Castle, House, Fountain, Cafe
            this.createCastle();
            this.createHouse();
            this.createFountain();
            this.createCafe();

            // Items
            this.createFlowers(10);
            this.createCoins(8);
            this.createGems(4);
            this.createPotions(3);
            this.createKeys(2);
            this.createArtifacts(2);

            // Sun, moon, stars
            this.createSun();
            this.createMoon();
            this.createStars();
          }

          createSun() {
            const sunGeo = new THREE.SphereGeometry(3, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffee00 });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(0, 200, -200);
            sun.visible = true;
            this.sceneObj.add(sun);
            this.sunMesh = sun;
          }

          createMoon() {
            const moonGeo = new THREE.SphereGeometry(2, 16, 16);
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
            const moon = new THREE.Mesh(moonGeo, moonMat);
            moon.position.set(-100, 150, 100);
            moon.visible = false;
            this.sceneObj.add(moon);
            this.moonMesh = moon;
          }

          createStars() {
            const starCount = 300;
            const positions = new Float32Array(starCount*3);
            for (let i=0; i<starCount; i++) {
              const radius = 300 + Math.random()*200;
              const angle = Math.random()*Math.PI*2;
              const ySpread = Math.random()*200 - 50;
              positions[i*3] = Math.cos(angle)*radius;
              positions[i*3+1] = 50 + ySpread;
              positions[i*3+2] = Math.sin(angle)*radius;
            }
            const starGeo = new THREE.BufferGeometry();
            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2 });
            const starField = new THREE.Points(starGeo, starMat);
            starField.visible = false;
            this.sceneObj.add(starField);
            this.starsMesh = starField;
          }

          /*-----------------------------------------
            Joysticks + Keyboard/Mouse
          -----------------------------------------*/
          initJoysticks() {
            this.joystickLeft = nipplejs.create({
              zone: document.getElementById('joystickLeft'),
              mode: 'static',
              color: 'white',
              size: 100,
              position: { left: '2vw', bottom: '6vh' }
            });
            this.joystickLeft.on('move', (evt, data) => {
              if (data && data.force > 0) {
                const angle = data.angle.radian;
                const speed = data.force * this.player.speedJoystick;
                const dx = Math.cos(angle) * speed;
                const dz = Math.sin(angle) * speed;
                const newX = this.player.x + dx;
                const newZ = this.player.z - dz;

                let blocked = false;
                for (const obj of this.objects) {
                  if (
                    obj.type === 'building' ||
                    obj.type === 'wall' ||
                    obj.type === 'boundary' ||
                    obj.type === 'decoration'
                  ) {
                    const dxObj = newX - obj.x;
                    const dzObj = newZ - obj.z;
                    const distSq = dxObj*dxObj + dzObj*dzObj;
                    const r = (obj.boundingRadius || 1) + 0.5;
                    if (distSq < r*r) {
                      blocked = true;
                      break;
                    }
                  }
                }
                if (!blocked) {
                  this.player.x = newX;
                  this.player.z = newZ;
                }
                this.joystickLeft.active = true;
              }
            });
            this.joystickLeft.on('end', () => { this.joystickLeft.active = false; });

            this.joystickRight = nipplejs.create({
              zone: document.getElementById('joystickRight'),
              mode: 'static',
              color: 'white',
              size: 100,
              position: { right: '2vw', bottom: '6vh' }
            });
            this.joystickRight.on('move', (evt, data) => {
              if (data && data.force > 0) {
                const sensitivity = 0.001;
                this.player.yaw += data.vector.x * sensitivity * data.force;
                this.player.pitch = Math.max(
                  -Math.PI/2,
                  Math.min(Math.PI/2, this.player.pitch + data.vector.y * sensitivity * data.force)
                );
              }
            });
            this.joystickRight.on('end', () => {});

            // Tap center to throw
            document.getElementById('gameContainer').addEventListener('click', e => {
              const rect = e.target.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              if (
                x > rect.width / 4 && x < (rect.width * 3) / 4 &&
                y > rect.height / 4 && y < (rect.height * 3) / 4
              ) {
                this.throwBall();
              }
            });
          }

          initKeyboardMouse() {
            document.addEventListener('keydown', e => {
              this.keysPressed[e.key] = true;
              if (e.key === ' ') this.throwBall();
            });
            document.addEventListener('keyup', e => {
              this.keysPressed[e.key] = false;
            });
            document.addEventListener('mousedown', () => {
              document.body.requestPointerLock();
            });
            document.addEventListener('mousemove', event => {
              if (document.pointerLockElement === document.body) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                const sensitivity = 0.001;
                this.player.yaw += movementX * sensitivity;
                this.player.pitch = Math.max(
                  -Math.PI/2,
                  Math.min(Math.PI/2, this.player.pitch + movementY * sensitivity)
                );
              }
            });
          }
        }

        // Create the game
        const game = new Game();
      } catch (error) {
        console.error('Error initializing the game:', error);
      }
    </script>
  </body>
</html>
