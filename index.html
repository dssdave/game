<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town – Fully Restored Game</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; }
    #ui, #ballCount, #dialogue, #controls {
      background: rgba(0,0,0,0.7);
      border: 4px solid #fff;
      border-radius: 5px;
      color: #fff;
      font-size: 28px;
      padding: 20px 30px;
      position: absolute;
      z-index: 10;
    }
    #ui        { top: 10px; left: 10px; }
    #ballCount { top: 10px; right: 10px; }
    #dialogue  { bottom: 10px; left: 10px; max-width: 600px; display: none; }
    #controls  { bottom: 10px; right: 10px; }
    #toggleUIBtn {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      font-size: 24px;
      padding: 10px 20px;
      background: #333;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 5px;
      cursor: pointer;
    }
    #dpadContainer, #turnContainer, #actionContainer {
      position: absolute;
      z-index: 15;
    }
    #dpadContainer {
      bottom: 16vh;
      left: 5vw;
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
    }
    #btnUp    { grid-column: 2; grid-row: 1; }
    #btnDown  { grid-column: 2; grid-row: 3; }
    #btnLeft  { grid-column: 1; grid-row: 2; }
    #btnRight { grid-column: 3; grid-row: 2; }
    #dpadContainer button {
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
    }
    #turnContainer {
      bottom: 16vh;
      left: calc(5vw + 200px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #turnContainer button, #actionContainer button {
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px;
      color: #fff;
      cursor: pointer;
    }
    #actionContainer {
      bottom: 16vh;
      left: calc(5vw + 200px + 70px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    @media (max-width: 768px) {
      #ui, #ballCount, #dialogue, #controls {
        font-size: 16px;
        padding: 10px 15px;
      }
      #toggleUIBtn { font-size: 16px; }
      #dpadContainer {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
      }
      #dpadContainer button {
        width: 50px;
        height: 50px;
        font-size: 14px;
      }
      #turnContainer button, #actionContainer button {
        width: 50px;
        height: 50px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>
    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifact: <span id="artifacts">0</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
    <div id="dialogue"></div>
    <div id="controls">
      Controls:<br>
      [Desktop] Arrow Up/Down = forward/back, Left/Right = turn, Space = throw ball, B = jump<br>
      [Mobile] D‑Pad Up/Down = forward/back, Left/Right = strafe, L/R = turn, A = throw ball, B = jump
    </div>
    <div id="dpadContainer">
      <button id="btnUp">▲</button>
      <button id="btnDown">▼</button>
      <button id="btnLeft">◀</button>
      <button id="btnRight">▶</button>
    </div>
    <div id="turnContainer">
      <button id="btnTurnLeft">L</button>
      <button id="btnTurnRight">R</button>
    </div>
    <div id="actionContainer">
      <button id="btnThrow">A</button>
      <button id="btnBigThrow">B</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Toggle UI
    document.getElementById('toggleUIBtn').addEventListener('click', () => {
      const ids = ["ui", "ballCount", "dialogue", "controls"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        el.style.display = (el.style.display === "none") ? "block" : "none";
      });
    });

    // Prevent text highlighting on mobile
    function disableHighlight(id) {
      const btn = document.getElementById(id);
      ["touchstart", "mousedown"].forEach(evt => {
        btn.addEventListener(evt, e => { e.preventDefault(); }, { passive: false });
      });
    }
    ["btnUp", "btnDown", "btnLeft", "btnRight", "btnTurnLeft", "btnTurnRight", "btnThrow", "btnBigThrow"]
      .forEach(disableHighlight);

    // On-screen controller state
    const controllerState = {
      dpadUp: false, dpadDown: false, dpadLeft: false, dpadRight: false,
      turnLeft: false, turnRight: false
    };
    function setButtonListener(btnId, stateProp) {
      const btn = document.getElementById(btnId);
      ["mousedown", "touchstart"].forEach(evt => {
        btn.addEventListener(evt, e => {
          e.preventDefault();
          controllerState[stateProp] = true;
        }, { passive: false });
      });
      ["mouseup", "touchend", "mouseleave"].forEach(evt => {
        btn.addEventListener(evt, () => { controllerState[stateProp] = false; });
      });
    }
    setButtonListener('btnUp', 'dpadUp');
    setButtonListener('btnDown', 'dpadDown');
    setButtonListener('btnLeft', 'dpadLeft');
    setButtonListener('btnRight', 'dpadRight');
    setButtonListener('btnTurnLeft', 'turnLeft');
    setButtonListener('btnTurnRight', 'turnRight');

    // A/B button actions
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game) window.game.throwBall();
      }, { passive: false });
    });
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnBigThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game) window.game.jump();
      }, { passive: false });
    });

    // Global variables
    let game = null;
    const keysPressed = {};
    const outsideScene = new THREE.Scene();
    const insideScene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
    let activeScene = outsideScene;
    let isInsideCastle = false;

    class Game {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.innerWidth < 768 ? 1 : window.devicePixelRatio);
        document.getElementById('gameCanvas').style.display = 'block';

        // Player
        this.player = { x: 0, y: 0.5, z: 0, speedKeyboard: 0.1, yaw: 0, jumpVelocity: 0, object: null };

        // Stats
        this.flowers = 0; this.coins = 0; this.gems = 0; this.potions = 0; this.keys = 0; this.artifacts = 0;
        this.ballCount = 0; this.thrownBalls = [];
        this.keysPressed = keysPressed;

        // Collision arrays
        this.outsideObjects = [];
        this.insideObjects = [];

        // Castle NPC data
        this.castleNPCData = [];

        // Initialize scenes
        this.initOutsideScene();
        this.initInsideScene();
        activeScene = outsideScene;
        isInsideCastle = false;
        document.getElementById('location').textContent = "Town";

        this.initKeyboardMouse();
        this.startAnimation();
      }

      initOutsideScene() {
        outsideScene.background = new THREE.Color(0x87CEEB); // Sky blue
        const groundGeo = new THREE.PlaneGeometry(300, 300);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x6bb26b, side: THREE.DoubleSide }); // Grassy green
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = Math.PI / 2;
        outsideScene.add(ground);

        const ambient = new THREE.AmbientLight(0x404040, 0.6);
        outsideScene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        outsideScene.add(dirLight);

        this.createPlayerModel();
        outsideScene.add(this.player.object);

        // Central platform
        const platformBase = new THREE.Mesh(
          new THREE.CylinderGeometry(2, 2, 0.5, 32),
          new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        platformBase.position.set(0, 0.25, 0);
        outsideScene.add(platformBase);
        const platformTop = new THREE.Mesh(
          new THREE.CylinderGeometry(2, 2, 0.2, 8),
          new THREE.MeshStandardMaterial({ color: 0x87CEFA })
        );
        platformTop.position.set(0, 0.35, 0);
        outsideScene.add(platformTop);
        this.outsideObjects.push({ mesh: platformBase, type: 'decoration', x: 0, z: 0, boundingRadius: 2 });

        // Light poles around platform
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2;
          const px = 3 * Math.cos(angle);
          const pz = 3 * Math.sin(angle);
          this.createLightPost(outsideScene, px, pz);
        }

        // Background objects
        const brownBlock = new THREE.Mesh(
          new THREE.BoxGeometry(10, 5, 5),
          new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        brownBlock.position.set(-10, 2.5, -20);
        brownBlock.rotation.y = Math.PI / 6;
        outsideScene.add(brownBlock);
        this.outsideObjects.push({ mesh: brownBlock, type: 'building', x: -10, z: -20, boundingRadius: 5 });

        const blackCube = new THREE.Mesh(
          new THREE.BoxGeometry(5, 10, 5),
          new THREE.MeshStandardMaterial({ color: 0x000000 })
        );
        blackCube.position.set(10, 5, -15);
        outsideScene.add(blackCube);
        this.outsideObjects.push({ mesh: blackCube, type: 'building', x: 10, z: -15, boundingRadius: 3 });

        // Collectibles
        this.createCoins(outsideScene, 5);
        this.createGems(outsideScene, 5);

        // Castle and relocated light post
        this.createCastle(outsideScene);
        this.createLightPost(outsideScene, 35, 50); // Moved to (35, 50) as requested

        camera.position.set(15, 15, 15);
        camera.lookAt(0, 1, 0);
      }

      initInsideScene() {
        insideScene.background = new THREE.Color(0x333333); // Dark interior
        const floorSize = 60;
        const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x808080, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        insideScene.add(floor);

        const wallHeight = 20, thickness = 1;
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const walls = [
          new THREE.Mesh(new THREE.BoxGeometry(floorSize, wallHeight, thickness), wallMat.clone()), // Front
          new THREE.Mesh(new THREE.BoxGeometry(floorSize, wallHeight, thickness), wallMat.clone()), // Back
          new THREE.Mesh(new THREE.BoxGeometry(thickness, wallHeight, floorSize), wallMat.clone()), // Left
          new THREE.Mesh(new THREE.BoxGeometry(thickness, wallHeight, floorSize), wallMat.clone())  // Right
        ];
        walls[0].position.set(0, wallHeight / 2, floorSize / 2);
        walls[1].position.set(0, wallHeight / 2, -floorSize / 2);
        walls[2].position.set(-floorSize / 2, wallHeight / 2, 0);
        walls[3].position.set(floorSize / 2, wallHeight / 2, 0);
        walls.forEach(wall => insideScene.add(wall));
        const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), wallMat);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = wallHeight;
        insideScene.add(ceiling);

        const amb = new THREE.AmbientLight(0xffffff, 0.4);
        insideScene.add(amb);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(10, 20, 10);
        insideScene.add(dir);

        const doorGeo = new THREE.PlaneGeometry(4, 6);
        const doorMat = new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide });
        const exitDoor = new THREE.Mesh(doorGeo, doorMat);
        exitDoor.position.set(0, 3, -floorSize / 2 + 1);
        insideScene.add(exitDoor);
        this.castleExit = { x: 0, z: -28, boundingRadius: 2 };

        // Add King and Queen NPCs
        const king = this.makeNPC(insideScene, 0xffd700, -5, 0, "Welcome to the castle!"); // Gold-colored King
        const queen = this.makeNPC(insideScene, 0xc0c0c0, 5, 0, "Greetings, Princess!"); // Silver-colored Queen
        this.castleNPCData = [
          { object: king, speed: 0.02 },
          { object: queen, speed: 0.02 }
        ];
      }

      createPlayerModel() {
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16),
          new THREE.MeshStandardMaterial({ color: 0xff69b4 }) // Pink body
        );
        body.position.y = 0.6;
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 }) // Skin-tone head
        );
        head.position.y = 1.4;
        group.add(head);
        group.position.set(this.player.x, this.player.y, this.player.z);
        this.player.object = group;
      }

      createLightPost(sceneRef, x, z) {
        const pole = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 3, 8),
          new THREE.MeshStandardMaterial({ color: 0x000000 })
        );
        pole.position.set(x, 1.5, z);
        const light = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        light.position.set(x, 3, z);
        sceneRef.add(pole, light);
        this.outsideObjects.push({ mesh: pole, type: 'decoration', x: x, z: z, boundingRadius: 0.5 });
      }

      createCastle(sceneRef) {
        const group = new THREE.Group();
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(10, 5, 10),
          new THREE.MeshStandardMaterial({ color: 0x808080 })
        );
        base.position.set(0, 2.5, 0);
        group.add(base);
        const door = new THREE.Mesh(
          new THREE.PlaneGeometry(2, 4),
          new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide })
        );
        door.position.set(0, 2, 5.01);
        group.add(door);
        group.position.set(40, 0, 40);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'building', x: 40, z: 40, boundingRadius: 5 });
      }

      createCoins(sceneRef, count) {
        for (let i = 0; i < count; i++) {
          const cx = Math.random() * 50 - 25;
          const cz = Math.random() * 50 - 25;
          const coin = new THREE.Mesh(
            new THREE.CircleGeometry(0.2, 16),
            new THREE.MeshStandardMaterial({ color: 0xffff00 })
          );
          coin.rotation.x = -Math.PI / 2;
          coin.position.set(cx, 0.01, cz);
          sceneRef.add(coin);
          this.outsideObjects.push({ mesh: coin, type: 'coin', x: cx, z: cz, boundingRadius: 0.2 });
        }
      }

      createGems(sceneRef, count) {
        for (let i = 0; i < count; i++) {
          const gx = Math.random() * 50 - 25;
          const gz = Math.random() * 50 - 25;
          const gem = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.3, 0),
            new THREE.MeshStandardMaterial({ color: 0x800080 })
          );
          gem.position.set(gx, 0.3, gz);
          sceneRef.add(gem);
          this.outsideObjects.push({ mesh: gem, type: 'gem', x: gx, z: gz, boundingRadius: 0.3 });
        }
      }

      makeNPC(sceneRef, color, x, z, dialogue) {
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16),
          new THREE.MeshStandardMaterial({ color: color })
        );
        body.position.y = 0.6;
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 })
        );
        head.position.y = 1.4;
        group.add(head);
        group.position.set(x, 0.5, z);
        group.userData = { dialogue: dialogue, target: null };
        sceneRef.add(group);
        return group;
      }

      enterCastle() {
        isInsideCastle = true;
        document.getElementById('location').textContent = "Castle Interior";
        outsideScene.remove(this.player.object);
        insideScene.add(this.player.object);
        this.player.x = 0; this.player.y = 0.5; this.player.z = 0;
        this.player.yaw = Math.PI;
        activeScene = insideScene;
      }

      exitCastle() {
        isInsideCastle = false;
        document.getElementById('location').textContent = "Town";
        insideScene.remove(this.player.object);
        outsideScene.add(this.player.object);
        this.player.x = 40; this.player.y = 0.5; this.player.z = 55;
        this.player.yaw = 0;
        activeScene = outsideScene;
      }

      checkCastleDoor() {
        if (isInsideCastle) return;
        const dx = this.player.x - 40;
        const dz = this.player.z - 40;
        if (dx * dx + dz * dz < 9) this.enterCastle();
      }

      checkCastleExitDoor() {
        if (!isInsideCastle || !this.castleExit) return;
        const dx = this.player.x - this.castleExit.x;
        const dz = this.player.z - this.castleExit.z;
        if (dx * dx + dz * dz < this.castleExit.boundingRadius * this.castleExit.boundingRadius) this.exitCastle();
      }

      startAnimation() {
        const animate = () => {
          requestAnimationFrame(animate);
          this.update();
          this.renderer.render(activeScene, camera);
        };
        animate();
      }

      update() {
        this.updateMovement();
        this.updateCollisions();
        this.updateBalls();
        this.updatePickups();
        if (isInsideCastle) {
          this.updateCastleNPCs();
          this.checkCastleExitDoor();
        } else {
          this.checkCastleDoor();
        }
        this.updateCamera();
      }

      updateMovement() {
        let keyboardForward = 0, keyboardTurn = 0;
        if (this.keysPressed['ArrowUp']) keyboardForward++;
        if (this.keysPressed['ArrowDown']) keyboardForward--;
        if (this.keysPressed['ArrowLeft']) keyboardTurn++;
        if (this.keysPressed['ArrowRight']) keyboardTurn--;
        let touchForward = 0, touchStrafe = 0;
        if (controllerState.dpadUp) touchForward++;
        if (controllerState.dpadDown) touchForward--;
        if (controllerState.dpadLeft) touchStrafe++;
        if (controllerState.dpadRight) touchStrafe--;
        let finalForward = (keyboardForward !== 0 ? keyboardForward : touchForward);
        let finalStrafe = touchStrafe;
        let finalTurn = keyboardTurn;
        if (controllerState.turnLeft) finalTurn++;
        if (controllerState.turnRight) finalTurn--;
        const forwardVec = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
        const rightVec = new THREE.Vector3(Math.cos(this.player.yaw), 0, -Math.sin(this.player.yaw));
        const movement = forwardVec.clone().multiplyScalar(finalForward)
                          .add(rightVec.clone().multiplyScalar(finalStrafe));
        if (movement.length() > 1) movement.normalize();
        movement.multiplyScalar(this.player.speedKeyboard);
        const newX = this.player.x + movement.x;
        const newZ = this.player.z + movement.z;
        let canMove = true;
        const collObjs = isInsideCastle ? this.insideObjects : this.outsideObjects;
        for (const obj of collObjs) {
          if (['building', 'decoration'].includes(obj.type)) {
            const dx = newX - obj.x;
            const dz = newZ - obj.z;
            const minDist = (obj.boundingRadius || 1) + 0.5;
            if (dx * dx + dz * dz < minDist * minDist) {
              canMove = false;
              break;
            }
          }
        }
        if (canMove) {
          this.player.x = newX;
          this.player.z = newZ;
        }
        if (isInsideCastle) {
          this.player.x = Math.max(-28, Math.min(28, this.player.x));
          this.player.z = Math.max(-28, Math.min(28, this.player.z));
        }
        this.player.yaw += finalTurn * 0.02;
        if (this.player.jumpVelocity !== 0 || this.player.y > 0.5) {
          this.player.jumpVelocity -= 0.02;
          this.player.y += this.player.jumpVelocity;
          if (this.player.y < 0.5) {
            this.player.y = 0.5;
            this.player.jumpVelocity = 0;
          }
        }
        if (this.player.object) {
          this.player.object.position.set(this.player.x, this.player.y, this.player.z);
          this.player.object.rotation.y = this.player.yaw;
        }
      }

      updateCamera() {
        const camDist = 15;
        const offsetX = -Math.sin(this.player.yaw) * camDist;
        const offsetZ = -Math.cos(this.player.yaw) * camDist;
        camera.position.set(this.player.x + offsetX, this.player.y + 10, this.player.z + offsetZ);
        camera.lookAt(this.player.x, this.player.y + 1, this.player.z);
      }

      updateCollisions() {}

      updateBalls() {
        for (let i = this.thrownBalls.length - 1; i >= 0; i--) {
          const ball = this.thrownBalls[i];
          ball.position.add(ball.userData.velocity);
          ball.userData.velocity.y -= 0.01;
          if (ball.position.y < 0) {
            (isInsideCastle ? insideScene : outsideScene).remove(ball);
            this.thrownBalls.splice(i, 1);
          }
        }
      }

      updatePickups() {
        for (let i = this.outsideObjects.length - 1; i >= 0; i--) {
          const obj = this.outsideObjects[i];
          if (["coin", "gem"].includes(obj.type)) {
            const dx = this.player.x - obj.x;
            const dz = this.player.z - obj.z;
            if (dx * dx + dz * dz < 1.0) {
              switch (obj.type) {
                case "coin": this.coins++; document.getElementById('coins').textContent = this.coins; break;
                case "gem": this.gems++; document.getElementById('gems').textContent = this.gems; break;
              }
              outsideScene.remove(obj.mesh);
              this.outsideObjects.splice(i, 1);
            }
          }
        }
      }

      updateCastleNPCs() {
        for (const data of this.castleNPCData) {
          const npc = data.object;
          const d = npc.userData;
          if (!d.target) {
            d.target = { x: Math.random() * 56 - 28, z: Math.random() * 56 - 28 };
          }
          const dx = d.target.x - npc.position.x;
          const dz = d.target.z - npc.position.z;
          if (dx * dx + dz * dz < 1) {
            d.target = null;
          } else {
            const angle = Math.atan2(dx, dz);
            npc.rotation.y = angle;
            const step = data.speed;
            npc.position.x += Math.sin(angle) * step;
            npc.position.z += Math.cos(angle) * step;
            npc.position.x = Math.max(-28, Math.min(28, npc.position.x));
            npc.position.z = Math.max(-28, Math.min(28, npc.position.z));
          }
          const pdx = this.player.x - npc.position.x;
          const pdz = this.player.z - npc.position.z;
          if (pdx * pdx + pdz * pdz < 25) this.showDialogue(d.dialogue);
        }
      }

      throwBall() {
        const direction = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
        const ball = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xff4500 })
        );
        ball.position.set(this.player.x, this.player.y + 1, this.player.z);
        ball.userData = { velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0, 0.3, 0)) };
        (isInsideCastle ? insideScene : outsideScene).add(ball);
        this.thrownBalls.push(ball);
        this.ballCount++;
        document.getElementById('ballCountValue').textContent = this.ballCount;
      }

      jump() {
        if (this.player.y <= 0.5) this.player.jumpVelocity = 0.3;
      }

      showDialogue(text) {
        const dlg = document.getElementById('dialogue');
        dlg.style.display = 'block';
        dlg.textContent = text;
        setTimeout(() => { dlg.style.display = 'none'; dlg.textContent = ''; }, 1500);
      }

      initKeyboardMouse() {
        document.addEventListener('keydown', e => {
          this.keysPressed[e.key] = true;
          if (e.key === ' ') this.throwBall();
          if (e.key === 'b' || e.key === 'B') this.jump();
        });
        document.addEventListener('keyup', e => {
          this.keysPressed[e.key] = false;
        });
      }
    }

    window.game = new Game();
  </script>
</body>
</html>
