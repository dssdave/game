<!DOCTYPE html>
<html>
<head>
    <title>Princess RPG - Standalone Edition</title>
    <style>
        #gameContainer {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid black;
        }
        #ui {
            margin-top: 10px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            Flowers: <span id="flowers">0</span> |
            Coins: <span id="coins">0</span> |
            Location: <span id="location">Town</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported!');
            throw new Error('WebGL not supported');
        }

        // Game state
        class Game {
            constructor() {
                this.scene = 'town';
                this.flowers = 0;
                this.coins = 0;
                this.player = {
                    x: 0,
                    y: 0,
                    z: 10,
                    speed: 0.5,
                    yaw: 0,
                    pitch: 0,
                    model: null
                };
                this.camera = {
                    x: 0,
                    y: -50,
                    z: 30,
                    yaw: 0,
                    pitch: -Math.PI / 6,
                    roll: 0
                };
                this.light = {
                    x: 50,
                    y: 50,
                    z: 100,
                    color: [1, 1, 1]
                };
            }
        }

        let game = new Game();

        // Simplified shaders for debugging
        const vertexShaderSource = `
            attribute vec3 a_position;
            uniform mat4 u_projection;
            uniform mat4 u_view;
            uniform mat4 u_model;
            void main() {
                gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Solid red for testing
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }
        gl.useProgram(program);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        const projLoc = gl.getUniformLocation(program, 'u_projection');
        const viewLoc = gl.getUniformLocation(program, 'u_view');
        const modelLoc = gl.getUniformLocation(program, 'u_model');

        function mat4() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        function perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
            return out;
        }

        function multiply(out, a, b) {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    out[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        out[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return out;
        }

        function translate(out, x, y, z) {
            out[12] = x; out[13] = y; out[14] = z;
            return out;
        }

        function rotateY(out, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            out[0] = c; out[2] = -s;
            out[8] = s; out[10] = c;
            return out;
        }

        function generatePlayerModel() {
            return {
                vertices: [
                    -1, 0, -1,  1, 0, -1,  1, 2, -1, -1, 2, -1,
                    -1, 0,  1,  1, 0,  1,  1, 2,  1, -1, 2,  1,
                    -2, 0, -2,  2, 0, -2,  2, 1, -2, -2, 1, -2,
                    -2, 0,  2,  2, 0,  2,  2, 1,  2, -2, 1,  2
                ],
                indices: [
                    0, 1, 2,  0, 2, 3,
                    4, 5, 6,  4, 6, 7,
                    8, 9, 10, 8, 10, 11,
                    12, 13, 14, 12, 14, 15
                ]
            };
        }

        const objects = {
            town: [
                {type: 'building', x: 20, y: 0, z: 20, width: 10, height: 15, depth: 10},
                {type: 'building', x: -20, y: 0, z: -20, width: 8, height: 6, depth: 8},
                {type: 'flower', x: 10, y: 0, z: 10, width: 2, height: 2, depth: 2},
                {type: 'coin', x: -10, y: 0, z: -10, width: 2, height: 2, depth: 2}
            ],
            castle: [
                {type: 'door', x: 0, y: 0, z: 0, width: 4, height: 4, depth: 1}
            ],
            house: [
                {type: 'door', x: 0, y: 0, z: 0, width: 4, height: 4, depth: 1}
            ]
        };

        game.player.model = generatePlayerModel();

        const positionBuffer = gl.createBuffer();
        const indexBuffer = gl.createBuffer();

        const keys = {};
        let mouseDown = false;
        let lastX, lastY;
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);
        canvas.addEventListener('mousedown', (e) => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const dx = (e.clientX - lastX) * 0.005;
                const dy = (e.clientY - lastY) * 0.005;
                game.camera.yaw += dx;
                game.camera.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, game.camera.pitch + dy));
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        function update() {
            const forward = [Math.sin(game.player.yaw), 0, Math.cos(game.player.yaw)];
            const right = [Math.cos(game.player.yaw), 0, -Math.sin(game.player.yaw)];
            if (keys['w']) {
                game.player.x += forward[0] * game.player.speed;
                game.player.z += forward[2] * game.player.speed;
            }
            if (keys['s']) {
                game.player.x -= forward[0] * game.player.speed;
                game.player.z -= forward[2] * game.player.speed;
            }
            if (keys['a']) {
                game.player.x -= right[0] * game.player.speed;
                game.player.z -= right[2] * game.player.speed;
            }
            if (keys['d']) {
                game.player.x += right[0] * game.player.speed;
                game.player.z += right[2] * game.player.speed;
            }
            if (keys['ArrowLeft']) game.player.yaw += 0.05;
            if (keys['ArrowRight']) game.player.yaw -= 0.05;

            game.camera.x = game.player.x;
            game.camera.z = game.player.z + 30 * Math.cos(game.camera.pitch);

            const currentObjects = objects[game.scene];
            for (let i = currentObjects.length - 1; i >= 0; i--) {
                const obj = currentObjects[i];
                if (obj.type !== 'terrain' && Math.abs(game.player.x - obj.x) < 5 && Math.abs(game.player.z - obj.z) < 5) {
                    if (obj.type === 'flower') {
                        game.flowers++;
                        currentObjects.splice(i, 1);
                    } else if (obj.type === 'coin') {
                        game.coins++;
                        currentObjects.splice(i, 1);
                    } else if (obj.type === 'building') {
                        game.scene = obj.x > 0 ? 'castle' : 'house';
                        game.player.x = 0;
                        game.player.z = 0;
                    } else if (obj.type === 'door') {
                        game.scene = 'town';
                        game.player.x = 0;
                        game.player.z = 0;
                    }
                }
            }
        }

        function drawObject(obj) {
            const vertices = [
                obj.x - obj.width/2, obj.y, obj.z - obj.depth/2,
                obj.x + obj.width/2, obj.y, obj.z - obj.depth/2,
                obj.x + obj.width/2, obj.y + obj.height, obj.z - obj.depth/2,
                obj.x - obj.width/2, obj.y + obj.height, obj.z - obj.depth/2,
                obj.x - obj.width/2, obj.y, obj.z + obj.depth/2,
                obj.x + obj.width/2, obj.y, obj.z + obj.depth/2,
                obj.x + obj.width/2, obj.y + obj.height, obj.z + obj.depth/2,
                obj.x - obj.width/2, obj.y + obj.height, obj.z + obj.depth/2
            ];
            const indices = [
                0, 1, 2,  0, 2, 3,
                4, 5, 6,  4, 6, 7,
                0, 4, 7,  0, 7, 3,
                1, 5, 6,  1, 6, 2
            ];

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionLoc);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            let model = mat4();
            model = translate(model, obj.x, obj.y, obj.z);
            gl.uniformMatrix4fv(modelLoc, false, model);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        function drawPlayer() {
            const { vertices, indices } = game.player.model;

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionLoc);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            let model = mat4();
            model = translate(model, game.player.x, game.player.y, game.player.z);
            model = multiply(mat4(), rotateY(mat4(), game.player.yaw), model);
            gl.uniformMatrix4fv(modelLoc, false, model);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        function draw() {
            gl.clearColor(0.53, 0.81, 0.98, 1); // Sky blue background
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            let projection = mat4();
            perspective(projection, Math.PI / 3, canvas.width / canvas.height, 0.1, 1000);
            gl.uniformMatrix4fv(projLoc, false, projection);

            let view = mat4();
            view = translate(view, -game.camera.x, -game.camera.y, -game.camera.z);
            view = multiply(mat4(), rotateX(mat4(), game.camera.pitch), view);
            view = multiply(mat4(), rotateY(mat4(), game.camera.yaw), view);
            gl.uniformMatrix4fv(viewLoc, false, view);

            objects[game.scene].forEach(drawObject);
            drawPlayer();

            document.getElementById('flowers').textContent = game.flowers;
            document.getElementById('coins').textContent = game.coins;
            document.getElementById('location').textContent = game.scene.charAt(0).toUpperCase() + game.scene.slice(1);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
