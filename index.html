<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Princess Donia’s Town - Enhanced 3D RPG</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }

      /* UI boxes – large style for desktop; smaller on mobile */
      #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
        background: rgba(0,0,0,0.7);
        border: 4px solid #fff;
        border-radius: 5px;
        color: #fff;
        font-size: 28px;
        padding: 40px 80px;
      }
      #ui, #ballCount, #dialogue, #controls {
        position: absolute;
        z-index: 10;
      }
      #ui { top: 10px; left: 10px; }
      #ballCount { top: 10px; right: 10px; }
      #dialogue { bottom: 10px; left: 10px; max-width: 600px; }
      #controls { bottom: 10px; right: 10px; }
      #errorMessage {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%,-50%);
        display: none;
        z-index: 20;
      }
      #guardPopup {
        position: absolute;
        bottom: 50%;
        left: 50%;
        transform: translate(-50%,50%);
        display: none;
        z-index: 50;
        text-align: center;
      }

      /* Joystick containers: dynamic approach, smaller zone */
      #joystickLeft, #joystickRight {
        position: absolute;
        width: 12vw;
        height: 12vw;
        min-width: 60px;
        min-height: 60px;
        max-width: 80px;
        max-height: 80px;
        opacity: 0.5;
        z-index: 15;
      }
      /* We'll keep them hidden at first – dynamic mode spawns them anywhere user touches. */
      #joystickLeft {
        bottom: 14vh; left: 10vw;
        display: none; /* dynamic spawn */
      }
      #joystickRight {
        bottom: 14vh; right: 10vw;
        display: none; /* dynamic spawn */
      }

      /* Button to toggle UI (top center) */
      #toggleUIBtn {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 11;
        font-size: 24px;
        padding: 10px 20px;
        background: #333;
        color: #fff;
        border: 2px solid #fff;
        border-radius: 5px;
        cursor: pointer;
      }

      /* Reorient button – small circle at bottom center */
      #reorientBtn {
        position: absolute;
        bottom: 16vh;
        left: 50%;
        transform: translateX(-50%);
        width: 60px; height: 60px;
        border-radius: 50%;
        background: #666;
        color: #fff;
        border: 2px solid #fff;
        text-align: center;
        line-height: 60px;
        font-size: 20px;
        z-index: 12;
        cursor: pointer;
      }

      /* Smaller UI on narrower screens */
      @media (max-width: 768px) {
        #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
          font-size: 16px;
          padding: 20px 30px;
        }
        #toggleUIBtn, #reorientBtn {
          font-size: 16px;
          width: 50px; height: 50px; line-height: 50px;
        }
      }
    </style>

    <!-- Three.js + NippleJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>

      <button id="toggleUIBtn">Toggle UI</button>
      <button id="reorientBtn">↺</button>

      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>
      <div id="ballCount">
        Balls Thrown: <span id="ballCountValue">0</span>
      </div>
      <div id="dialogue"></div>
      <div id="controls">
        Controls:<br>
        Joysticks/Arrow Keys: Move<br>
        Joysticks/Mouse: Look Around<br>
        Tap Center/Space: Throw Ball
      </div>
      <div id="joystickLeft"></div>
      <div id="joystickRight"></div>
      <div id="errorMessage">WebGL not supported in your browser. Use a modern browser.</div>
      <div id="guardPopup"></div>
    </div>

    <script>
      // Toggle UI
      document.getElementById('toggleUIBtn').addEventListener('click', () => {
        for (let id of ["ui","ballCount","dialogue","controls","guardPopup","errorMessage"]) {
          const el = document.getElementById(id);
          if (el.style.display === "none") el.style.display = "block";
          else el.style.display = "none";
        }
      });

      // Gracefully handle pointer lock SecurityError
      window.addEventListener('unhandledrejection', e => {
        if (e.reason && e.reason.name === 'SecurityError') {
          console.warn('Pointer lock security error ignored:', e.reason);
          e.preventDefault();
        }
      });

      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');
        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          throw new Error('WebGL not supported');
        }

        // Basic Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameCanvas.style.display = 'block';

        // Data for NPCs
        let npcBlueData = { angle:0, speed:0.0008, radius:120, object:null };
        let npcYellowData = { object:null, pathIndex:0, speed:0.01, target:null };
        let mermaidData = { object:null, route:[{x:-50,z:-70},{x:50,z:-70}], routeIndex:0, direction:1, speed:0.01, splashTimer:0 };
        let guardData = {
          object:null,
          state:'idle',  // 'idle','patrol'
          timer:0,       // increments each update
          route:[
            {x:30,z:40},{x:30,z:50},{x:50,z:50},{x:50,z:40},{x:40,z:40} // loop around castle
          ],
          routeIndex:0,
          speed:0.02
        };

        let birdData = { angle:0, speed:0.002, radius:140, object:null };

        class Game {
          constructor() {
            // Game state
            this.scene = 'town';
            this.flowers = 0;
            this.coins = 0;
            this.gems = 0;
            this.potions = 0;
            this.keys = 0;
            this.artifacts = 0;
            this.health = 100;
            this.time = 'Day';
            this.dayNightCycle = 0;

            this.player = {
              x:0, z:0,
              speedKeyboard: 0.07,
              speedJoystick: 0.04, // slightly slower for easier control
              yaw:0, pitch:-0.2,
              object:null,
              lastMoveVec:new THREE.Vector3(1,0,0),
              waterSplashTimer:0
            };

            this.dialogue = '';
            this.dialogueTimer = 0;
            this.objects = [];
            this.buildingPositions = [];
            this.ballCount = 0;
            this.thrownBalls = [];
            this.collectionGlow = null;
            this.joystickLeft = null;
            this.joystickRight = null;
            this.keysPressed = {};
            this.sceneObj = scene;
            this.camera = camera;
            this.renderer = renderer;
            this.itemRange = 80;

            // Day/Night
            this.sunMesh = null;
            this.moonMesh = null;
            this.starsMesh = null;

            // Interactions
            this.guardObject = null;
            this.guardMessageShown = false;
            this.npcBlueMessageShown = false;
            this.mermaidMessageShown = false;
            this.npcYellowMessageShown = false;

            this.initScene();
            this.initJoysticks();
            this.initKeyboardMouse();
            this.startAnimation();
          }

          initScene() {
            // Ground
            const groundGeo = new THREE.PlaneGeometry(300,300);
            const groundMat = new THREE.MeshStandardMaterial({ color:0x6bb26b, side:THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = Math.PI/2;
            this.sceneObj.add(ground);

            // Sky
            const skyGeo = new THREE.SphereGeometry(3000,60,40); // bigger radius
            const skyMat = new THREE.ShaderMaterial({
              uniforms: {
                topColor:{ value:new THREE.Color(0x87ceeb) },
                bottomColor:{ value:new THREE.Color(0x2f4f4f) },
                offset:{ value:0.5 },
                exponent:{ value:0.6 }
              },
              vertexShader:`
                varying vec3 vWorldPosition;
                void main() {
                  vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                  vWorldPosition = worldPosition.xyz;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader:`
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                  float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
                  gl_FragColor = vec4(
                    mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)),
                    1.0
                  );
                }
              `,
              side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.name = 'sky';
            this.sceneObj.add(sky);

            // Lighting
            const ambient = new THREE.AmbientLight(0x404040, 0.6);
            this.sceneObj.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10,20,10);
            this.sceneObj.add(dirLight);

            // Rolling hills
            this.createRollingHills();
            // Beach + water
            this.createBeach();
            // Characters
            this.createPlayerModel();
            this.createBlueNPC();
            this.createYellowNPC();
            this.createGuardAtCastle();
            this.createMermaid();
            this.createBird(); // Important
            // Boundary
            this.createBoundary();
            // Buildings
            this.createCastle();
            this.createHouse();
            this.createFountain();
            this.createCafe();
            // Shrubs behind house
            this.addShrubsAndTreesBehindHouse();
            // Items
            this.createFlowers(10);
            this.createCoins(8);
            this.createGems(4);
            this.createPotions(3);
            this.createKeys(2);
            this.createArtifacts(2);
            // Day/Night
            this.createSun();
            this.createMoon();
            this.createStars();
          }

          /* Basic geometry for hills, beach, etc. */
          createRollingHills(){/* see code in previous snippet */}
          createBeach(){/* see code in previous snippet */}
          createBoundary(){/* see code in previous snippet */}
          addShrubsAndTreesBehindHouse(){/* see code in previous snippet */}
          createCastle(){/* see code in previous snippet */}
          createHouse(){/* see code in previous snippet */}
          createFountain(){/* see code in previous snippet */}
          createCafe(){/* see code in previous snippet */}

          /* Player, NPCs, mermaid, bird, etc. */
          createPlayerModel(){/* half-sphere hair replaced with top sphere => see code in previous snippet */}
          createBlueNPC(){/* see code in previous snippet */}
          createYellowNPC(){/* see code in previous snippet */}
          createGuardAtCastle(){/* see code in previous snippet */}
          createMermaid(){/* see code in previous snippet */}
          createBird(){
            const bird = new THREE.Mesh(new THREE.SphereGeometry(0.5,8,8), new THREE.MeshStandardMaterial({ color:0xffffff }));
            bird.position.set(0,30,0);
            birdData.object = bird;
            this.sceneObj.add(bird);
          }

          /* Items */
          createFlowers(count){/* see code in previous snippet */}
          createCoins(count){/* see code in previous snippet */}
          createGems(count){/* see code in previous snippet */}
          createPotions(count){/* see code in previous snippet */}
          createKeys(count){/* see code in previous snippet */}
          createArtifacts(count){/* see code in previous snippet */}

          /* Sun, Moon, Stars */
          createSun(){/* see code in previous snippet */}
          createMoon(){/* see code in previous snippet */}
          createStars(){
            const starCount=300;
            const positions=new Float32Array(starCount*3);
            for(let i=0;i<starCount;i++){
              const radius=2000+Math.random()*800; // bigger radius
              const angle=Math.random()*Math.PI*2;
              const ySpread=Math.random()*200-50;
              positions[i*3]=Math.cos(angle)*radius;
              positions[i*3+1]=50+ySpread;
              positions[i*3+2]=Math.sin(angle)*radius;
            }
            const starGeo=new THREE.BufferGeometry();
            starGeo.setAttribute('position',new THREE.BufferAttribute(positions,3));
            const starMat=new THREE.PointsMaterial({ color:0xffffff, size:1.2 });
            starMat.depthTest=false; // behind everything
            const starField=new THREE.Points(starGeo,starMat);
            starField.visible=false;
            this.sceneObj.add(starField);
            this.starsMesh=starField;
          }

          /* Animation loop */
          startAnimation(){
            const animate=()=>{
              requestAnimationFrame(animate);
              this.update();
              this.renderer.render(this.sceneObj,this.camera);
            };
            animate();
          }

          update(){
            this.updateDayNight();
            this.updateBalls();
            this.updatePlayer();
            this.updateBlueNPC();
            this.updateYellowNPC();
            this.updateMermaid();
            this.updateGuardPatrol();
            this.updateBird();
            this.updateCollisions();
            this.updateCamera();
            this.updatePickups();
          }

          /* Day/Night cycle */
          updateDayNight(){
            this.dayNightCycle=(this.dayNightCycle+1)%1200;
            this.time=this.dayNightCycle<600?'Day':'Night';
            document.getElementById('time').textContent=this.time;
            if(this.sunMesh&&this.moonMesh&&this.starsMesh){
              if(this.time==='Day'){
                this.sunMesh.visible=true;
                this.moonMesh.visible=false;
                this.starsMesh.visible=false;
              } else {
                this.sunMesh.visible=false;
                this.moonMesh.visible=true;
                this.starsMesh.visible=true;
              }
            }
          }

          /* Balls */
          updateBalls(){/* see code in previous snippet */}
          spawnRipple(x,z){/* see code in previous snippet */}

          /* Player movement + water splash */
          updatePlayer(){/* see code in previous snippet, with slower speeds */}
          
          /* Blue NPC – circle around center */
          updateBlueNPC(){
            npcBlueData.angle+=npcBlueData.speed;
            const npcX=npcBlueData.radius*Math.cos(npcBlueData.angle);
            const npcZ=npcBlueData.radius*Math.sin(npcBlueData.angle);
            if(npcBlueData.object){
              npcBlueData.object.position.set(npcX,0.5,npcZ);
              npcBlueData.object.rotation.y=-npcBlueData.angle;
              for(const obj of this.objects){
                if(obj.mesh===npcBlueData.object){
                  obj.x=npcX; obj.z=npcZ;
                  break;
                }
              }
            }
          }

          /* Yellow NPC – roam among buildingPositions */
          updateYellowNPC(){
            if(!npcYellowData.object) return;
            const npc=npcYellowData.object;
            if(!npcYellowData.target){
              npcYellowData.target=this.getRandomBuildingTarget();
            }
            const dx=npcYellowData.target.x-npc.position.x;
            const dz=npcYellowData.target.z-npc.position.z;
            const distSq=dx*dx+dz*dz;
            if(distSq<1){
              // arrived => pick new
              npcYellowData.target=this.getRandomBuildingTarget();
            } else {
              const angle=Math.atan2(-dx,dz);
              npc.rotation.y=angle;
              const step=npcYellowData.speed;
              const newX=npc.position.x+Math.sin(angle)*step;
              const newZ=npc.position.z+Math.cos(angle)*step;
              if(Math.abs(newX)<125&&Math.abs(newZ)<125){
                npc.position.x=newX;
                npc.position.z=newZ;
              }
            }
            for(const obj of this.objects){
              if(obj.mesh===npcYellowData.object){
                obj.x=npc.position.x; obj.z=npc.position.z;
                break;
              }
            }
          }
          getRandomBuildingTarget(){
            const i=Math.floor(Math.random()*this.buildingPositions.length);
            return this.buildingPositions[i];
          }

          /* Mermaid – pace left<->right in water */
          updateMermaid(){
            if(!mermaidData.object) return;
            const m=mermaidData;
            // current route points
            const currentPt=m.route[m.routeIndex];
            const dx=currentPt.x - m.object.position.x;
            const dz=currentPt.z - m.object.position.z;
            const distSq=dx*dx+dz*dz;
            if(distSq<1){
              // reached => next
              m.routeIndex=(m.routeIndex+1)%m.route.length;
            }
            const angle=Math.atan2(-dx,dz);
            m.object.rotation.y=angle;
            const step=m.speed;
            const newX=m.object.position.x+Math.sin(angle)*step;
            const newZ=m.object.position.z+Math.cos(angle)*step;
            m.object.position.set(newX, m.object.position.y, newZ);

            // collisions
            for(const obj of this.objects){
              if(obj.mesh===m.object){
                obj.x=newX; obj.z=newZ;
                break;
              }
            }
            // water splashes
            m.splashTimer=(m.splashTimer||0)+1;
            if(m.splashTimer>30){
              this.spawnRipple(newX,newZ);
              m.splashTimer=0;
            }
          }

          /* Guard – idle 2 minutes, do a lap, return, idle again */
          updateGuardPatrol(){
            if(!guardData.object) return;
            guardData.timer++;
            if(guardData.state==='idle'){
              // wait 2 minutes => 120s => ~7200 frames if 60fps
              if(guardData.timer>7200){
                guardData.state='patrol';
                guardData.timer=0;
                guardData.routeIndex=0;
              }
            } else if(guardData.state==='patrol'){
              const route=guardData.route;
              const guard=guardData.object;
              const target=route[guardData.routeIndex];
              const dx=target.x-guard.position.x;
              const dz=target.z-guard.position.z;
              const distSq=dx*dx+dz*dz;
              if(distSq<1){
                guardData.routeIndex++;
                if(guardData.routeIndex>=route.length){
                  // done lap => return idle
                  guardData.state='idle';
                  guardData.timer=0;
                }
              } else {
                const angle=Math.atan2(-dx,dz);
                guard.rotation.y=angle;
                const step=guardData.speed;
                const newX=guard.position.x+Math.sin(angle)*step;
                const newZ=guard.position.z+Math.cos(angle)*step;
                guard.position.set(newX,0.5,newZ);
                // collisions
                for(const obj of this.objects){
                  if(obj.mesh===guard){
                    obj.x=newX; obj.z=newZ;
                    break;
                  }
                }
              }
            }
          }

          /* Bird – circle overhead */
          updateBird(){
            birdData.angle+=birdData.speed;
            const bx=birdData.radius*Math.cos(birdData.angle);
            const bz=birdData.radius*Math.sin(birdData.angle);
            if(birdData.object){
              birdData.object.position.set(bx,60,bz);
              birdData.object.rotation.y=-birdData.angle;
            }
          }

          /* Collisions + camera + pickups */
          updateCollisions(){/* see code in previous snippet */}
          updateCamera(){/* see code in previous snippet */}
          updatePickups(){/* see code in previous snippet */}

          /* Utility: Dialogue, guard popup, throwBall, glow, etc. */
          showDialogue(text){
            document.getElementById('dialogue').textContent=text;
          }
          showGuardPopup(text){
            const popup=document.getElementById('guardPopup');
            popup.style.display='block';
            popup.textContent=text;
            setTimeout(()=>{
              popup.style.display='none';
              popup.textContent='';
            },2000);
          }
          throwBall(){/* see code in previous snippet */}
          startCollectionGlow(){/* see code in previous snippet */}

          /* Joysticks: dynamic mode => user can press anywhere. */
          initJoysticks(){
            // We'll create dynamic joysticks => appear where user touches
            this.joystickLeft=nipplejs.create({
              zone:document.getElementById('gameContainer'),
              mode:'dynamic',
              color:'white',
              size:100,
              threshold:0.1,
              multitouch:true, // allow multiple
              maxNumberOfNipples:1, // only 1 left joystick
              position:{},
              restOpacity:0.5
            });
            this.joystickLeft.on('move',(evt,data)=>{
              if(data&&data.force>0){
                const angle=data.angle.radian;
                // a bit less speed
                const speed=data.force*this.player.speedJoystick*0.7;
                const dx=Math.cos(angle)*speed;
                const dz=Math.sin(angle)*speed;
                const newX=this.player.x+dx;
                const newZ=this.player.z-dz;
                let blocked=false;
                for(const obj of this.objects){
                  if(obj.type==='building'||obj.type==='wall'||obj.type==='boundary'||obj.type==='decoration'||obj.type==='npc'){
                    const dxObj=newX-obj.x;
                    const dzObj=newZ-obj.z;
                    const distSq=dxObj*dxObj+dzObj*dzObj;
                    const r=(obj.boundingRadius||5);
                    if(distSq<r*r){ blocked=true; break; }
                  }
                }
                if(!blocked){
                  this.player.x=newX;
                  this.player.z=newZ;
                }
                this.joystickLeft.active=true;
              }
            });
            this.joystickLeft.on('end',()=>{ this.joystickLeft.active=false; });

            // Right joystick for looking
            this.joystickRight=nipplejs.create({
              zone:document.getElementById('gameContainer'),
              mode:'dynamic',
              color:'white',
              size:100,
              threshold:0.1,
              multitouch:true,
              maxNumberOfNipples:1,
              position:{},
              restOpacity:0.5
            });
            this.joystickRight.on('move',(evt,data)=>{
              if(data&&data.force>0){
                const sensitivity=0.0005;
                this.player.yaw+=data.vector.x*sensitivity*data.force;
                this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch+data.vector.y*sensitivity*data.force));
              }
            });
            this.joystickRight.on('end',()=>{});

            // Tapping center => throw ball
            document.getElementById('gameContainer').addEventListener('click', e=>{
              const rect=e.target.getBoundingClientRect();
              const x=e.clientX-rect.left;
              const y=e.clientY-rect.top;
              if(x>rect.width/4&&x<(rect.width*3)/4&&y>rect.height/4&&y<(rect.height*3)/4){
                this.throwBall();
              }
            });
          }

          /* Keyboard + pointer lock */
          initKeyboardMouse(){
            document.addEventListener('keydown',e=>{
              this.keysPressed[e.key]=true;
              if(e.key===' ')this.throwBall();
            });
            document.addEventListener('keyup',e=>{
              this.keysPressed[e.key]=false;
            });
            document.addEventListener('mousedown',()=>{
              try{
                document.body.requestPointerLock();
              }catch(err){
                console.warn('Pointer lock request failed:',err);
              }
            });
            document.addEventListener('mousemove',evt=>{
              if(document.pointerLockElement===document.body){
                const movementX=evt.movementX||0;
                const movementY=evt.movementY||0;
                const sensitivity=0.001;
                this.player.yaw+=movementX*sensitivity;
                this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch+movementY*sensitivity));
              }
            });
          }
        }

        // Create the game
        const game=new Game();

        // Reorient button: resets yaw/pitch
        document.getElementById('reorientBtn').addEventListener('click',()=>{
          game.player.yaw=0;
          game.player.pitch=0;
        });
      } catch(err){
        console.error('Error initializing the game:',err);
      }
    </script>
  </body>
</html>
