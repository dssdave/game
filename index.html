<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Prevent iPhone zooming and unwanted touches -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Princess Donia’s Town - SNES Controller + Full Environment</title>
    <style>
      /* Basic resets */
      html, body {
        margin: 0;
        padding: 0;
        background: #000;
        font-family: Arial, sans-serif;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        user-select: none;
        touch-action: manipulation;
        overflow: hidden;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }
      /* UI Boxes */
      #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
        background: rgba(0,0,0,0.7);
        border: 4px solid #fff;
        border-radius: 5px;
        color: #fff;
        font-size: 28px;
        padding: 40px 80px;
        position: absolute;
        z-index: 10;
      }
      #ui         { top: 10px;  left: 10px; }
      #ballCount  { top: 10px;  right: 10px; }
      #dialogue   { bottom: 10px; left: 10px; max-width: 600px; }
      #controls   { bottom: 10px; right: 10px; }
      #errorMessage {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: none;
        z-index: 20;
      }
      #guardPopup {
        bottom: 50%;
        left: 50%;
        transform: translate(-50%, 50%);
        display: none;
        z-index: 50;
        text-align: center;
      }
      /* Toggle UI button (top center) */
      #toggleUIBtn {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 11;
        font-size: 24px;
        padding: 10px 20px;
        background: #333;
        color: #fff;
        border: 2px solid #fff;
        border-radius: 5px;
        cursor: pointer;
      }
      /* SNES-Style On-Screen Controller */
      /* D-Pad container: moved higher (16vh) so not cut off on mobile */
      #dpadContainer {
        position: absolute;
        bottom: 16vh;
        left: 6vw;
        width: 120px;
        height: 120px;
        z-index: 15;
      }
      #dpadContainer button {
        position: absolute;
        width: 40px;
        height: 40px;
        background: rgba(255,255,255,0.3);
        border: 2px solid #fff;
        border-radius: 5px;
        font-size: 18px;
        color: #fff;
        cursor: pointer;
      }
      #btnUp    { top: 0;    left: 40px; }
      #btnDown  { bottom: 0; left: 40px; }
      #btnLeft  { left: 0;   top: 40px; }
      #btnRight { right: 0;  top: 40px; }
      /* Turn buttons container: bottom-right, moved higher */
      #turnContainer {
        position: absolute;
        bottom: 16vh;
        right: 12vw;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 15;
      }
      #turnContainer button {
        width: 60px;
        height: 60px;
        background: rgba(255,255,255,0.3);
        border: 2px solid #fff;
        border-radius: 50%;
        font-size: 16px;
        color: #fff;
        cursor: pointer;
      }
      /* Action buttons container: bottom-right, near turn buttons */
      #actionContainer {
        position: absolute;
        bottom: 16vh;
        right: 4vw;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 15;
      }
      #actionContainer button {
        width: 60px;
        height: 60px;
        background: rgba(255,255,255,0.3);
        border: 2px solid #fff;
        border-radius: 50%;
        font-size: 16px;
        color: #fff;
        cursor: pointer;
      }
      /* Scale down on narrower screens */
      @media (max-width: 768px) {
        #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
          font-size: 16px;
          padding: 20px 30px;
        }
        #toggleUIBtn { font-size: 16px; }
        #dpadContainer { width: 90px; height: 90px; }
        #dpadContainer button { width: 30px; height: 30px; font-size: 14px; }
        #turnContainer button, #actionContainer button {
          width: 50px; height: 50px; font-size: 14px;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <button id="toggleUIBtn">Toggle UI</button>
      <!-- UI Elements -->
      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>
      <div id="ballCount">
        Balls Thrown: <span id="ballCountValue">0</span>
      </div>
      <div id="dialogue"></div>
      <div id="controls">
        Controls:<br>
        D-Pad: Move<br>
        Turn: Rotate<br>
        A/B: Throw Ball / Big Ball<br>
        Arrow Keys + Space on Desktop
      </div>
      <div id="errorMessage">
        WebGL not supported in your browser. Please use a modern browser.
      </div>
      <div id="guardPopup"></div>

      <!-- SNES-Style Controller -->
      <div id="dpadContainer">
        <button id="btnUp">▲</button>
        <button id="btnDown">▼</button>
        <button id="btnLeft">◀</button>
        <button id="btnRight">▶</button>
      </div>
      <div id="turnContainer">
        <button id="btnTurnLeft">L</button>
        <button id="btnTurnRight">R</button>
      </div>
      <div id="actionContainer">
        <button id="btnThrow">A</button>
        <button id="btnBigThrow">B</button>
      </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Toggle UI functionality
      document.getElementById('toggleUIBtn').addEventListener('click', () => {
        const ids = ["ui", "ballCount", "dialogue", "controls", "guardPopup", "errorMessage"];
        ids.forEach(id => {
          const el = document.getElementById(id);
          el.style.display = (el.style.display === "none") ? "block" : "none";
        });
      });

      // Prevent highlighting on iOS
      function disableHighlight(id) {
        const btn = document.getElementById(id);
        ["touchstart", "mousedown"].forEach(evt => {
          btn.addEventListener(evt, e => e.preventDefault(), { passive: false });
        });
      }
      ["btnUp", "btnDown", "btnLeft", "btnRight", "btnTurnLeft", "btnTurnRight", "btnThrow", "btnBigThrow"].forEach(disableHighlight);

      // Controller state
      const controllerState = {
        dpadUp: false,
        dpadDown: false,
        dpadLeft: false,
        dpadRight: false,
        turnLeft: false,
        turnRight: false
      };
      function setButtonListener(btnId, stateProp) {
        const btn = document.getElementById(btnId);
        btn.addEventListener('mousedown', () => { controllerState[stateProp] = true; });
        btn.addEventListener('touchstart', () => { controllerState[stateProp] = true; }, { passive: false });
        btn.addEventListener('mouseup', () => { controllerState[stateProp] = false; });
        btn.addEventListener('touchend', () => { controllerState[stateProp] = false; });
        btn.addEventListener('mouseleave', () => { controllerState[stateProp] = false; });
      }
      setButtonListener('btnUp', 'dpadUp');
      setButtonListener('btnDown', 'dpadDown');
      setButtonListener('btnLeft', 'dpadLeft');
      setButtonListener('btnRight', 'dpadRight');
      setButtonListener('btnTurnLeft', 'turnLeft');
      setButtonListener('btnTurnRight', 'turnRight');

      // Global game variable (for action button access)
      let game = null;
      document.getElementById('btnThrow').addEventListener('mousedown', () => { game?.throwBall(); });
      document.getElementById('btnThrow').addEventListener('touchstart', () => { game?.throwBall(); }, { passive: false });
      document.getElementById('btnBigThrow').addEventListener('mousedown', () => { game?.throwBigBall(); });
      document.getElementById('btnBigThrow').addEventListener('touchstart', () => { game?.throwBigBall(); }, { passive: false });

      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');
        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          throw new Error('WebGL not supported');
        }
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameCanvas.style.display = 'block';

        class Game {
          constructor() {
            this.scene = scene;
            this.camera = camera;
            this.renderer = renderer;
            this.time = 'Day';
            this.dayNightCycle = 0;
            this.player = {
              x: 0,
              z: 0,
              speedKeyboard: 0.1,
              speedController: 0.08,
              yaw: 0,
              pitch: 0,
              object: null,
              waterSplashTimer: 0
            };
            this.flowers = 0;
            this.coins = 0;
            this.gems = 0;
            this.potions = 0;
            this.keys = 0;
            this.artifacts = 0;
            this.health = 100;
            this.dialogue = '';
            this.dialogueTimer = 0;
            this.objects = [];
            this.buildingPositions = [];
            this.ballCount = 0;
            this.thrownBalls = [];
            this.collectionGlow = null;
            this.keysPressed = {};
            this.itemRange = 80;
            // Day/Night objects
            this.sunMesh = null;
            this.moonMesh = null;
            this.starsMesh = null;
            // NPCs
            this.npcBlueData = { angle: 0, speed: 0.001, radius: 120, object: null };
            this.npcYellowData = { object: null, speed: 0.03, target: null };
            // Guard: idle for 2 min (7200 frames) then patrol
            this.guardData = {
              object: null,
              state: 'idle',
              timer: 0,
              route: [{ x: 30, z: 40 }, { x: 30, z: 50 }, { x: 50, z: 50 }, { x: 50, z: 40 }, { x: 40, z: 40 }],
              routeIndex: 0,
              speed: 0.03
            };
            this.mermaidData = { object: null, route: [{ x: -15, z: -70 }, { x: 15, z: -70 }], routeIndex: 0, speed: 0.02 };
            this.birdData = { angle: 0, speed: 0.002, radius: 140, object: null };

            // Interactions
            this.guardObject = null;
            this.guardMessageShown = false;
            this.npcBlueMessageShown = false;
            this.mermaidMessageShown = false;
            this.npcYellowMessageShown = false;

            this.initScene();
            this.initKeyboardMouse();
            this.startAnimation();
          }

          // NEW: Define getRandomBuildingTarget so yellow NPC can pick a target
          getRandomBuildingTarget() {
            if (this.buildingPositions.length === 0) return { x: 0, z: 0 };
            const index = Math.floor(Math.random() * this.buildingPositions.length);
            return this.buildingPositions[index];
          }

          initScene() {
            // Ground
            const groundGeo = new THREE.PlaneGeometry(300, 300);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x6bb26b, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = Math.PI / 2;
            this.scene.add(ground);

            // Rolling hills
            for (let i = 0; i < 100; i++) {
              const r = 80 + Math.random() * 60;
              const x = (Math.random() > 0.5 ? 1 : -1) * (300 + Math.random() * 500);
              const z = (Math.random() > 0.5 ? 1 : -1) * (300 + Math.random() * 500);
              const hillGeo = new THREE.SphereGeometry(r, 16, 16);
              const hillMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.9 });
              const hill = new THREE.Mesh(hillGeo, hillMat);
              hill.position.set(x, -r / 2, z);
              this.scene.add(hill);
            }

            // Boundary ±130
            for (let x = -130; x <= 130; x += 4) {
              this.addShrub(x, -130);
              this.addShrub(x, 130);
            }
            for (let z = -130; z <= 130; z += 4) {
              this.addShrub(-130, z);
              this.addShrub(130, z);
            }

            // Beach & water
            this.createBeach();

            // Lighting
            const ambient = new THREE.AmbientLight(0x404040, 0.6);
            this.scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            this.scene.add(dirLight);

            // Sun, Moon, Stars
            this.createSun();
            this.createMoon();
            this.createStars();

            // Player (Princess)
            this.createPlayerModel();

            // Buildings (castle, house, cafe, fountain)
            this.createCastle();
            this.createHouse();
            this.createCafe();
            this.createFountain();

            // Record building positions for NPC targets
            // (Assumes createCastle, createHouse, createCafe push to buildingPositions)
            // For example:
            this.buildingPositions.push({ x: 40, z: 40 });
            this.buildingPositions.push({ x: -40, z: -40 });
            this.buildingPositions.push({ x: 70, z: -30 });

            // NPCs
            this.createBlueNPC();
            this.createYellowNPC();
            this.createGuardAtCastle();
            this.createMermaid();
            this.createBird();

            // Items
            this.createFlowers(10);
            this.createCoins(8);
            this.createGems(4);
            this.createPotions(3);
            this.createKeys(2);
            this.createArtifacts(2);

            // Position camera behind the player (third-person)
            this.camera.position.set(this.player.x + 15, 15, this.player.z + 15);
            this.camera.lookAt(this.player.x, 1, this.player.z);
          }

          addShrub(x, z) {
            const geo = new THREE.CylinderGeometry(1, 1, 2, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const shrub = new THREE.Mesh(geo, mat);
            shrub.position.set(x, 1, z);
            this.scene.add(shrub);
            this.objects.push({ mesh: shrub, type: 'boundary', x, z, boundingRadius: 2 });
          }

          createBeach() {
            const beachGeo = new THREE.PlaneGeometry(300, 30);
            const beachMat = new THREE.MeshStandardMaterial({ color: 0xD2B48C, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: 1 });
            const beach = new THREE.Mesh(beachGeo, beachMat);
            beach.rotation.x = -Math.PI / 2;
            beach.position.set(0, 0.01, -40);
            this.scene.add(beach);
            this.objects.push({ mesh: beach, type: 'beach', x: 0, z: -40, boundingRadius: 0 });

            const waterGeo = new THREE.PlaneGeometry(300, 30);
            const waterMat = new THREE.MeshStandardMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.8, polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: 1 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.set(0, 0.02, -70);
            this.scene.add(water);
            this.objects.push({ mesh: water, type: 'water', x: 0, z: -70, boundingRadius: 0 });
          }

          createSun() {
            const sunGeo = new THREE.SphereGeometry(3, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffee00 });
            this.sunMesh = new THREE.Mesh(sunGeo, sunMat);
            this.sunMesh.position.set(0, 200, -200);
            this.sunMesh.visible = true;
            this.scene.add(this.sunMesh);
          }
          createMoon() {
            const moonGeo = new THREE.SphereGeometry(2, 16, 16);
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
            this.moonMesh = new THREE.Mesh(moonGeo, moonMat);
            this.moonMesh.position.set(-100, 150, 100);
            this.moonMesh.visible = false;
            this.scene.add(this.moonMesh);
          }
          createStars() {
            const starCount = 300;
            const positions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
              const radius = 300 + Math.random() * 200;
              const angle = Math.random() * Math.PI * 2;
              const ySpread = Math.random() * 200 - 50;
              positions[i * 3] = Math.cos(angle) * radius;
              positions[i * 3 + 1] = 50 + ySpread;
              positions[i * 3 + 2] = Math.sin(angle) * radius;
            }
            const starGeo = new THREE.BufferGeometry();
            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, depthTest: false });
            const starField = new THREE.Points(starGeo, starMat);
            starField.visible = false;
            this.scene.add(starField);
            this.starsMesh = starField;
          }

          createPlayerModel() {
            const group = new THREE.Group();
            // Body
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16), new THREE.MeshStandardMaterial({ color: 0xff69b4 }));
            body.position.set(0, 0.6, 0);
            body.userData = { isBodyPart: true };
            group.add(body);
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffddc1 }));
            head.position.set(0, 1.4, 0);
            head.userData = { isBodyPart: true };
            group.add(head);
            // Hair
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0x4b2e05 }));
            hair.position.set(0, 1.75, 0);
            group.add(hair);
            // Crown
            const crown = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.09, 8, 16), new THREE.MeshStandardMaterial({ color: 0xffd700 }));
            crown.rotation.x = Math.PI / 2;
            crown.position.set(0, 1.95, 0);
            group.add(crown);
            // Arms (with alternating phases)
            const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5, 1.0, 0);
            leftArm.userData = { isArm: true, side: 'left' };
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5, 1.0, 0);
            rightArm.userData = { isArm: true, side: 'right' };
            group.add(rightArm);
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 8);
            const leftLeg = new THREE.Mesh(legGeo, skinMat);
            leftLeg.position.set(-0.2, 0.2, 0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, skinMat);
            rightLeg.position.set(0.2, 0.2, 0);
            group.add(rightLeg);

            group.position.set(0, 0.5, 0);
            this.player.object = group;
            this.scene.add(group);
          }

          createCastle() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 20), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
            base.position.set(0, 5, 0);
            group.add(base);
            const towerGeo = new THREE.CylinderGeometry(3, 3, 15, 16);
            const towerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            [[10,7.5,10], [-10,7.5,10], [10,7.5,-10], [-10,7.5,-10]].forEach(pos => {
              const tower = new THREE.Mesh(towerGeo, towerMat);
              tower.position.set(pos[0], pos[1], pos[2]);
              group.add(tower);
            });
            const door = new THREE.Mesh(new THREE.PlaneGeometry(4, 6), new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide }));
            door.position.set(0, 3, 10.01);
            group.add(door);
            // "Daddy's Castle" sign
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 512, 128);
            ctx.fillStyle = 'white';
            ctx.font = '60px Arial';
            ctx.fillText("Daddy's Castle", 50, 80);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex });
            const signGeo = new THREE.PlaneGeometry(12, 3);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0, 8, 10.1);
            group.add(signMesh);

            group.position.set(40, 0, 40);
            this.scene.add(group);
            this.objects.push({ mesh: group, type: 'building', x: 40, z: 40, boundingRadius: 15 });
            this.buildingPositions.push({ x: 40, z: 40 });
          }

          createHouse() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(12, 8, 10), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
            base.position.set(0, 4, 0);
            group.add(base);
            const roof = new THREE.Mesh(new THREE.ConeGeometry(6, 4, 4), new THREE.MeshStandardMaterial({ color: 0x800000 }));
            roof.position.set(0, 8, 0);
            roof.rotation.y = Math.PI / 4;
            group.add(roof);
            const door = new THREE.Mesh(new THREE.PlaneGeometry(2, 4), new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide }));
            door.position.set(0, 2, 5.01);
            group.add(door);
            // House sign
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 128, 32);
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText("Donia's House", 5, 22);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
            const signGeo = new THREE.PlaneGeometry(4, 1);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0, 5, 4.05);
            group.add(signMesh);

            group.position.set(-40, 0, -40);
            this.scene.add(group);
            this.objects.push({ mesh: group, type: 'building', x: -40, z: -40, boundingRadius: 10 });
            this.buildingPositions.push({ x: -40, z: -40 });
          }

          createCafe() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(12, 7, 10), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            base.position.set(0, 3.5, 0);
            group.add(base);
            const door = new THREE.Mesh(new THREE.PlaneGeometry(2, 3), new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide }));
            door.position.set(0, 1.5, 5.01);
            group.add(door);
            // Cafe sign
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("Donia's Cafe", 128, 40);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
            const signGeo = new THREE.PlaneGeometry(8, 2);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0, 3.5, 4.05);
            group.add(signMesh);

            group.position.set(70, 0, -30);
            this.scene.add(group);
            this.objects.push({ mesh: group, type: 'building', x: 70, z: -30, boundingRadius: 10 });
            this.buildingPositions.push({ x: 70, z: -30 });
          }

          createFountain() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 1, 16), new THREE.MeshStandardMaterial({ color: 0x808080 }));
            base.position.set(0, 0.5, 0);
            group.add(base);
            const bowl = new THREE.Mesh(new THREE.TorusGeometry(3, 0.3, 16, 32), new THREE.MeshStandardMaterial({ color: 0x808080 }));
            bowl.rotation.x = Math.PI / 2;
            bowl.position.y = 1;
            group.add(bowl);
            const water = new THREE.Mesh(new THREE.CylinderGeometry(2.8, 2.8, 0.2, 16), new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 }));
            water.position.set(0, 1.1, 0);
            group.add(water);
            group.position.set(0, 0, 20);
            this.scene.add(group);
            this.objects.push({ mesh: group, type: 'decoration', x: 0, z: 20, boundingRadius: 5 });
          }

          createBlueNPC() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16), new THREE.MeshStandardMaterial({ color: 0x0000ff }));
            body.position.set(0, 0.6, 0);
            group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffddc1 }));
            head.position.set(0, 1.4, 0);
            group.add(head);
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0x4b2e05 }));
            hair.position.set(0, 1.75, 0);
            group.add(hair);
            // Arms with alternating animation
            const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5, 1.0, 0);
            leftArm.userData = { isArm: true, side: 'left' };
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5, 1.0, 0);
            rightArm.userData = { isArm: true, side: 'right' };
            group.add(rightArm);
            group.position.set(120, 0.5, 0);
            this.scene.add(group);
            this.objects.push({ mesh: group, type: 'npc', x: 120, z: 0, boundingRadius: 1 });
            this.npcBlueData.object = group;
          }

          createYellowNPC() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.0, 16), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
            body.position.set(0, 0.5, 0);
            group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffddc1 }));
            head.position.set(0, 1.1, 0);
            group.add(head);
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0x4b2e05 }));
            hair.position.set(0, 1.55, 0);
            group.add(hair);
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5, 0.8, 0);
            leftArm.userData = { isArm: true, side: 'left' };
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5, 0.8, 0);
            rightArm.userData = { isArm: true, side: 'right' };
            group.add(rightArm);
            group.position.set(-30, 0.3, 30);
            this.scene.add(group);
            this.objects.push({ mesh: group, type: 'npc', x: -30, z: 30, boundingRadius: 1 });
            this.npcYellowData.object = group;
          }

          createGuardAtCastle() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            body.position.set(0, 0.6, 0);
            group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffddc1 }));
            head.position.set(0, 1.4, 0);
            group.add(head);
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0x4b2e05 }));
            hair.position.set(0, 1.75, 0);
            group.add(hair);
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5, 1.0, 0);
            leftArm.userData = { isArm: true, side: 'left' };
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5, 1.0, 0);
            rightArm.userData = { isArm: true, side: 'right' };
            group.add(rightArm);
            group.position.set(45, 0.5, 50.5);
            this.scene.add(group);
            this.objects.push({ mesh: group, type: 'guard', x: 45, z: 50.5, boundingRadius: 3 });
            this.guardData.object = group;
            this.guardObject = group;
          }

          createMermaid() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 0.6, 16), new THREE.MeshStandardMaterial({ color: 0xff69b4 }));
            body.position.set(0, 0.9, 0);
            group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffddc1 }));
            head.position.set(0, 1.4, 0);
            group.add(head);
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0x4b2e05 }));
            hair.position.set(0, 1.8, 0);
            group.add(hair);
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5, 1.1, 0);
            leftArm.userData = { isArm: true, side: 'left' };
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5, 1.1, 0);
            rightArm.userData = { isArm: true, side: 'right' };
            group.add(rightArm);
            group.position.set(20, -0.5, -70);
            this.scene.add(group);
            this.objects.push({ mesh: group, type: 'mermaid', x: 20, z: -70, boundingRadius: 3 });
            this.mermaidData.object = group;
          }

          createBird() {
            const bird = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            bird.position.set(0, 60, 0);
            this.scene.add(bird);
            this.birdData.object = bird;
          }

          // For brevity, the following item-creation methods are similar to previous versions.
          createFlowers(count) { /* ... implement as needed ... */ }
          createCoins(count) { /* ... implement as needed ... */ }
          createGems(count) { /* ... implement as needed ... */ }
          createPotions(count) { /* ... implement as needed ... */ }
          createKeys(count) { /* ... implement as needed ... */ }
          createArtifacts(count) { /* ... implement as needed ... */ }

          startAnimation() {
            const animate = () => {
              requestAnimationFrame(animate);
              this.update();
              this.renderer.render(this.scene, this.camera);
            };
            animate();
          }

          update() {
            this.updateDayNight();
            this.updateBalls();
            this.updateGuard();
            this.updateMovement();
            this.updateBlueNPC();
            this.updateYellowNPC();
            this.updateMermaid();
            this.updateBird();
            this.updateCollisions();
            this.updateCamera();
            this.updatePickups();
            this.processController();
          }

          updateDayNight() {
            this.dayNightCycle = (this.dayNightCycle + 1) % 1200;
            this.time = (this.dayNightCycle < 600) ? 'Day' : 'Night';
            document.getElementById('time').textContent = this.time;
            if (this.sunMesh && this.moonMesh && this.starsMesh) {
              if (this.time === 'Day') {
                this.sunMesh.visible = true;
                this.moonMesh.visible = false;
                this.starsMesh.visible = false;
              } else {
                this.sunMesh.visible = false;
                this.moonMesh.visible = true;
                this.starsMesh.visible = true;
              }
            }
          }

          updateBalls() {
            for (let i = this.thrownBalls.length - 1; i >= 0; i--) {
              const ball = this.thrownBalls[i];
              ball.position.add(ball.userData.velocity);
              ball.userData.velocity.y -= 0.01;
              // Bounce off buildings/decorations
              for (const obj of this.objects) {
                if (obj.type === 'building' || obj.type === 'decoration') {
                  const dxB = ball.position.x - obj.x;
                  const dzB = ball.position.z - obj.z;
                  const distSq = dxB * dxB + dzB * dzB;
                  const r = (obj.boundingRadius || 5);
                  if (distSq < r * r && ball.position.y < 10) {
                    const normal = new THREE.Vector3(dxB, 0, dzB).normalize();
                    const v = ball.userData.velocity.clone();
                    const dot = v.dot(normal);
                    const reflection = v.sub(normal.multiplyScalar(2 * dot)).multiplyScalar(0.6);
                    ball.userData.velocity.copy(reflection);
                  }
                }
              }
              if (ball.position.y < 0) {
                if (!ball.userData.bounced) {
                  ball.position.y = 0;
                  ball.userData.velocity.y *= -0.7;
                  ball.userData.bounced = true;
                } else if (ball.position.y < -0.5) {
                  this.scene.remove(ball);
                  this.thrownBalls.splice(i, 1);
                }
              }
            }
          }

          updateGuard() {
            // Guard: 2 min idle (~7200 frames) then patrol route, then idle again.
            if (!this.guardData.object) return;
            this.guardData.timer++;
            if (this.guardData.state === 'idle') {
              if (this.guardData.timer > 7200) {
                this.guardData.state = 'patrol';
                this.guardData.timer = 0;
                this.guardData.routeIndex = 0;
              }
            } else if (this.guardData.state === 'patrol') {
              const route = this.guardData.route;
              const guard = this.guardData.object;
              const target = route[this.guardData.routeIndex];
              const dx = target.x - guard.position.x;
              const dz = target.z - guard.position.z;
              const distSq = dx * dx + dz * dz;
              if (distSq < 1) {
                this.guardData.routeIndex++;
                if (this.guardData.routeIndex >= route.length) {
                  this.guardData.state = 'idle';
                  this.guardData.timer = 0;
                }
              } else {
                this.animateArms(guard, true);
                const angle = Math.atan2(dx, dz);
                guard.rotation.y = angle;
                const step = this.guardData.speed;
                const newX = guard.position.x + Math.sin(angle) * step;
                const newZ = guard.position.z + Math.cos(angle) * step;
                guard.position.set(newX, 0.5, newZ);
                for (const obj of this.objects) {
                  if (obj.mesh === guard) { obj.x = newX; obj.z = newZ; break; }
                }
              }
            }
          }

          updateMovement() {
            let moveForward = 0, moveStrafe = 0;
            if (this.keysPressed['ArrowUp']) moveForward += 1;
            if (this.keysPressed['ArrowDown']) moveForward -= 1;
            if (this.keysPressed['ArrowLeft']) moveStrafe -= 1;
            if (this.keysPressed['ArrowRight']) moveStrafe += 1;
            if (controllerState.dpadUp) moveForward += 1;
            if (controllerState.dpadDown) moveForward -= 1;
            if (controllerState.dpadLeft) moveStrafe -= 1;
            if (controllerState.dpadRight) moveStrafe += 1;
            if (moveForward !== 0 || moveStrafe !== 0) {
              const speed = (this.keysPressed['ArrowUp'] || this.keysPressed['ArrowDown']) ? this.player.speedKeyboard : this.player.speedController;
              // With yaw=0 meaning facing up (negative z)
              const forwardX = -Math.sin(this.player.yaw);
              const forwardZ = -Math.cos(this.player.yaw);
              const rightX = Math.cos(this.player.yaw);
              const rightZ = -Math.sin(this.player.yaw);
              const dx = (forwardX * moveForward + rightX * moveStrafe) * speed;
              const dz = (forwardZ * moveForward + rightZ * moveStrafe) * speed;
              const newX = this.player.x + dx;
              const newZ = this.player.z + dz;
              let blocked = false;
              for (const obj of this.objects) {
                if (obj.type === 'building' || obj.type === 'boundary' || obj.type === 'decoration' || obj.type === 'npc') {
                  const dxObj = newX - obj.x;
                  const dzObj = newZ - obj.z;
                  const distSq = dxObj * dxObj + dzObj * dzObj;
                  const r = (obj.boundingRadius || 5);
                  if (distSq < r * r) { blocked = true; break; }
                }
              }
              if (!blocked) {
                this.player.x = newX;
                this.player.z = newZ;
              }
              if (this.player.object) {
                this.player.object.position.set(this.player.x, 0.5, this.player.z);
              }
              this.animateArms(this.player.object, true);
            } else {
              this.animateArms(this.player.object, false);
            }
            // Process on-screen turn buttons (handled in processController)
          }

          animateArms(obj, isMoving) {
            if (!obj) return;
            const t = Date.now() * 0.01;
            obj.traverse(child => {
              if (child.userData && child.userData.isArm) {
                if (isMoving) {
                  if (child.userData.side === 'left') {
                    child.rotation.x = Math.sin(t) * 0.5;
                  } else {
                    child.rotation.x = -Math.sin(t) * 0.5;
                  }
                } else {
                  child.rotation.x = 0;
                }
              }
            });
          }

          updateBlueNPC() {
            this.npcBlueData.angle += this.npcBlueData.speed;
            const x = this.npcBlueData.radius * Math.cos(this.npcBlueData.angle);
            const z = this.npcBlueData.radius * Math.sin(this.npcBlueData.angle);
            if (this.npcBlueData.object) {
              this.animateArms(this.npcBlueData.object, true);
              this.npcBlueData.object.position.set(x, 0.5, z);
              this.npcBlueData.object.rotation.y = -this.npcBlueData.angle;
              for (const obj of this.objects) {
                if (obj.mesh === this.npcBlueData.object) { obj.x = x; obj.z = z; break; }
              }
            }
          }

          updateYellowNPC() {
            if (!this.npcYellowData.object) return;
            const npc = this.npcYellowData.object;
            if (!this.npcYellowData.target) {
              this.npcYellowData.target = this.getRandomBuildingTarget();
            }
            const dx = this.npcYellowData.target.x - npc.position.x;
            const dz = this.npcYellowData.target.z - npc.position.z;
            const distSq = dx * dx + dz * dz;
            if (distSq < 1) {
              this.npcYellowData.target = this.getRandomBuildingTarget();
            } else {
              this.animateArms(npc, true);
              const angle = Math.atan2(dx, dz);
              npc.rotation.y = angle;
              const step = this.npcYellowData.speed;
              const newX = npc.position.x + Math.sin(angle) * step;
              const newZ = npc.position.z + Math.cos(angle) * step;
              if (Math.abs(newX) < 125 && Math.abs(newZ) < 125) {
                npc.position.x = newX;
                npc.position.z = newZ;
              }
            }
            for (const obj of this.objects) {
              if (obj.mesh === this.npcYellowData.object) { obj.x = npc.position.x; obj.z = npc.position.z; break; }
            }
          }

          updateMermaid() {
            if (!this.mermaidData.object) return;
            const mer = this.mermaidData;
            const pt = mer.route[mer.routeIndex];
            const dx = pt.x - mer.object.position.x;
            const dz = pt.z - mer.object.position.z;
            const distSq = dx * dx + dz * dz;
            if (distSq < 1) {
              mer.routeIndex = (mer.routeIndex + 1) % mer.route.length;
            } else {
              this.animateArms(mer.object, true);
              const angle = Math.atan2(dx, dz);
              mer.object.rotation.y = angle;
              const step = mer.speed;
              const newX = mer.object.position.x + Math.sin(angle) * step;
              const newZ = mer.object.position.z + Math.cos(angle) * step;
              mer.object.position.set(newX, 0.5, newZ);
              for (const obj of this.objects) {
                if (obj.mesh === mer.object) { obj.x = newX; obj.z = newZ; break; }
              }
            }
          }

          updateBird() {
            this.birdData.angle += this.birdData.speed;
            const bx = this.birdData.radius * Math.cos(this.birdData.angle);
            const bz = this.birdData.radius * Math.sin(this.birdData.angle);
            if (this.birdData.object) {
              this.birdData.object.position.set(bx, 60, bz);
              this.birdData.object.rotation.y = -this.birdData.angle;
            }
          }

          updateCollisions() {
            if (this.guardObject && !this.guardMessageShown) {
              const dxG = this.player.x - this.guardObject.position.x;
              const dzG = this.player.z - this.guardObject.position.z;
              const distG = Math.sqrt(dxG * dxG + dzG * dzG);
              if (distG < 5) {
                this.showGuardPopup("I'm the guard of this castle. Please show your ID.");
              }
            }
            if (this.npcBlueData.object && !this.npcBlueMessageShown) {
              const dxN = this.player.x - this.npcBlueData.object.position.x;
              const dzN = this.player.z - this.npcBlueData.object.position.z;
              const distN = Math.sqrt(dxN * dxN + dzN * dzN);
              if (distN < 5) {
                this.showGuardPopup("Hello Princess Donia!");
                this.npcBlueMessageShown = true;
                setTimeout(() => { this.npcBlueMessageShown = false; }, 2500);
              }
            }
            if (!this.mermaidMessageShown) {
              const mermaidObj = this.objects.find(o => o.type === 'mermaid');
              if (mermaidObj) {
                const dxM = this.player.x - mermaidObj.x;
                const dzM = this.player.z - mermaidObj.z;
                const distM = Math.sqrt(dxM * dxM + dzM * dzM);
                if (distM < 5) {
                  this.showGuardPopup("Hello Princess Donia. It's me the Mermaid.");
                  this.mermaidMessageShown = true;
                  setTimeout(() => { this.mermaidMessageShown = false; }, 2500);
                }
              }
            }
          }

          updateCamera() {
            const camDist = 15;
            const offsetX = Math.sin(this.player.yaw) * (-camDist);
            const offsetZ = Math.cos(this.player.yaw) * (-camDist);
            const offsetY = 15;
            this.camera.position.set(this.player.x + offsetX, offsetY, this.player.z + offsetZ);
            this.camera.lookAt(this.player.x, 0.5, this.player.z);
          }

          updatePickups() {
            for (const obj of this.objects) {
              if (obj.isPickup) {
                const dxObj = this.player.x - obj.x;
                const dzObj = this.player.z - obj.z;
                const distSq = dxObj * dxObj + dzObj * dzObj;
                if (distSq < 4) {
                  switch (obj.type) {
                    case 'flower':
                      this.flowers++;
                      document.getElementById('flowers').textContent = this.flowers;
                      this.showDialogue('You picked a radiant flower!');
                      break;
                    case 'coin':
                      this.coins++;
                      document.getElementById('coins').textContent = this.coins;
                      this.showDialogue('You picked up a shiny coin!');
                      break;
                    case 'gem':
                      this.gems++;
                      document.getElementById('gems').textContent = this.gems;
                      this.showDialogue('A dazzling gem is yours!');
                      break;
                    case 'potion':
                      this.potions++;
                      document.getElementById('potions').textContent = this.potions;
                      this.showDialogue('You found a potion!');
                      break;
                    case 'key':
                      this.keys++;
                      document.getElementById('keys').textContent = this.keys;
                      this.showDialogue('A golden key is yours!');
                      break;
                    case 'artifact':
                      this.artifacts++;
                      document.getElementById('artifacts').textContent = this.artifacts;
                      this.showDialogue('You discovered a mystical artifact!');
                      break;
                  }
                  this.scene.remove(obj.mesh);
                  this.objects = this.objects.filter(o => o !== obj);
                  this.startCollectionGlow();
                }
              }
            }
          }

          showDialogue(text) {
            document.getElementById('dialogue').textContent = text;
          }
          showGuardPopup(text) {
            const popup = document.getElementById('guardPopup');
            popup.style.display = 'block';
            popup.textContent = text;
            setTimeout(() => {
              popup.style.display = 'none';
              popup.textContent = '';
            }, 2000);
          }

          throwBall() {
            if (!this.player.object) return;
            const direction = new THREE.Vector3(-Math.sin(this.player.yaw), 0, -Math.cos(this.player.yaw));
            const ballGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4500 });
            const ball = new THREE.Mesh(ballGeo, ballMat);
            ball.position.set(this.player.x, 0.5, this.player.z);
            ball.position.y += 1;
            ball.userData = { velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0, 0.3, 0)), bounced: false };
            this.scene.add(ball);
            this.thrownBalls.push(ball);
            this.ballCount++;
            document.getElementById('ballCountValue').textContent = this.ballCount;
            this.showDialogue("Threw a magic ball!");
          }

          throwBigBall() {
            if (!this.player.object) return;
            const direction = new THREE.Vector3(-Math.sin(this.player.yaw), 0, -Math.cos(this.player.yaw));
            const ballGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            const ball = new THREE.Mesh(ballGeo, ballMat);
            ball.position.set(this.player.x, 0.5, this.player.z);
            ball.position.y += 1;
            ball.userData = { velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0, 0.3, 0)), bounced: false };
            this.scene.add(ball);
            this.thrownBalls.push(ball);
            this.ballCount++;
            document.getElementById('ballCountValue').textContent = this.ballCount;
            this.showDialogue("Threw a BIG magic ball!");
          }

          startCollectionGlow() {
            if (this.collectionGlow) this.scene.remove(this.collectionGlow);
            const glowGeo = new THREE.SphereGeometry(1, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5, side: THREE.BackSide });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.set(this.player.x, 1, this.player.z);
            this.scene.add(glow);
            this.collectionGlow = glow;
            setTimeout(() => {
              if (this.collectionGlow) {
                this.scene.remove(this.collectionGlow);
                this.collectionGlow = null;
              }
            }, 1000);
          }

          processController() {
            // Process D-Pad input for movement
            let moveForward = 0, moveStrafe = 0;
            if (controllerState.dpadUp) moveForward += 1;
            if (controllerState.dpadDown) moveForward -= 1;
            if (controllerState.dpadLeft) moveStrafe -= 1;
            if (controllerState.dpadRight) moveStrafe += 1;
            if (moveForward !== 0 || moveStrafe !== 0) {
              const forwardX = -Math.sin(this.player.yaw);
              const forwardZ = -Math.cos(this.player.yaw);
              const rightX = Math.cos(this.player.yaw);
              const rightZ = -Math.sin(this.player.yaw);
              const dx = (forwardX * moveForward + rightX * moveStrafe) * this.player.speedController;
              const dz = (forwardZ * moveForward + rightZ * moveStrafe) * this.player.speedController;
              const newX = this.player.x + dx;
              const newZ = this.player.z + dz;
              let blocked = false;
              for (const obj of this.objects) {
                if (obj.type === 'building' || obj.type === 'boundary' || obj.type === 'decoration' || obj.type === 'npc') {
                  const dxObj = newX - obj.x;
                  const dzObj = newZ - obj.z;
                  const distSq = dxObj * dxObj + dzObj * dzObj;
                  const r = (obj.boundingRadius || 5);
                  if (distSq < r * r) { blocked = true; break; }
                }
              }
              if (!blocked) {
                this.player.x = newX;
                this.player.z = newZ;
              }
              if (this.player.object) {
                this.player.object.position.set(this.player.x, 0.5, this.player.z);
              }
              this.animateArms(this.player.object, true);
            } else {
              this.animateArms(this.player.object, false);
            }
            // Process Turn buttons
            if (controllerState.turnLeft) this.player.yaw += 0.02;
            if (controllerState.turnRight) this.player.yaw -= 0.02;
          }

          initKeyboardMouse() {
            document.addEventListener('keydown', e => {
              this.keysPressed[e.key] = true;
              if (e.key === ' ') this.throwBall();
            });
            document.addEventListener('keyup', e => {
              this.keysPressed[e.key] = false;
            });
            document.addEventListener('mousedown', () => {
              try { document.body.requestPointerLock(); }
              catch (err) { console.warn('Pointer lock request failed:', err); }
            });
            document.addEventListener('mousemove', evt => {
              if (document.pointerLockElement === document.body) {
                const movementX = evt.movementX || 0;
                const sensitivity = 0.001;
                this.player.yaw += movementX * sensitivity;
              }
            });
          }

          startAnimation() {
            const animate = () => {
              requestAnimationFrame(animate);
              this.update();
              this.renderer.render(this.scene, this.camera);
            };
            animate();
          }

          update() {
            this.updateDayNight();
            this.updateBalls();
            this.updateGuard();
            this.updateMovement();
            this.updateBlueNPC();
            this.updateYellowNPC();
            this.updateMermaid();
            this.updateBird();
            this.updateCollisions();
            this.updateCamera();
            this.updatePickups();
            this.processController();
          }
        }

        // Create the global game instance
        window.game = new Game();
      } catch (err) {
        console.error('Error initializing the game:', err);
      }
    </script>
  </body>
</html>
