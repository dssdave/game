<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Prevent iPhone from zooming, etc. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Princess Donia’s Town - Full Environment + 3rd Person</title>
  <style>
    /* Basic resets */
    html, body {
      margin: 0; 
      padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      -webkit-user-select: none;  /* iOS no text selection */
      -webkit-touch-callout: none;
      user-select: none;
      touch-action: manipulation;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; }

    /* UI boxes */
    #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
      background: rgba(0,0,0,0.7);
      border: 4px solid #fff;
      border-radius: 5px;
      color: #fff;
      font-size: 28px;
      padding: 40px 80px;
      position: absolute;
      z-index: 10;
    }
    #ui         { top: 10px;  left: 10px; }
    #ballCount  { top: 10px;  right: 10px; }
    #dialogue   { bottom: 10px; left: 10px; max-width: 600px; }
    #controls   { bottom: 10px; right: 10px; }
    #errorMessage {
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 20;
    }
    #guardPopup {
      bottom: 50%; left: 50%;
      transform: translate(-50%, 50%);
      display: none;
      z-index: 50;
      text-align: center;
    }

    /* Toggle UI button (top center) */
    #toggleUIBtn {
      position: absolute;
      top: 10px; 
      left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      font-size: 24px;
      padding: 10px 20px;
      background: #333;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 5px;
      cursor: pointer;
    }

    /* SNES-Style On-Screen Controller */
    /* D-Pad container: bigger + spaced out so not squished */
    #dpadContainer {
      position: absolute;
      bottom: 16vh;   /* higher up so not cut off */
      left: 12vw;     /* more toward center */
      width: 160px;
      height: 160px;
      z-index: 15;
    }
    #dpadContainer button {
      position: absolute;
      width: 50px; height: 50px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
    }
    /* Place Up/Down/Left/Right with spacing */
    #btnUp    { top: 10px;    left: 55px; }
    #btnDown  { bottom: 10px; left: 55px; }
    #btnLeft  { left: 10px;   top: 55px; }
    #btnRight { right: 10px;  top: 55px; }

    /* Turn buttons: bottom-right, spaced out */
    #turnContainer {
      position: absolute;
      bottom: 16vh;
      right: 10vw;
      display: flex;
      flex-direction: column;
      gap: 20px;
      z-index: 15;
    }
    #turnContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px;
      color: #fff;
      cursor: pointer;
    }

    /* Action buttons: also spaced out */
    #actionContainer {
      position: absolute;
      bottom: 16vh;
      right: 3vw;
      display: flex;
      flex-direction: column;
      gap: 20px;
      z-index: 15;
    }
    #actionContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px;
      color: #fff;
      cursor: pointer;
    }

    /* Scale down on narrower screens */
    @media (max-width: 768px) {
      #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
        font-size: 16px;
        padding: 20px 30px;
      }
      #toggleUIBtn { font-size: 16px; }
      #dpadContainer {
        width: 120px; height: 120px;
      }
      #dpadContainer button {
        width: 40px; height: 40px; font-size: 14px;
      }
      #turnContainer button, #actionContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>

    <!-- UI Elements -->
    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifacts: <span id="artifacts">0</span> |
      Health: <span id="health">100</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">
      Balls Thrown: <span id="ballCountValue">0</span>
    </div>
    <div id="dialogue"></div>
    <div id="controls">
      Controls:<br>
      Up/Down: Forward/Back<br>
      Left/Right: Turn Character<br>
      A/B: Throw Ball / Big Ball<br>
      Arrow Keys + Space on Desktop
    </div>
    <div id="errorMessage">
      WebGL not supported in your browser. Please use a modern browser.
    </div>
    <div id="guardPopup"></div>

    <!-- SNES-Style On-Screen Controller -->
    <div id="dpadContainer">
      <button id="btnUp">▲</button>
      <button id="btnDown">▼</button>
      <button id="btnLeft">◀</button>
      <button id="btnRight">▶</button>
    </div>
    <div id="turnContainer">
      <button id="btnTurnLeft">L</button>
      <button id="btnTurnRight">R</button>
    </div>
    <div id="actionContainer">
      <button id="btnThrow">A</button>
      <button id="btnBigThrow">B</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Toggle UI button
    document.getElementById('toggleUIBtn').addEventListener('click', () => {
      for(const id of ["ui","ballCount","dialogue","controls","guardPopup","errorMessage"]){
        const el = document.getElementById(id);
        el.style.display = (el.style.display==="none") ? "block" : "none";
      }
    });

    // Prevent highlight/focus on iOS
    function disableHighlight(id){
      const btn = document.getElementById(id);
      ["touchstart","mousedown"].forEach(evt=>{
        btn.addEventListener(evt, e=> e.preventDefault(), {passive:false});
      });
    }
    ["btnUp","btnDown","btnLeft","btnRight","btnTurnLeft","btnTurnRight","btnThrow","btnBigThrow"].forEach(disableHighlight);

    // On-screen controller state
    const controllerState = {
      dpadUp:false, dpadDown:false,
      dpadLeft:false, dpadRight:false,
      turnLeft:false, turnRight:false
    };
    function setButtonListener(btnId, stateProp){
      const btn = document.getElementById(btnId);
      btn.addEventListener('mousedown',   ()=>{ controllerState[stateProp]=true; });
      btn.addEventListener('touchstart', ()=>{ controllerState[stateProp]=true; }, {passive:false});
      btn.addEventListener('mouseup',    ()=>{ controllerState[stateProp]=false; });
      btn.addEventListener('touchend',   ()=>{ controllerState[stateProp]=false; });
      btn.addEventListener('mouseleave', ()=>{ controllerState[stateProp]=false; });
    }
    setButtonListener('btnUp','dpadUp');
    setButtonListener('btnDown','dpadDown');
    setButtonListener('btnLeft','dpadLeft');
    setButtonListener('btnRight','dpadRight');
    setButtonListener('btnTurnLeft','turnLeft');
    setButtonListener('btnTurnRight','turnRight');

    // Ball buttons: add "click" for desktop + mobile
    let game = null; // global reference
    document.getElementById('btnThrow').addEventListener('click', ()=>{ game?.throwBall(); });
    document.getElementById('btnBigThrow').addEventListener('click', ()=>{ game?.throwBigBall(); });

    try {
      const errorMessage = document.getElementById('errorMessage');
      const gameCanvas  = document.getElementById('gameCanvas');
      if(!window.WebGLRenderingContext){
        errorMessage.style.display = 'block';
        gameCanvas.style.display   = 'none';
        throw new Error('WebGL not supported');
      }

      const scene    = new THREE.Scene();
      const camera   = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
      const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type    = THREE.PCFSoftShadowMap;
      gameCanvas.style.display   = 'block';

      class Game {
        constructor(){
          this.scene = scene;
          this.camera = camera;
          this.renderer = renderer;

          this.time='Day';
          this.dayNightCycle=0;

          // Player faces yaw=0 => +Z direction
          this.player={
            x:0, z:0,
            speedKeyboard:0.1,
            speedController:0.08,
            yaw:0, pitch:0,
            object:null
          };

          // Stats
          this.flowers=0; this.coins=0; this.gems=0; this.potions=0; this.keys=0; this.artifacts=0;
          this.health=100;
          this.dialogue='';
          this.dialogueTimer=0;
          this.objects=[];
          this.buildingPositions=[];
          this.ballCount=0;
          this.thrownBalls=[];
          this.collectionGlow=null;
          this.keysPressed={};
          this.itemRange=80;

          // Day/Night objects
          this.sunMesh=null; 
          this.moonMesh=null; 
          this.starsMesh=null;

          // NPCs
          this.npcBlueData={ angle:0, speed:0.001, radius:120, object:null };
          this.npcYellowData={ object:null, speed:0.03, target:null };
          // Guard: idle for ~2 min => patrol => repeat
          this.guardData={
            object:null,
            state:'idle',
            timer:0,
            route:[{ x:30,z:40 },{ x:30,z:50 },{ x:50,z:50 },{ x:50,z:40 },{ x:40,z:40 }],
            routeIndex:0,
            speed:0.02
          };
          this.mermaidData={ object:null, route:[{ x:-15,z:-70 },{ x:15,z:-70 }], routeIndex:0, speed:0.02 };
          this.birdData={ angle:0, speed:0.002, radius:140, object:null };

          // Interactions
          this.guardObject=null;
          this.guardMessageShown=false;
          this.npcBlueMessageShown=false;
          this.mermaidMessageShown=false;
          this.npcYellowMessageShown=false;

          this.initScene();
          this.initKeyboardMouse();
          this.startAnimation();
        }

        initScene(){
          // 1) Ground
          const groundGeo=new THREE.PlaneGeometry(300,300);
          const groundMat=new THREE.MeshStandardMaterial({ color:0x6bb26b, side:THREE.DoubleSide });
          const ground=new THREE.Mesh(groundGeo,groundMat);
          ground.rotation.x=Math.PI/2;
          this.scene.add(ground);

          // 2) Rolling hills
          for(let i=0;i<100;i++){
            const r=80+Math.random()*60;
            const x=(Math.random()>0.5?1:-1)*(300+Math.random()*500);
            const z=(Math.random()>0.5?1:-1)*(300+Math.random()*500);
            const hillGeo=new THREE.SphereGeometry(r,16,16);
            const hillMat=new THREE.MeshStandardMaterial({ color:0x228b22, roughness:0.9 });
            const hill=new THREE.Mesh(hillGeo,hillMat);
            hill.position.set(x,-r/2,z);
            this.scene.add(hill);
          }

          // 3) Boundary ±130
          for(let x=-130;x<=130;x+=4){
            this.addShrub(x,-130);
            this.addShrub(x,130);
          }
          for(let z=-130;z<=130;z+=4){
            this.addShrub(-130,z);
            this.addShrub(130,z);
          }

          // 4) Beach & water
          this.createBeach();

          // 5) Lighting
          const ambient=new THREE.AmbientLight(0x404040,0.6);
          this.scene.add(ambient);
          const dirLight=new THREE.DirectionalLight(0xffffff,0.8);
          dirLight.position.set(10,20,10);
          this.scene.add(dirLight);

          // 6) Sun, Moon, Stars
          this.createSun();
          this.createMoon();
          this.createStars();

          // 7) Player
          this.createPlayerModel();

          // 8) Buildings
          this.createCastle();
          this.createHouse();
          this.createCafe();
          this.createFountain();
          // store building positions for NPC
          this.buildingPositions.push({ x:40, z:40 });
          this.buildingPositions.push({ x:-40, z:-40 });
          this.buildingPositions.push({ x:70, z:-30 });

          // 9) NPCs
          this.createBlueNPC();
          this.createYellowNPC();
          this.createGuardAtCastle();
          this.createMermaid();
          this.createBird();

          // 10) Items
          this.createFlowers(10);
          this.createCoins(8);
          this.createGems(4);
          this.createPotions(3);
          this.createKeys(2);
          this.createArtifacts(2);

          // 3rd-person camera behind the player
          this.camera.position.set(this.player.x+15,15,this.player.z+15);
          this.camera.lookAt(this.player.x,1,this.player.z);
        }

        /* Helper to add boundary shrubs */
        addShrub(x,z){
          const geo=new THREE.CylinderGeometry(1,1,2,8);
          const mat=new THREE.MeshStandardMaterial({ color:0x228b22 });
          const shrub=new THREE.Mesh(geo,mat);
          shrub.position.set(x,1,z);
          this.scene.add(shrub);
          this.objects.push({ mesh:shrub, type:'boundary', x, z, boundingRadius:2 });
        }

        /* Beach + Water */
        createBeach(){
          const beachGeo=new THREE.PlaneGeometry(300,30);
          const beachMat=new THREE.MeshStandardMaterial({ color:0xD2B48C, polygonOffset:true, polygonOffsetFactor:-1, polygonOffsetUnits:1 });
          const beach=new THREE.Mesh(beachGeo,beachMat);
          beach.rotation.x=-Math.PI/2;
          beach.position.set(0,0.01,-40);
          this.scene.add(beach);
          this.objects.push({ mesh:beach, type:'beach', x:0, z:-40, boundingRadius:0 });

          const waterGeo=new THREE.PlaneGeometry(300,30);
          const waterMat=new THREE.MeshStandardMaterial({ color:0x1E90FF, transparent:true, opacity:0.8, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:1 });
          const water=new THREE.Mesh(waterGeo,waterMat);
          water.rotation.x=-Math.PI/2;
          water.position.set(0,0.02,-70);
          this.scene.add(water);
          this.objects.push({ mesh:water, type:'water', x:0, z:-70, boundingRadius:0 });
        }

        createSun(){
          const sunGeo=new THREE.SphereGeometry(3,16,16);
          const sunMat=new THREE.MeshBasicMaterial({ color:0xffee00 });
          this.sunMesh=new THREE.Mesh(sunGeo,sunMat);
          this.sunMesh.position.set(0,200,-200);
          this.sunMesh.visible=true;
          this.scene.add(this.sunMesh);
        }
        createMoon(){
          const moonGeo=new THREE.SphereGeometry(2,16,16);
          const moonMat=new THREE.MeshBasicMaterial({ color:0xcccccc });
          this.moonMesh=new THREE.Mesh(moonGeo,moonMat);
          this.moonMesh.position.set(-100,150,100);
          this.moonMesh.visible=false;
          this.scene.add(this.moonMesh);
        }
        createStars(){
          const starCount=300;
          const positions=new Float32Array(starCount*3);
          for(let i=0;i<starCount;i++){
            const radius=300+Math.random()*200;
            const angle=Math.random()*Math.PI*2;
            const ySpread=Math.random()*200-50;
            positions[i*3]=Math.cos(angle)*radius;
            positions[i*3+1]=50+ySpread;
            positions[i*3+2]=Math.sin(angle)*radius;
          }
          const starGeo=new THREE.BufferGeometry();
          starGeo.setAttribute('position',new THREE.BufferAttribute(positions,3));
          const starMat=new THREE.PointsMaterial({ color:0xffffff, size:1.2, depthTest:false });
          const starField=new THREE.Points(starGeo,starMat);
          starField.visible=false;
          this.scene.add(starField);
          this.starsMesh=starField;
        }

        createPlayerModel(){
          const group=new THREE.Group();
          // Body
          const body=new THREE.Mesh(
            new THREE.CylinderGeometry(0.4,0.5,1.2,16),
            new THREE.MeshStandardMaterial({ color:0xff69b4 })
          );
          body.position.set(0,0.6,0);
          group.add(body);

          // Head
          const head=new THREE.Mesh(
            new THREE.SphereGeometry(0.3,16,16),
            new THREE.MeshStandardMaterial({ color:0xffddc1 })
          );
          head.position.set(0,1.4,0);
          group.add(head);

          // Hair
          const hair=new THREE.Mesh(
            new THREE.SphereGeometry(0.4,16,16),
            new THREE.MeshStandardMaterial({ color:0x4b2e05 })
          );
          hair.position.set(0,1.75,0);
          group.add(hair);

          // Crown
          const crown=new THREE.Mesh(
            new THREE.TorusGeometry(0.25,0.09,8,16),
            new THREE.MeshStandardMaterial({ color:0xffd700 })
          );
          crown.rotation.x=Math.PI/2;
          crown.position.set(0,1.95,0);
          group.add(crown);

          // Arms (animate them)
          const armGeo=new THREE.CylinderGeometry(0.1,0.1,0.8,8);
          const skinMat=new THREE.MeshStandardMaterial({ color:0xffddc1 });
          const leftArm=new THREE.Mesh(armGeo,skinMat);
          leftArm.position.set(-0.5,1.0,0);
          leftArm.userData={ isArm:true, side:'left' };
          group.add(leftArm);
          const rightArm=new THREE.Mesh(armGeo,skinMat);
          rightArm.position.set(0.5,1.0,0);
          rightArm.userData={ isArm:true, side:'right' };
          group.add(rightArm);

          // Legs
          const legGeo=new THREE.CylinderGeometry(0.12,0.12,0.8,8);
          const leftLeg=new THREE.Mesh(legGeo,skinMat);
          leftLeg.position.set(-0.2,0.2,0);
          group.add(leftLeg);
          const rightLeg=new THREE.Mesh(legGeo,skinMat);
          rightLeg.position.set(0.2,0.2,0);
          group.add(rightLeg);

          group.position.set(0,0.5,0);
          this.player.object=group;
          this.scene.add(group);
        }

        createCastle(){
          const group=new THREE.Group();
          const base=new THREE.Mesh(
            new THREE.BoxGeometry(20,10,20),
            new THREE.MeshStandardMaterial({ color:0xcccccc })
          );
          base.position.set(0,5,0);
          group.add(base);

          const towerGeo=new THREE.CylinderGeometry(3,3,15,16);
          const towerMat=new THREE.MeshStandardMaterial({ color:0xcccccc });
          [[10,7.5,10],[-10,7.5,10],[10,7.5,-10],[-10,7.5,-10]].forEach(pos=>{
            const tower=new THREE.Mesh(towerGeo,towerMat);
            tower.position.set(pos[0],pos[1],pos[2]);
            group.add(tower);
          });

          const door=new THREE.Mesh(
            new THREE.PlaneGeometry(4,6),
            new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide })
          );
          door.position.set(0,3,10.01);
          group.add(door);

          // "Daddy's Castle" sign
          const canvas=document.createElement('canvas');
          canvas.width=512; canvas.height=128;
          const ctx=canvas.getContext('2d');
          ctx.fillStyle='black'; ctx.fillRect(0,0,512,128);
          ctx.fillStyle='white'; ctx.font='60px Arial';
          ctx.fillText("Daddy's Castle",50,80);
          const tex=new THREE.Texture(canvas);
          tex.needsUpdate=true;
          const signMat=new THREE.MeshBasicMaterial({ map:tex });
          const signGeo=new THREE.PlaneGeometry(12,3);
          const signMesh=new THREE.Mesh(signGeo,signMat);
          signMesh.position.set(0,8,10.1);
          group.add(signMesh);

          group.position.set(40,0,40);
          this.scene.add(group);
          this.objects.push({ mesh:group, type:'building', x:40, z:40, boundingRadius:15 });
        }

        createHouse(){
          const group=new THREE.Group();
          const base=new THREE.Mesh(
            new THREE.BoxGeometry(12,8,10),
            new THREE.MeshStandardMaterial({ color:0x8b4513 })
          );
          base.position.set(0,4,0);
          group.add(base);

          const roof=new THREE.Mesh(
            new THREE.ConeGeometry(6,4,4),
            new THREE.MeshStandardMaterial({ color:0x800000 })
          );
          roof.position.set(0,8,0);
          roof.rotation.y=Math.PI/4;
          group.add(roof);

          const door=new THREE.Mesh(
            new THREE.PlaneGeometry(2,4),
            new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide })
          );
          door.position.set(0,2,5.01);
          group.add(door);

          // House sign
          const canvas=document.createElement('canvas');
          canvas.width=128; canvas.height=32;
          const ctx=canvas.getContext('2d');
          ctx.fillStyle='black'; ctx.fillRect(0,0,128,32);
          ctx.fillStyle='white'; ctx.font='16px Arial';
          ctx.fillText("Donia's House",5,22);
          const tex=new THREE.Texture(canvas);
          tex.needsUpdate=true;
          const signMat=new THREE.MeshBasicMaterial({ map:tex, transparent:true });
          const signGeo=new THREE.PlaneGeometry(4,1);
          const signMesh=new THREE.Mesh(signGeo,signMat);
          signMesh.position.set(0,5,4.05);
          group.add(signMesh);

          group.position.set(-40,0,-40);
          this.scene.add(group);
          this.objects.push({ mesh:group, type:'building', x:-40, z:-40, boundingRadius:10 });
        }

        createCafe(){
          const group=new THREE.Group();
          const base=new THREE.Mesh(
            new THREE.BoxGeometry(12,7,10),
            new THREE.MeshStandardMaterial({ color:0x888888 })
          );
          base.position.set(0,3.5,0);
          group.add(base);

          const door=new THREE.Mesh(
            new THREE.PlaneGeometry(2,3),
            new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide })
          );
          door.position.set(0,1.5,5.01);
          group.add(door);

          // Cafe sign
          const canvas=document.createElement('canvas');
          canvas.width=256; canvas.height=64;
          const ctx=canvas.getContext('2d');
          ctx.fillStyle='black'; ctx.fillRect(0,0,256,64);
          ctx.fillStyle='white'; ctx.font='30px Arial'; ctx.textAlign='center';
          ctx.fillText("Donia's Cafe",128,40);
          const tex=new THREE.Texture(canvas);
          tex.needsUpdate=true;
          const signMat=new THREE.MeshBasicMaterial({ map:tex, transparent:true });
          const signGeo=new THREE.PlaneGeometry(8,2);
          const signMesh=new THREE.Mesh(signGeo,signMat);
          signMesh.position.set(0,3.5,4.05);
          group.add(signMesh);

          group.position.set(70,0,-30);
          this.scene.add(group);
          this.objects.push({ mesh:group, type:'building', x:70, z:-30, boundingRadius:10 });
        }

        createFountain(){
          const group=new THREE.Group();
          const base=new THREE.Mesh(
            new THREE.CylinderGeometry(3,3,1,16),
            new THREE.MeshStandardMaterial({ color:0x808080 })
          );
          base.position.set(0,0.5,0);
          group.add(base);

          const bowl=new THREE.Mesh(
            new THREE.TorusGeometry(3,0.3,16,32),
            new THREE.MeshStandardMaterial({ color:0x808080 })
          );
          bowl.rotation.x=Math.PI/2;
          bowl.position.y=1;
          group.add(bowl);

          const water=new THREE.Mesh(
            new THREE.CylinderGeometry(2.8,2.8,0.2,16),
            new THREE.MeshStandardMaterial({ color:0x00ffff, transparent:true, opacity:0.6 })
          );
          water.position.set(0,1.1,0);
          group.add(water);

          group.position.set(0,0,20);
          this.scene.add(group);
          this.objects.push({ mesh:group, type:'decoration', x:0, z:20, boundingRadius:5 });
        }

        createBlueNPC(){
          const group=new THREE.Group();
          const body=new THREE.Mesh(
            new THREE.CylinderGeometry(0.4,0.5,1.2,16),
            new THREE.MeshStandardMaterial({ color:0x0000ff })
          );
          body.position.set(0,0.6,0);
          group.add(body);

          const head=new THREE.Mesh(
            new THREE.SphereGeometry(0.3,16,16),
            new THREE.MeshStandardMaterial({ color:0xffddc1 })
          );
          head.position.set(0,1.4,0);
          group.add(head);

          const hair=new THREE.Mesh(
            new THREE.SphereGeometry(0.4,16,16),
            new THREE.MeshStandardMaterial({ color:0x4b2e05 })
          );
          hair.position.set(0,1.75,0);
          group.add(hair);

          // Arms
          const armGeo=new THREE.CylinderGeometry(0.1,0.1,0.8,8);
          const skinMat=new THREE.MeshStandardMaterial({ color:0xffddc1 });
          const leftArm=new THREE.Mesh(armGeo,skinMat);
          leftArm.position.set(-0.5,1.0,0);
          leftArm.userData={ isArm:true, side:'left' };
          group.add(leftArm);
          const rightArm=new THREE.Mesh(armGeo,skinMat);
          rightArm.position.set(0.5,1.0,0);
          rightArm.userData={ isArm:true, side:'right' };
          group.add(rightArm);

          group.position.set(120,0.5,0);
          this.scene.add(group);
          this.objects.push({ mesh:group, type:'npc', x:120, z:0, boundingRadius:1 });
          this.npcBlueData.object=group;
        }

        createYellowNPC(){
          const group=new THREE.Group();
          const body=new THREE.Mesh(
            new THREE.CylinderGeometry(0.4,0.5,1.0,16),
            new THREE.MeshStandardMaterial({ color:0xffff00 })
          );
          body.position.set(0,0.5,0);
          group.add(body);

          const head=new THREE.Mesh(
            new THREE.SphereGeometry(0.3,16,16),
            new THREE.MeshStandardMaterial({ color:0xffddc1 })
          );
          head.position.set(0,1.1,0);
          group.add(head);

          const hair=new THREE.Mesh(
            new THREE.SphereGeometry(0.4,16,16),
            new THREE.MeshStandardMaterial({ color:0x4b2e05 })
          );
          hair.position.set(0,1.55,0);
          group.add(hair);

          // Arms
          const armGeo=new THREE.CylinderGeometry(0.1,0.1,0.6,8);
          const skinMat=new THREE.MeshStandardMaterial({ color:0xffddc1 });
          const leftArm=new THREE.Mesh(armGeo,skinMat);
          leftArm.position.set(-0.5,0.8,0);
          leftArm.userData={ isArm:true, side:'left' };
          group.add(leftArm);
          const rightArm=new THREE.Mesh(armGeo,skinMat);
          rightArm.position.set(0.5,0.8,0);
          rightArm.userData={ isArm:true, side:'right' };
          group.add(rightArm);

          group.position.set(-30,0.3,30);
          this.scene.add(group);
          this.objects.push({ mesh:group, type:'npc', x:-30, z:30, boundingRadius:1 });
          this.npcYellowData.object=group;
        }

        createGuardAtCastle(){
          const group=new THREE.Group();
          const body=new THREE.Mesh(
            new THREE.CylinderGeometry(0.4,0.5,1.2,16),
            new THREE.MeshStandardMaterial({ color:0x000000 })
          );
          body.position.set(0,0.6,0);
          group.add(body);

          const head=new THREE.Mesh(
            new THREE.SphereGeometry(0.3,16,16),
            new THREE.MeshStandardMaterial({ color:0xffddc1 })
          );
          head.position.set(0,1.4,0);
          group.add(head);

          const hair=new THREE.Mesh(
            new THREE.SphereGeometry(0.4,16,16),
            new THREE.MeshStandardMaterial({ color:0x4b2e05 })
          );
          hair.position.set(0,1.75,0);
          group.add(hair);

          // Arms
          const armGeo=new THREE.CylinderGeometry(0.1,0.1,0.8,8);
          const skinMat=new THREE.MeshStandardMaterial({ color:0xffddc1 });
          const leftArm=new THREE.Mesh(armGeo,skinMat);
          leftArm.position.set(-0.5,1.0,0);
          leftArm.userData={ isArm:true, side:'left' };
          group.add(leftArm);
          const rightArm=new THREE.Mesh(armGeo,skinMat);
          rightArm.position.set(0.5,1.0,0);
          rightArm.userData={ isArm:true, side:'right' };
          group.add(rightArm);

          group.position.set(45,0.5,50.5);
          this.scene.add(group);
          this.objects.push({ mesh:group, type:'guard', x:45, z:50.5, boundingRadius:3 });
          this.guardData.object=group;
          this.guardObject=group;
        }

        createMermaid(){
          const group=new THREE.Group();
          const body=new THREE.Mesh(
            new THREE.CylinderGeometry(0.4,0.5,0.6,16),
            new THREE.MeshStandardMaterial({ color:0xff69b4 })
          );
          body.position.set(0,0.9,0);
          group.add(body);

          const head=new THREE.Mesh(
            new THREE.SphereGeometry(0.3,16,16),
            new THREE.MeshStandardMaterial({ color:0xffddc1 })
          );
          head.position.set(0,1.4,0);
          group.add(head);

          const hair=new THREE.Mesh(
            new THREE.SphereGeometry(0.4,16,16),
            new THREE.MeshStandardMaterial({ color:0x4b2e05 })
          );
          hair.position.set(0,1.8,0);
          group.add(hair);

          // Arms
          const armGeo=new THREE.CylinderGeometry(0.1,0.1,0.6,8);
          const skinMat=new THREE.MeshStandardMaterial({ color:0xffddc1 });
          const leftArm=new THREE.Mesh(armGeo,skinMat);
          leftArm.position.set(-0.5,1.1,0);
          leftArm.userData={ isArm:true, side:'left' };
          group.add(leftArm);
          const rightArm=new THREE.Mesh(armGeo,skinMat);
          rightArm.position.set(0.5,1.1,0);
          rightArm.userData={ isArm:true, side:'right' };
          group.add(rightArm);

          group.position.set(20,-0.5,-70);
          this.scene.add(group);
          this.objects.push({ mesh:group, type:'mermaid', x:20, z:-70, boundingRadius:3 });
          this.mermaidData.object=group;
        }

        createBird(){
          const bird=new THREE.Mesh(
            new THREE.SphereGeometry(0.5,8,8),
            new THREE.MeshStandardMaterial({ color:0xffffff })
          );
          bird.position.set(0,60,0);
          this.scene.add(bird);
          this.birdData.object=bird;
        }

        /* Items */
        createFlowers(count){
          for(let i=0;i<count;i++){
            const fx=Math.random()*this.itemRange*2 - this.itemRange;
            const fz=Math.random()*this.itemRange*2 - this.itemRange;
            const stem=new THREE.Mesh(
              new THREE.CylinderGeometry(0.05,0.05,1,8),
              new THREE.MeshStandardMaterial({ color:0x008000 })
            );
            stem.position.y=0.5;
            const bloom=new THREE.Mesh(
              new THREE.SphereGeometry(0.2,8,8),
              new THREE.MeshStandardMaterial({ color:0xff0000 })
            );
            bloom.position.y=1;
            const flower=new THREE.Group();
            flower.add(stem,bloom);
            flower.position.set(fx,0,fz);
            this.scene.add(flower);
            this.objects.push({ mesh:flower, type:'flower', isPickup:true, x:fx, z:fz });
          }
        }
        createCoins(count){
          for(let i=0;i<count;i++){
            const cx=Math.random()*this.itemRange*2 - this.itemRange;
            const cz=Math.random()*this.itemRange*2 - this.itemRange;
            const coin=new THREE.Mesh(
              new THREE.CircleGeometry(0.3,16),
              new THREE.MeshStandardMaterial({ color:0xffff00 })
            );
            coin.rotation.x=-Math.PI/2;
            coin.position.set(cx,0.01,cz);
            this.scene.add(coin);
            this.objects.push({ mesh:coin, type:'coin', isPickup:true, x:cx, z:cz });
          }
        }
        createGems(count){
          for(let i=0;i<count;i++){
            const gx=Math.random()*this.itemRange*2 - this.itemRange;
            const gz=Math.random()*this.itemRange*2 - this.itemRange;
            const gem=new THREE.Mesh(
              new THREE.OctahedronGeometry(0.5,0),
              new THREE.MeshStandardMaterial({ color:0x00ffff })
            );
            gem.position.set(gx,0.5,gz);
            this.scene.add(gem);
            this.objects.push({ mesh:gem, type:'gem', isPickup:true, x:gx, z:gz });
          }
        }
        createPotions(count){
          for(let i=0;i<count;i++){
            const px=Math.random()*this.itemRange*2 - this.itemRange;
            const pz=Math.random()*this.itemRange*2 - this.itemRange;
            const base=new THREE.Mesh(
              new THREE.CylinderGeometry(0.3,0.3,0.8,16),
              new THREE.MeshStandardMaterial({ color:0xffffff })
            );
            base.position.y=0.4;
            const liquid=new THREE.Mesh(
              new THREE.CylinderGeometry(0.25,0.25,0.6,16),
              new THREE.MeshStandardMaterial({ color:0xff4500 })
            );
            liquid.position.y=0.4;
            const potion=new THREE.Group();
            potion.add(base,liquid);
            potion.position.set(px,0,pz);
            this.scene.add(potion);
            this.objects.push({ mesh:potion, type:'potion', isPickup:true, x:px, z:pz });
          }
        }
        createKeys(count){
          for(let i=0;i<count;i++){
            const kx=Math.random()*this.itemRange*2 - this.itemRange;
            const kz=Math.random()*this.itemRange*2 - this.itemRange;
            const handle=new THREE.Mesh(
              new THREE.SphereGeometry(0.2,16,16),
              new THREE.MeshStandardMaterial({ color:0xffd700 })
            );
            const shaft=new THREE.Mesh(
              new THREE.CylinderGeometry(0.1,0.1,0.8,8),
              new THREE.MeshStandardMaterial({ color:0xffd700 })
            );
            shaft.position.y=-0.4;
            const key=new THREE.Group();
            key.add(handle,shaft);
            key.position.set(kx,0.5,kz);
            key.rotation.x=Math.PI/2;
            this.scene.add(key);
            this.objects.push({ mesh:key, type:'key', isPickup:true, x:kx, z:kz });
          }
        }
        createArtifacts(count){
          for(let i=0;i<count;i++){
            const ax=Math.random()*this.itemRange*2 - this.itemRange;
            const az=Math.random()*this.itemRange*2 - this.itemRange;
            const artifact=new THREE.Mesh(
              new THREE.SphereGeometry(0.5,16,16),
              new THREE.MeshStandardMaterial({ color:0x9400d3 })
            );
            const glow=new THREE.Mesh(
              new THREE.SphereGeometry(0.6,16,16),
              new THREE.MeshBasicMaterial({ color:0xffeb3b, transparent:true, opacity:0.5, side:THREE.BackSide })
            );
            const group=new THREE.Group();
            group.add(artifact,glow);
            group.position.set(ax,0.5,az);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'artifact', isPickup:true, x:ax, z:az });
          }
        }

        startAnimation(){
          const animate=()=>{
            requestAnimationFrame(animate);
            this.update();
            this.renderer.render(this.scene,this.camera);
          };
          animate();
        }

        update(){
          this.updateDayNight();
          this.updateBalls();
          this.updateGuard();
          this.updateMovement();
          this.updateBlueNPC();
          this.updateYellowNPC();
          this.updateMermaid();
          this.updateBird();
          this.updateCollisions();
          this.updateCamera();
          this.updatePickups();
          this.processController();
        }

        /* Day/Night cycle */
        updateDayNight(){
          this.dayNightCycle=(this.dayNightCycle+1)%1200;
          this.time=(this.dayNightCycle<600)?'Day':'Night';
          document.getElementById('time').textContent=this.time;
          if(this.sunMesh&&this.moonMesh&&this.starsMesh){
            if(this.time==='Day'){
              this.sunMesh.visible=true;
              this.moonMesh.visible=false;
              this.starsMesh.visible=false;
            } else {
              this.sunMesh.visible=false;
              this.moonMesh.visible=true;
              this.starsMesh.visible=true;
            }
          }
        }

        /* Ball update (bouncing, removing) */
        updateBalls(){
          for(let i=this.thrownBalls.length-1;i>=0;i--){
            const ball=this.thrownBalls[i];
            ball.position.add(ball.userData.velocity);
            ball.userData.velocity.y-=0.01;
            for(const obj of this.objects){
              if(obj.type==='building'||obj.type==='decoration'){
                const dxB=ball.position.x-obj.x;
                const dzB=ball.position.z-obj.z;
                const distSq=dxB*dxB+dzB*dzB;
                const r=(obj.boundingRadius||5);
                if(distSq<r*r&&ball.position.y<10){
                  const normal=new THREE.Vector3(dxB,0,dzB).normalize();
                  const v=ball.userData.velocity.clone();
                  const dot=v.dot(normal);
                  const reflection=v.sub(normal.multiplyScalar(2*dot)).multiplyScalar(0.6);
                  ball.userData.velocity.copy(reflection);
                }
              }
            }
            if(ball.position.y<0){
              if(!ball.userData.bounced){
                ball.position.y=0;
                ball.userData.velocity.y*=-0.7;
                ball.userData.bounced=true;
              } else if(ball.position.y<-0.5){
                this.scene.remove(ball);
                this.thrownBalls.splice(i,1);
              }
            }
          }
        }

        /* Guard patrol: idle 2 min => patrol => repeat */
        updateGuard(){
          if(!this.guardData.object)return;
          this.guardData.timer++;
          if(this.guardData.state==='idle'){
            if(this.guardData.timer>7200){
              this.guardData.state='patrol';
              this.guardData.timer=0;
              this.guardData.routeIndex=0;
            }
          } else if(this.guardData.state==='patrol'){
            const route=this.guardData.route;
            const guard=this.guardData.object;
            const target=route[this.guardData.routeIndex];
            const dx=target.x-guard.position.x;
            const dz=target.z-guard.position.z;
            const distSq=dx*dx+dz*dz;
            if(distSq<1){
              this.guardData.routeIndex++;
              if(this.guardData.routeIndex>=route.length){
                this.guardData.state='idle';
                this.guardData.timer=0;
              }
            } else {
              this.animateArms(guard,true);
              const angle=Math.atan2(dx,dz);
              guard.rotation.y=angle;
              const step=this.guardData.speed;
              const newX=guard.position.x+Math.sin(angle)*step;
              const newZ=guard.position.z+Math.cos(angle)*step;
              guard.position.set(newX,0.5,newZ);
              for(const obj of this.objects){
                if(obj.mesh===guard){ obj.x=newX; obj.z=newZ; break; }
              }
            }
          }
        }

        /* Movement: up/down => forward/back, left/right => turn */
        updateMovement(){
          let forward=0, turn=0;
          // Desktop arrow keys
          if(this.keysPressed['ArrowUp'])   forward+=1;
          if(this.keysPressed['ArrowDown']) forward-=1;
          if(this.keysPressed['ArrowLeft']) turn+=1; // left
          if(this.keysPressed['ArrowRight'])turn-=1; // right

          // On-screen D-Pad
          if(controllerState.dpadUp)   forward+=1;
          if(controllerState.dpadDown) forward-=1;
          if(controllerState.dpadLeft) turn+=1;
          if(controllerState.dpadRight)turn-=1;

          // Move forward/back
          const speed=this.player.speedKeyboard;
          if(forward!==0){
            const dx=Math.sin(this.player.yaw)*forward*speed;
            const dz=Math.cos(this.player.yaw)*forward*speed;
            const newX=this.player.x+dx;
            const newZ=this.player.z+dz;
            let blocked=false;
            for(const obj of this.objects){
              if(obj.type==='building'||obj.type==='boundary'||obj.type==='decoration'||obj.type==='npc'){
                const dxObj=newX-obj.x;
                const dzObj=newZ-obj.z;
                const distSq=dxObj*dxObj+dzObj*dzObj;
                const r=(obj.boundingRadius||5);
                if(distSq<r*r){ blocked=true; break; }
              }
            }
            if(!blocked){
              this.player.x=newX;
              this.player.z=newZ;
            }
            if(this.player.object){
              this.player.object.position.set(this.player.x,0.5,this.player.z);
            }
            this.animateArms(this.player.object,true);
          } else {
            this.animateArms(this.player.object,false);
          }

          // Turn
          if(turn!==0){
            this.player.yaw+=turn*0.02; // rotate
          }
        }

        /* Animate arms (player, NPCs) */
        animateArms(obj,isMoving){
          if(!obj)return;
          const t=Date.now()*0.01;
          obj.traverse(child=>{
            if(child.userData&&child.userData.isArm){
              if(isMoving){
                if(child.userData.side==='left'){
                  child.rotation.x=Math.sin(t)*0.5;
                } else {
                  child.rotation.x=-Math.sin(t)*0.5;
                }
              } else {
                child.rotation.x=0;
              }
            }
          });
        }

        /* Blue NPC orbits, Yellow roams, etc. */
        updateBlueNPC(){
          this.npcBlueData.angle+=this.npcBlueData.speed;
          const x=this.npcBlueData.radius*Math.cos(this.npcBlueData.angle);
          const z=this.npcBlueData.radius*Math.sin(this.npcBlueData.angle);
          if(this.npcBlueData.object){
            this.animateArms(this.npcBlueData.object,true);
            this.npcBlueData.object.position.set(x,0.5,z);
            this.npcBlueData.object.rotation.y=-this.npcBlueData.angle;
            for(const obj of this.objects){
              if(obj.mesh===this.npcBlueData.object){ obj.x=x; obj.z=z; break; }
            }
          }
        }
        updateYellowNPC(){
          if(!this.npcYellowData.object)return;
          const npc=this.npcYellowData.object;
          if(!this.npcYellowData.target){
            this.npcYellowData.target=this.getRandomBuildingTarget();
          }
          const dx=this.npcYellowData.target.x-npc.position.x;
          const dz=this.npcYellowData.target.z-npc.position.z;
          const distSq=dx*dx+dz*dz;
          if(distSq<1){
            this.npcYellowData.target=this.getRandomBuildingTarget();
          } else {
            this.animateArms(npc,true);
            const angle=Math.atan2(dx,dz);
            npc.rotation.y=angle;
            const step=this.npcYellowData.speed;
            const newX=npc.position.x+Math.sin(angle)*step;
            const newZ=npc.position.z+Math.cos(angle)*step;
            if(Math.abs(newX)<125&&Math.abs(newZ)<125){
              npc.position.x=newX; npc.position.z=newZ;
            }
          }
          for(const obj of this.objects){
            if(obj.mesh===npc){ obj.x=npc.position.x; obj.z=npc.position.z; break; }
          }
        }
        updateMermaid(){
          if(!this.mermaidData.object)return;
          const mer=this.mermaidData;
          const pt=mer.route[mer.routeIndex];
          const dx=pt.x-mer.object.position.x;
          const dz=pt.z-mer.object.position.z;
          const distSq=dx*dx+dz*dz;
          if(distSq<1){
            mer.routeIndex=(mer.routeIndex+1)%mer.route.length;
          } else {
            this.animateArms(mer.object,true);
            const angle=Math.atan2(dx,dz);
            mer.object.rotation.y=angle;
            const step=mer.speed;
            const newX=mer.object.position.x+Math.sin(angle)*step;
            const newZ=mer.object.position.z+Math.cos(angle)*step;
            mer.object.position.set(newX,0.5,newZ);
            for(const obj of this.objects){
              if(obj.mesh===mer.object){ obj.x=newX; obj.z=newZ; break; }
            }
          }
        }
        updateBird(){
          this.birdData.angle+=this.birdData.speed;
          const bx=this.birdData.radius*Math.cos(this.birdData.angle);
          const bz=this.birdData.radius*Math.sin(this.birdData.angle);
          if(this.birdData.object){
            this.birdData.object.position.set(bx,60,bz);
            this.birdData.object.rotation.y=-this.birdData.angle;
          }
        }

        /* Collisions for guard, mermaid, blue npc, etc. */
        updateCollisions(){
          // guard
          if(this.guardObject&&!this.guardMessageShown){
            const dxG=this.player.x-this.guardObject.position.x;
            const dzG=this.player.z-this.guardObject.position.z;
            const distG=Math.sqrt(dxG*dxG+dzG*dzG);
            if(distG<5){
              this.showGuardPopup("I'm the guard of this castle. Please show your ID.");
            }
          }
          // Blue NPC
          if(this.npcBlueData.object&&!this.npcBlueMessageShown){
            const dxN=this.player.x-this.npcBlueData.object.position.x;
            const dzN=this.player.z-this.npcBlueData.object.position.z;
            const distN=Math.sqrt(dxN*dxN+dzN*dzN);
            if(distN<5){
              this.showGuardPopup("Hello Princess Donia!");
              this.npcBlueMessageShown=true;
              setTimeout(()=>{ this.npcBlueMessageShown=false; },2500);
            }
          }
          // Mermaid
          if(!this.mermaidMessageShown){
            const mermaidObj=this.objects.find(o=>o.type==='mermaid');
            if(mermaidObj){
              const dxM=this.player.x-mermaidObj.x;
              const dzM=this.player.z-mermaidObj.z;
              const distM=Math.sqrt(dxM*dxM+dzM*dzM);
              if(distM<5){
                this.showGuardPopup("Hello Princess Donia. It's me the Mermaid.");
                this.mermaidMessageShown=true;
                setTimeout(()=>{ this.mermaidMessageShown=false; },2500);
              }
            }
          }
        }

        /* Keep camera behind the player (Tomb Raider style) */
        updateCamera(){
          const camDist=15;
          // If yaw=0 => facing +Z => behind is -Z
          const offsetX=-Math.sin(this.player.yaw)*camDist;
          const offsetZ=-Math.cos(this.player.yaw)*camDist;
          const offsetY=15;
          this.camera.position.set(this.player.x+offsetX, offsetY, this.player.z+offsetZ);
          this.camera.lookAt(this.player.x,1,this.player.z);
        }

        /* Pickups: flowers, coins, etc. */
        updatePickups(){
          for(const obj of this.objects){
            if(obj.isPickup){
              const dxObj=this.player.x-obj.x;
              const dzObj=this.player.z-obj.z;
              const distSq=dxObj*dxObj+dzObj*dzObj;
              if(distSq<4){
                switch(obj.type){
                  case 'flower':
                    this.flowers++;
                    document.getElementById('flowers').textContent=this.flowers;
                    this.showDialogue('You picked a radiant flower!');
                    break;
                  case 'coin':
                    this.coins++;
                    document.getElementById('coins').textContent=this.coins;
                    this.showDialogue('You picked up a shiny coin!');
                    break;
                  case 'gem':
                    this.gems++;
                    document.getElementById('gems').textContent=this.gems;
                    this.showDialogue('A dazzling gem is yours!');
                    break;
                  case 'potion':
                    this.potions++;
                    document.getElementById('potions').textContent=this.potions;
                    this.showDialogue('You found a potion!');
                    break;
                  case 'key':
                    this.keys++;
                    document.getElementById('keys').textContent=this.keys;
                    this.showDialogue('A golden key is yours!');
                    break;
                  case 'artifact':
                    this.artifacts++;
                    document.getElementById('artifacts').textContent=this.artifacts;
                    this.showDialogue('You discovered a mystical artifact!');
                    break;
                }
                this.scene.remove(obj.mesh);
                this.objects=this.objects.filter(o=>o!==obj);
                this.startCollectionGlow();
              }
            }
          }
        }

        /* Simple dialogue */
        showDialogue(text){
          document.getElementById('dialogue').textContent=text;
        }
        showGuardPopup(text){
          const popup=document.getElementById('guardPopup');
          popup.style.display='block';
          popup.textContent=text;
          setTimeout(()=>{
            popup.style.display='none';
            popup.textContent='';
          },2000);
        }

        /* Throw normal ball forward (facing +Z if yaw=0) */
        throwBall(){
          if(!this.player.object)return;
          const direction=new THREE.Vector3(Math.sin(this.player.yaw),0,Math.cos(this.player.yaw));
          const ballGeo=new THREE.SphereGeometry(0.3,16,16);
          const ballMat=new THREE.MeshStandardMaterial({ color:0xff4500 });
          const ball=new THREE.Mesh(ballGeo,ballMat);
          ball.position.set(this.player.x,0.5,this.player.z);
          ball.position.y+=1;
          ball.userData={
            velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
            bounced:false
          };
          this.scene.add(ball);
          this.thrownBalls.push(ball);
          this.ballCount++;
          document.getElementById('ballCountValue').textContent=this.ballCount;
          this.showDialogue("Threw a magic ball!");
        }

        /* Throw big blue ball */
        throwBigBall(){
          if(!this.player.object)return;
          const direction=new THREE.Vector3(Math.sin(this.player.yaw),0,Math.cos(this.player.yaw));
          const ballGeo=new THREE.SphereGeometry(0.6,16,16);
          const ballMat=new THREE.MeshStandardMaterial({ color:0x0000ff });
          const ball=new THREE.Mesh(ballGeo,ballMat);
          ball.position.set(this.player.x,0.5,this.player.z);
          ball.position.y+=1;
          ball.userData={
            velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
            bounced:false
          };
          this.scene.add(ball);
          this.thrownBalls.push(ball);
          this.ballCount++;
          document.getElementById('ballCountValue').textContent=this.ballCount;
          this.showDialogue("Threw a BIG magic ball!");
        }

        /* Collection glow effect */
        startCollectionGlow(){
          if(this.collectionGlow)this.scene.remove(this.collectionGlow);
          const glowGeo=new THREE.SphereGeometry(1,16,16);
          const glowMat=new THREE.MeshBasicMaterial({ color:0xffff00, transparent:true, opacity:0.5, side:THREE.BackSide });
          const glow=new THREE.Mesh(glowGeo,glowMat);
          glow.position.set(this.player.x,1,this.player.z);
          this.scene.add(glow);
          this.collectionGlow=glow;
          setTimeout(()=>{
            if(this.collectionGlow){
              this.scene.remove(this.collectionGlow);
              this.collectionGlow=null;
            }
          },1000);
        }

        /* On-screen turn buttons => slow rotation */
        processController(){
          if(controllerState.turnLeft)  this.player.yaw+=0.01;
          if(controllerState.turnRight) this.player.yaw-=0.01;
        }

        initKeyboardMouse(){
          document.addEventListener('keydown', e=>{
            this.keysPressed[e.key]=true;
            if(e.key===' ') this.throwBall();
          });
          document.addEventListener('keyup', e=>{
            this.keysPressed[e.key]=false;
          });
          document.addEventListener('mousedown', ()=>{
            try{ document.body.requestPointerLock(); }
            catch(err){ console.warn('Pointer lock request failed:',err); }
          });
          document.addEventListener('mousemove', evt=>{
            if(document.pointerLockElement===document.body){
              const movementX=evt.movementX||0;
              const sensitivity=0.001;
              this.player.yaw+=movementX*sensitivity;
            }
          });
        }

        startAnimation(){
          const animate=()=>{
            requestAnimationFrame(animate);
            this.update();
            this.renderer.render(this.scene,this.camera);
          };
          animate();
        }
      }

      // Create the global game instance
      window.game=new Game();
    } catch(err){
      console.error('Error initializing the game:',err);
    }
  </script>
</body>
</html>
