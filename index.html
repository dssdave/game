<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town - Castle Interior</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw; height: 100vh;
    }
    canvas { display: block; }

    /* UI boxes */
    #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
      background: rgba(0,0,0,0.7);
      border: 4px solid #fff;
      border-radius: 5px;
      color: #fff;
      font-size: 28px;
      padding: 40px 80px;
      position: absolute;
      z-index: 10;
    }
    #ui         { top: 10px; left: 10px; }
    #ballCount  { top: 10px; right: 10px; }
    #dialogue   { bottom: 10px; left: 10px; max-width: 600px; display: none; }
    #controls   { bottom: 10px; right: 10px; }
    #errorMessage {
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      display: none;
    }
    #guardPopup {
      bottom: 50%; left: 50%;
      transform: translate(-50%,50%);
      display: none; text-align: center;
    }

    /* Toggle UI button */
    #toggleUIBtn {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      font-size: 24px;
      padding: 10px 20px;
      background: #333; color: #fff;
      border: 2px solid #fff; border-radius: 5px;
      cursor: pointer;
    }

    /* On-screen Controller Panels */
    #dpadContainer, #turnContainer, #actionContainer {
      position: absolute; z-index: 15;
    }
    /* D-Pad as a grid with a small gap */
    #dpadContainer {
      bottom: 16vh; left: 5vw;
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
    }
    #btnUp    { grid-column: 2; grid-row: 1; }
    #btnDown  { grid-column: 2; grid-row: 3; }
    #btnLeft  { grid-column: 1; grid-row: 2; }
    #btnRight { grid-column: 3; grid-row: 2; }

    #dpadContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 20px; color: #fff;
      cursor: pointer;
    }
    #turnContainer {
      bottom: 16vh; left: calc(5vw + 200px);
      display: flex; flex-direction: column; gap: 10px;
    }
    #turnContainer button, #actionContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px; color: #fff;
      cursor: pointer;
    }
    #actionContainer {
      bottom: 16vh; left: calc(5vw + 200px + 70px);
      display: flex; flex-direction: column; gap: 10px;
    }

    /* Smaller UI on narrower screens */
    @media (max-width: 768px) {
      #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
        font-size: 16px; padding: 20px 30px;
      }
      #toggleUIBtn { font-size: 16px; }
      #dpadContainer {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
      }
      #dpadContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
      #turnContainer button, #actionContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>

    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifacts: <span id="artifacts">0</span> |
      Health: <span id="health">100</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
    <div id="dialogue"></div>
    <div id="controls">
      Controls:<br>
      [Desktop] Arrow Up/Down = forward/back, Left/Right = turn, Space = throw ball<br>
      [Mobile] D‑Pad Up/Down = forward/back, Left/Right = strafe, L/R = turn, A = throw ball, B = jump
    </div>
    <div id="errorMessage">WebGL not supported in your browser.</div>
    <div id="guardPopup"></div>

    <!-- On-screen Controller Panels -->
    <div id="dpadContainer">
      <button id="btnUp">▲</button>
      <button id="btnDown">▼</button>
      <button id="btnLeft">◀</button>
      <button id="btnRight">▶</button>
    </div>
    <div id="turnContainer">
      <button id="btnTurnLeft">L</button>
      <button id="btnTurnRight">R</button>
    </div>
    <div id="actionContainer">
      <button id="btnThrow">A</button>
      <button id="btnBigThrow">B</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Toggle UI
    document.getElementById('toggleUIBtn').addEventListener('click', () => {
      const ids = ["ui", "ballCount", "dialogue", "controls", "guardPopup", "errorMessage"];
      for (const id of ids) {
        const el = document.getElementById(id);
        el.style.display = (el.style.display === "none") ? "block" : "none";
      }
    });

    // Prevent text highlighting on mobile
    function disableHighlight(id) {
      const btn = document.getElementById(id);
      ["touchstart", "mousedown"].forEach(evt => {
        btn.addEventListener(evt, e => { e.preventDefault(); }, { passive: false });
      });
    }
    ["btnUp","btnDown","btnLeft","btnRight","btnTurnLeft","btnTurnRight","btnThrow","btnBigThrow"]
      .forEach(disableHighlight);

    // On-screen controller state
    const controllerState = {
      dpadUp: false, dpadDown: false, dpadLeft: false, dpadRight: false,
      turnLeft: false, turnRight: false
    };
    function setButtonListener(btnId, stateProp) {
      const btn = document.getElementById(btnId);
      ["mousedown","touchstart"].forEach(evt => {
        btn.addEventListener(evt, e => { e.preventDefault(); controllerState[stateProp] = true; }, { passive:false });
      });
      ["mouseup", "touchend", "mouseleave"].forEach(evt => {
        btn.addEventListener(evt, e => { controllerState[stateProp] = false; });
      });
    }
    setButtonListener('btnUp', 'dpadUp');
    setButtonListener('btnDown', 'dpadDown');
    setButtonListener('btnLeft', 'dpadLeft');
    setButtonListener('btnRight', 'dpadRight');
    setButtonListener('btnTurnLeft', 'turnLeft');
    setButtonListener('btnTurnRight', 'turnRight');

    // A/B button actions
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game && typeof window.game.throwBall === "function") {
          window.game.throwBall();
        }
      }, { passive: false });
    });
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnBigThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game && typeof window.game.jump === "function") {
          window.game.jump();
        }
      }, { passive: false });
    });

    let game = null;

    try {
      const errorMsg = document.getElementById('errorMessage');
      const gameCanvas = document.getElementById('gameCanvas');
      if (!window.WebGLRenderingContext) {
        errorMsg.style.display = 'block';
        gameCanvas.style.display = 'none';
        throw new Error('WebGL not supported');
      }

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
      const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      gameCanvas.style.display = 'block';

      const keysPressed = {};

      class Game {
        constructor() {
          this.scene = scene;
          this.camera = camera;
          this.renderer = renderer;
          this.time = 'Day';
          this.dayNightCycle = 0;

          // We'll move 2.5x faster outside, normal speed inside
          this.player = {
            x: 0, y: 0.5, z: 0,
            baseSpeed: 0.1, // base speed
            yaw: 0, pitch: 0,
            jumpVelocity: 0,
            object: null
          };

          // Stats
          this.flowers = 0; 
          this.coins = 0; 
          this.gems = 0; 
          this.potions = 0; 
          this.keys = 0; 
          this.artifacts = 0;
          this.health = 100;

          this.objects = []; 
          this.buildingPositions = [];
          this.ballCount = 0;
          this.thrownBalls = [];
          this.keysPressed = keysPressed;
          this.itemRange = 80;

          // Day/Night
          this.sunMesh = null; 
          this.moonMesh = null; 
          this.starsMesh = null;

          // NPC data
          this.npcBlueData = { angle: 0, speed: 0.001, radius: 120, object: null };
          this.npcYellowData = { object: null, speed: 0.03, target: null };
          this.guardData = {
            object: null,
            state: 'idle',
            timer: 0,
            route: [ { x: 35, z: 60 }, { x: 35, z: 70 }, { x: 55, z: 70 }, { x: 55, z: 60 }, { x: 45, z: 55 } ],
            routeIndex: 0,
            speed: 0.02
          };
          this.mermaidData = { object: null, route: [ { x: -15, z: -70 }, { x: 15, z: -70 } ], routeIndex: 0, speed: 0.02 };
          this.birdData = { angle: 0, speed: 0.002, radius: 140, object: null };
          this.guardObject = null; 
          this.guardMessageShown = false;
          this.npcBlueMessageShown = false; 
          this.mermaidMessageShown = false; 
          this.npcYellowMessageShown = false;

          // Piazza NPC random-walk data
          this.piazzaNPCData = [];

          // Scene-switch booleans
          this.interior = false; // Are we inside the castle?

          // Keep track of objects that belong to "outside" so we can remove them
          this.outsideObjects = [];

          // Keep track of objects that belong to "inside" scene
          this.insideObjects = [];

          this.initScene();
          this.initKeyboardMouse();
          this.startAnimation();
        }

        initScene() {
          // Scene background color
          this.scene.background = new THREE.Color(0x87CEEB);

          // ... (Everything in the "outside" scene) ...
          // Ground
          const groundGeo = new THREE.PlaneGeometry(300, 300);
          const groundMat = new THREE.MeshStandardMaterial({ color: 0x6bb26b, side: THREE.DoubleSide });
          const ground = new THREE.Mesh(groundGeo, groundMat);
          ground.rotation.x = Math.PI / 2;
          this.scene.add(ground);
          this.outsideObjects.push(ground);

          // Rolling hills, boundary shrubs, beach, water, lighting, sun, moon, stars, etc...
          // (omitting re-paste for brevity, but same approach as before)
          // For brevity, we won't re-list all code. 
          // We'll just call helper methods that also push items to outsideObjects.

          this.createOutsideEnvironment(); // We'll define below
          this.createPlayerModel();        // The player is persistent
          this.createBuildingsAndNPCs();   // Castle, house, cafe, guard, mermaid, etc.
          this.createItems();              // Flowers, coins, gems, potions, keys, artifacts
          this.createPiazza();            // The central small area
          this.createPiazzaNPCs();
          this.createLampPosts();

          // Start camera behind player
          this.camera.position.set(this.player.x + 15, this.player.y + 15, this.player.z + 15);
          this.camera.lookAt(this.player.x, this.player.y + 1, this.player.z);
        }

        createOutsideEnvironment() {
          // e.g. lighting, sky objects, boundary shrubs, water, etc.
          // Similar to the previous code
          // ...
        }

        createBuildingsAndNPCs() {
          // Creates castle, house, cafe, fountain, guard, mermaid, bird, etc.
          // Also pushes them to outsideObjects, and to this.objects for collisions
          // ...
        }

        createItems() {
          // Creates flowers, coins, gems, potions, keys, artifacts
          // ...
        }

        // =========================
        // CASTLE INTERIOR
        // =========================
        createCastleInterior() {
          // 1) Large interior box, 3× bigger
          // We'll do 300×180×300, so the "floor" is at y=0 if we position the box so its center is at y=90
          const roomGeo = new THREE.BoxGeometry(300, 180, 300);
          const roomMat = new THREE.MeshStandardMaterial({ color: 0x999999, side: THREE.BackSide });
          const room = new THREE.Mesh(roomGeo, roomMat);
          // Center is at (0,0,0) by default; shift it so floor is at y=0 => center at y=90
          room.position.y = 90;
          this.scene.add(room);
          this.insideObjects.push(room);

          // 2) A point light in the ceiling
          const roomLight = new THREE.PointLight(0xffffff, 1.0, 600);
          roomLight.position.set(0, 160, 0); // near top of the interior
          this.scene.add(roomLight);
          this.insideObjects.push(roomLight);

          // 3) Exit door behind player (somewhere along one wall, e.g. z=-150/2 + small offset)
          // The box extends from -150..+150 in Z if centered at 0
          // We'll place the exit door at z=-149 (a bit inwards)
          const exitDoor = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 15),
            new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide })
          );
          // We'll place it so the bottom of door is near floor => door center at y=7.5 => plus the shift from box center => total y=7.5
          exitDoor.position.set(0, 7.5, -149);
          this.scene.add(exitDoor);
          this.insideObjects.push(exitDoor);

          // Optionally add a small overhead exit light
          const exitLight = new THREE.PointLight(0xffeeaa, 0.8, 20);
          exitLight.position.set(0, 12, -148);
          this.scene.add(exitLight);
          this.insideObjects.push(exitLight);
        }

        // ==============
        // ENTER / EXIT
        // ==============
        enterCastle() {
          this.interior = true;
          document.getElementById('location').textContent = "Castle Interior";

          // Remove all outside objects from scene
          for (let obj of this.outsideObjects) {
            this.scene.remove(obj);
          }

          // Create the inside scene
          this.createCastleInterior();

          // Place the player in the center of the interior
          this.player.x = 0;
          this.player.y = 1;
          this.player.z = 140; // near front wall, so you appear to have come in
          this.player.yaw = Math.PI; // facing the interior
          if (this.player.object) {
            this.player.object.position.set(this.player.x, this.player.y, this.player.z);
            this.player.object.rotation.y = this.player.yaw;
          }
        }

        exitCastle() {
          this.interior = false;
          document.getElementById('location').textContent = "Town";

          // Remove all inside objects
          for (let obj of this.insideObjects) {
            this.scene.remove(obj);
          }
          this.insideObjects = [];

          // Re-add outside objects
          for (let obj of this.outsideObjects) {
            this.scene.add(obj);
          }

          // Place the player a few steps away from the castle door outside
          this.player.x = 40;
          this.player.y = 0.5;
          this.player.z = 47; // ~7 steps away from the door at z=40+10=50 => so 47 is slightly back
          this.player.yaw = Math.PI; // facing outward from castle
          if (this.player.object) {
            this.player.object.position.set(this.player.x, this.player.y, this.player.z);
            this.player.object.rotation.y = this.player.yaw;
          }
        }

        // =========================
        // Standard updates
        // =========================
        startAnimation() {
          const animate = () => {
            requestAnimationFrame(animate);
            this.update();
            this.renderer.render(this.scene, this.camera);
          };
          animate();
        }

        update() {
          this.updateDayNight();
          this.updateBalls();
          this.updateGuard();
          this.updateMovement();
          this.updateBlueNPC();
          this.updateYellowNPC();
          this.updateMermaid();
          this.updateBird();
          this.updatePiazzaNPCs();
          this.updatePickups();
          this.updateCollisions();
          this.updateCamera();
        }

        updateMovement() {
          let keyboardForward = 0, keyboardTurn = 0;
          if (this.keysPressed['ArrowUp']) keyboardForward += 1;
          if (this.keysPressed['ArrowDown']) keyboardForward -= 1;
          if (this.keysPressed['ArrowLeft']) keyboardTurn += 1;
          if (this.keysPressed['ArrowRight']) keyboardTurn -= 1;

          let touchForward = 0, touchStrafe = 0;
          if (controllerState.dpadUp) touchForward += 1;
          if (controllerState.dpadDown) touchForward -= 1;
          if (controllerState.dpadLeft) touchStrafe += 1;
          if (controllerState.dpadRight) touchStrafe -= 1;

          let finalForward = (keyboardForward !== 0 ? keyboardForward : touchForward);
          let finalStrafe = touchStrafe;
          let finalTurn = keyboardTurn;
          if (controllerState.turnLeft) finalTurn += 1;
          if (controllerState.turnRight) finalTurn -= 1;

          // If outside, speed is baseSpeed * 2.5, else inside => baseSpeed
          const speedMult = this.interior ? 1.0 : 2.5;
          const forwardVec = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
          const rightVec = new THREE.Vector3(Math.cos(this.player.yaw), 0, -Math.sin(this.player.yaw));
          const movement = forwardVec.clone().multiplyScalar(finalForward)
                          .add(rightVec.clone().multiplyScalar(finalStrafe));
          if (movement.length() > 1) movement.normalize();
          movement.multiplyScalar(this.player.baseSpeed * speedMult);

          const newX = this.player.x + movement.x;
          const newZ = this.player.z + movement.z;
          let canMove = true;

          // If inside, no collisions with outside objects
          const collidableTypes = this.interior ? [] : ['building','boundary','decoration','npc','guard','mermaid'];
          for (const obj of this.objects) {
            if (collidableTypes.includes(obj.type)) {
              const dx = newX - obj.x;
              const dz = newZ - obj.z;
              const minDist = (obj.boundingRadius || 5) + 1;
              if ((dx*dx + dz*dz) < (minDist*minDist)) {
                canMove = false;
                break;
              }
            }
          }

          if (canMove) {
            this.player.x = newX;
            this.player.z = newZ;
          }

          this.player.yaw += finalTurn * 0.02;

          // Jump
          if (this.player.jumpVelocity !== 0 || this.player.y > 0.5) {
            this.player.jumpVelocity -= 0.02;
            this.player.y += this.player.jumpVelocity;
            if (this.player.y < 0.5) {
              this.player.y = 0.5;
              this.player.jumpVelocity = 0;
            }
          }

          if (this.player.object) {
            this.player.object.position.set(this.player.x, this.player.y, this.player.z);
            this.player.object.rotation.y = this.player.yaw;
          }

          if (finalForward !== 0 || finalStrafe !== 0) {
            this.animateArms(this.player.object, true);
          } else {
            this.animateArms(this.player.object, false);
          }
        }

        updateCollisions() {
          // Guard dialogue
          // ...
          // Blue NPC
          // ...
          // Piazza NPC
          // ...

          // If outside, check if near castle door to enter
          if (!this.interior) {
            const castleObj = this.objects.find(o => o.type==='building' && o.x===40 && o.z===40);
            if (castleObj) {
              const dx = this.player.x - castleObj.x;
              // door near z=castleObj.z+10 => ~50
              const dz = this.player.z - 50;
              if (dx*dx + dz*dz < 4) {
                this.enterCastle();
              }
            }
          } else {
            // If inside, check if near exit door at z=-149
            // We'll say x^2 + (z+149)^2 < 4 => close enough
            const dx = this.player.x;
            const dz = (this.player.z+149);
            if (dx*dx + dz*dz < 4) {
              this.exitCastle();
            }
          }
        }

        // (All the other standard updates like updateDayNight, updateBalls, etc. 
        //  remain the same as in previous code, except we changed dayNightCycle increment.)
        //  ...
        
        animateArms(obj, isMoving) {
          if (!obj) return;
          const t = Date.now() * 0.002;
          obj.traverse(child => {
            if (child.userData && child.userData.isArm) {
              if (isMoving) {
                if (child.userData.side === 'left') {
                  child.rotation.x = Math.sin(t) * 0.5;
                } else {
                  child.rotation.x = -Math.sin(t) * 0.5;
                }
              } else {
                child.rotation.x = 0;
              }
            }
          });
        }

        throwBall() {
          const direction = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
          const ballGeo = new THREE.SphereGeometry(0.3, 16, 16);
          const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4500 });
          const ball = new THREE.Mesh(ballGeo, ballMat);
          ball.position.set(this.player.x, this.player.y + 1, this.player.z);
          ball.userData = {
            velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0, 0.3, 0)),
            bounced: false,
            timer: 0
          };
          this.scene.add(ball);
          this.thrownBalls.push(ball);
          this.ballCount++;
          document.getElementById('ballCountValue').textContent = this.ballCount;
          this.showDialogue("Threw a magic ball!");
        }

        jump() {
          if (this.player.y <= 0.5) {
            this.player.jumpVelocity = 0.3;
            this.showDialogue("Jump!");
          }
        }

        showDialogue(text) {
          const dlg = document.getElementById('dialogue');
          dlg.style.display = 'block';
          dlg.textContent = text;
          setTimeout(() => {
            dlg.style.display = 'none';
            dlg.textContent = '';
          }, 1500);
        }

        showGuardPopup(text) {
          const popup = document.getElementById('guardPopup');
          popup.style.display = 'block';
          popup.textContent = text;
          setTimeout(() => {
            popup.style.display = 'none';
            popup.textContent = '';
          }, 2000);
        }

        initKeyboardMouse() {
          document.addEventListener('keydown', e => {
            this.keysPressed[e.key] = true;
            if (e.key === ' ') this.throwBall();
          });
          document.addEventListener('keyup', e => {
            this.keysPressed[e.key] = false;
          });

          document.addEventListener('mousedown', () => {
            try { document.body.requestPointerLock(); }
            catch (err) { console.warn('Pointer lock failed:', err); }
          });
          document.addEventListener('mousemove', evt => {
            if (document.pointerLockElement === document.body) {
              const movementX = evt.movementX || 0;
              const sensitivity = 0.001;
              this.player.yaw += movementX * sensitivity;
            }
          });
        }
      }

      window.game = new Game();
    } catch (err) {
      console.error('Error initializing the game:', err);
    }
  </script>
</body>
</html>
