<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Princess Donia’s Town - Enhanced 3D RPG</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-size: 16px;
        background: rgba(0,0,0,0.7);
        padding: 10px 20px; /* extra horizontal padding */
        border-radius: 5px;
        z-index: 10;
      }
      #ballCount {
        position: absolute;
        top: 10px;
        right: 10px;
        color: #fff;
        font-size: 16px;
        background: rgba(0,0,0,0.7);
        padding: 5px 20px;
        border-radius: 5px;
        z-index: 10;
      }
      #dialogue {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: #fff;
        font-size: 14px;
        background: rgba(0,0,0,0.7);
        padding: 10px 20px;
        border-radius: 5px;
        max-width: 600px;
        z-index: 10;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        color: #fff;
        font-size: 14px;
        background: rgba(0,0,0,0.7);
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 10;
      }
      #errorMessage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 20px;
        background: rgba(0,0,0,0.8);
        padding: 20px 40px; /* extra padding around text */
        border-radius: 5px;
        z-index: 20;
        display: none;
      }
      /* Joystick containers */
      #joystickLeft,
      #joystickRight {
        position: absolute;
        width: 15vw;
        height: 15vw;
        min-width: 80px;
        min-height: 80px;
        max-width: 100px;
        max-height: 100px;
        opacity: 0.5;
        z-index: 15;
      }
      #joystickLeft {
        bottom: 6vh;
        left: 2vw;
      }
      #joystickRight {
        bottom: 6vh;
        right: 2vw;
      }
      /* Large pop-up for guard / NPC / mermaid messages */
      #guardPopup {
        position: absolute;
        bottom: 50%;
        left: 50%;
        transform: translate(-50%, 50%);
        color: #fff;
        font-size: 48px; /* 3x bigger */
        font-family: 'Press Start 2P', monospace;
        background: rgba(0,0,0,0.8);
        border: 2px solid #fff;
        padding: 40px; /* more padding around text */
        border-radius: 5px;
        display: none;
        z-index: 50;
        text-align: center;
      }
    </style>
    <!-- Include Three.js and NippleJS from CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>

      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>

      <div id="ballCount">
        Balls Thrown: <span id="ballCountValue">0</span>
      </div>

      <div id="dialogue"></div>

      <div id="controls">
        Controls:<br>
        Joysticks/Arrow Keys: Move<br>
        Joysticks/Mouse: Look Around<br>
        Tap Center/Space: Throw Ball
      </div>

      <div id="joystickLeft"></div>
      <div id="joystickRight"></div>

      <div id="errorMessage">
        WebGL is not supported in your browser. Please use a modern browser.
      </div>

      <div id="guardPopup"></div> <!-- Large pop-up for messages -->
    </div>

    <script>
      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');

        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          throw new Error('WebGL not supported');
        }

        // Basic Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        gameCanvas.style.display = 'block';

        // We'll store references for the new NPC, etc.
        let npcBlueData = { angle: 0, speed: 0.001, radius: 120, object: null };
        let npcYellowData = { object: null, pathIndex: 0, speed: 0.03, target: null }; // We'll do building visits
        let birdData = { angle: 0, speed: 0.002, radius: 140, object: null };

        class Game {
          constructor() {
            // Game state
            this.scene = 'town';
            this.flowers = 0;
            this.coins = 0;
            this.gems = 0;
            this.potions = 0;
            this.keys = 0;
            this.artifacts = 0;
            this.health = 100;
            this.time = 'Day';
            this.dayNightCycle = 0;

            // Player
            this.player = {
              x: 0,
              z: 0,
              speedKeyboard: 0.1,
              speedJoystick: 0.05,
              yaw: 0,
              pitch: -0.2,
              object: null,
              lastMoveVec: new THREE.Vector3(1,0,0)
            };

            this.dialogue = '';
            this.dialogueTimer = 0;
            this.objects = [];
            this.buildingPositions = []; // We'll store building centers for the new NPC
            this.ballCount = 0;
            this.thrownBalls = [];
            this.collectionGlow = null;
            this.joystickLeft = null;
            this.joystickRight = null;
            this.keysPressed = {};
            this.sceneObj = scene;
            this.camera = camera;
            this.renderer = renderer;
            this.itemRange = 80;

            // For day/night toggles
            this.sunMesh = null;
            this.moonMesh = null;
            this.starsMesh = null;

            // Interactions
            this.guardObject = null;
            this.guardMessageShown = false;
            this.npcBlueMessageShown = false;
            this.npcYellowMessageShown = false;
            this.mermaidMessageShown = false;

            this.initScene();
            this.initJoysticks();
            this.initKeyboardMouse();
            this.startAnimation();
          }

          //=========================================
          // SCENE CREATION
          //=========================================
          initScene() {
            // Ground plane
            const groundGeo = new THREE.PlaneGeometry(300,300);
            const groundMat = new THREE.MeshStandardMaterial({
              color: 0x6bb26b,
              side: THREE.DoubleSide,
              roughness: 0.8,
              metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = Math.PI/2;
            this.sceneObj.add(ground);

            // Sky
            const skyGeo = new THREE.SphereGeometry(1000,60,40);
            const skyMat = new THREE.ShaderMaterial({
              uniforms: {
                topColor: { value: new THREE.Color(0x87ceeb) },
                bottomColor: { value: new THREE.Color(0x2f4f4f) },
                offset: { value: 0.5 },
                exponent: { value: 0.6 }
              },
              vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                  vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                  vWorldPosition = worldPosition.xyz;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                  float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
                  gl_FragColor = vec4(
                    mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)),
                    1.0
                  );
                }
              `,
              side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.name = 'sky';
            this.sceneObj.add(sky);

            // Lighting
            const ambient = new THREE.AmbientLight(0x404040, 0.6);
            this.sceneObj.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10,20,10);
            dirLight.castShadow = true;
            this.sceneObj.add(dirLight);

            // Rolling hills (large green semi-spheres) outside boundary
            this.createRollingHills();

            // Water, beach
            this.createBeach();
            // Characters
            this.createPlayerModel();
            this.createBlueNPC();
            this.createYellowNPC(); // new yellow NPC
            this.createGuardAtCastle();
            this.createMermaid();
            this.createBird();
            // Boundary
            this.createBoundary();
            // Buildings
            this.createCastle();
            this.createHouse();
            this.createFountain();
            this.createCafe();
            // Realistic shrubs/trees behind the house
            this.addShrubsAndTreesBehindHouse();

            // Items
            this.createFlowers(10);
            this.createCoins(8);
            this.createGems(4);
            this.createPotions(3);
            this.createKeys(2);
            this.createArtifacts(2);

            // Sun, moon, stars
            this.createSun();
            this.createMoon();
            this.createStars();
          }

          createRollingHills() {
            // We'll place 8 random big green semi-spheres outside ±150
            for (let i=0; i<8; i++) {
              const radius = 40 + Math.random()*30;
              const x = (Math.random()>0.5?1:-1)*(150 + Math.random()*200);
              const z = (Math.random()>0.5?1:-1)*(150 + Math.random()*200);
              const hillGeo = new THREE.SphereGeometry(radius,16,16,0,Math.PI*2,0,Math.PI/2); // half-sphere
              const hillMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness:0.9, metalness:0 });
              const hill = new THREE.Mesh(hillGeo, hillMat);
              hill.rotation.x = Math.PI; // flip so it's a dome
              hill.position.set(x, 0, z);
              this.sceneObj.add(hill);
            }
          }

          createBeach() {
            // Beach plane
            const beachGeo = new THREE.PlaneGeometry(300, 40);
            const beachMat = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
            const beach = new THREE.Mesh(beachGeo, beachMat);
            beach.rotation.x = -Math.PI/2;
            beach.position.set(0,0,-120);
            this.sceneObj.add(beach);
            this.objects.push({ mesh: beach, type:'beach', x:0, z:-120, boundingRadius:0 });

            // Water plane
            const waterGeo = new THREE.PlaneGeometry(300, 60);
            const waterMat = new THREE.MeshStandardMaterial({ color: 0x1E90FF, transparent:true, opacity:0.8 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI/2;
            water.position.set(0,0,-150);
            this.sceneObj.add(water);
            this.objects.push({ mesh: water, type:'water', x:0, z:-150, boundingRadius:0 });
          }

          createPlayerModel() {
            const group = new THREE.Group();
            // Body
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,1.2,16),
              new THREE.MeshStandardMaterial({ color: 0xff69b4 })
            );
            body.position.set(0,0.6,0);
            body.userData.isBodyPart = true;
            group.add(body);
            // Head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.4,0);
            head.userData.isBodyPart = true;
            group.add(head);
            // Hair (brown half-sphere)
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.28,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.35,0);
            hair.rotation.x = Math.PI;
            hair.userData.isBodyPart = true;
            group.add(hair);
            // Crown (thicker/taller)
            const crown = new THREE.Mesh(
              new THREE.TorusGeometry(0.25,0.09,8,16),
              new THREE.MeshStandardMaterial({ color: 0xffd700 })
            );
            crown.rotation.x = Math.PI/2;
            crown.position.set(0,1.65,0);
            group.add(crown);
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.8,8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5,1.0,0);
            leftArm.userData.isBodyPart = true;
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5,1.0,0);
            rightArm.userData.isBodyPart = true;
            group.add(rightArm);
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.12,0.12,0.8,8);
            const leftLeg = new THREE.Mesh(legGeo, skinMat);
            leftLeg.position.set(-0.2,0.2,0);
            leftLeg.userData.isBodyPart = true;
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, skinMat);
            rightLeg.position.set(0.2,0.2,0);
            rightLeg.userData.isBodyPart = true;
            group.add(rightLeg);

            group.position.set(0,0.5,0);
            this.player.object = group;
            this.sceneObj.add(group);
          }

          createMermaid() {
            const group = new THREE.Group();
            // Body
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,0.6,16),
              new THREE.MeshStandardMaterial({ color: 0xff69b4 })
            );
            body.position.set(0,0.9,0);
            group.add(body);
            // Head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.4,0);
            group.add(head);
            // Hair
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.28,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.35,0);
            hair.rotation.x = Math.PI;
            group.add(hair);
            // Submerge half
            group.position.set(20,-0.5,-150);
            this.sceneObj.add(group);
            // Add so we can check distance for pop-up
            this.objects.push({ mesh: group, type:'mermaid', x:20, z:-150, boundingRadius:3 });
          }

          createBird() {
            const bird = new THREE.Mesh(
              new THREE.SphereGeometry(0.5,8,8),
              new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            this.sceneObj.add(bird);
            birdData.object = bird;
          }

          createBlueNPC() {
            const group = new THREE.Group();
            // Body
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,1.2,16),
              new THREE.MeshStandardMaterial({ color: 0x0000ff })
            );
            body.position.set(0,0.6,0);
            group.add(body);
            // Head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.4,0);
            group.add(head);
            // Hair
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.28,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.35,0);
            hair.rotation.x = Math.PI;
            group.add(hair);
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.8,8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5,1.0,0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5,1.0,0);
            group.add(rightArm);
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.12,0.12,0.8,8);
            const leftLeg = new THREE.Mesh(legGeo, skinMat);
            leftLeg.position.set(-0.2,0.2,0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, skinMat);
            rightLeg.position.set(0.2,0.2,0);
            group.add(rightLeg);

            group.position.set(120,0.5,0);
            this.sceneObj.add(group);
            npcBlueData.object = group;
          }

          createYellowNPC() {
            // Similar to blue NPC but shorter, “yellow” body
            const group = new THREE.Group();
            // Body
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,1.0,16),
              new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            body.position.set(0,0.5,0);
            group.add(body);
            // Head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.28,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.1,0);
            group.add(head);
            // Hair
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.25,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.05,0);
            hair.rotation.x = Math.PI;
            group.add(hair);
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.6,8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5,0.8,0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5,0.8,0);
            group.add(rightArm);
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.12,0.12,0.6,8);
            const leftLeg = new THREE.Mesh(legGeo, skinMat);
            leftLeg.position.set(-0.2,0.0,0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, skinMat);
            rightLeg.position.set(0.2,0.0,0);
            group.add(rightLeg);

            group.position.set(-30,0.3,30);
            this.sceneObj.add(group);
            npcYellowData.object = group;

            // We'll define building visits after we create buildings
          }

          createGuardAtCastle() {
            const group = new THREE.Group();
            // Body
            const body = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4,0.5,1.2,16),
              new THREE.MeshStandardMaterial({ color: 0x000000 })
            );
            body.position.set(0,0.6,0);
            group.add(body);
            // Head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.3,16,16),
              new THREE.MeshStandardMaterial({ color: 0xffddc1 })
            );
            head.position.set(0,1.4,0);
            group.add(head);
            // Hair
            const hair = new THREE.Mesh(
              new THREE.SphereGeometry(0.28,16,16,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color: 0x553322 })
            );
            hair.position.set(0,1.35,0);
            hair.rotation.x = Math.PI;
            group.add(hair);
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.8,8);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-0.5,1.0,0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0.5,1.0,0);
            group.add(rightArm);
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.12,0.12,0.8,8);
            const leftLeg = new THREE.Mesh(legGeo, skinMat);
            leftLeg.position.set(-0.2,0.2,0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, skinMat);
            rightLeg.position.set(0.2,0.2,0);
            group.add(rightLeg);

            group.position.set(45,0.5,50.5);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type:'guard', x:45, z:50.5, boundingRadius:3 });
            this.guardObject = group;
          }

          createBoundary() {
            // We'll place boundary except behind the water. So let's do 3 sides
            for (let x=-130; x<=130; x+=4) {
              // front boundary
              this.addShrub(x,130);
              // left boundary
              this.addShrub(-130,x);
              // right boundary
              this.addShrub(130,x);
            }
            // We won't block behind the water
          }

          addShrub(x,z) {
            const geo = new THREE.CylinderGeometry(1,1,2,8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const shrub = new THREE.Mesh(geo, mat);
            shrub.position.set(x,1,z);
            this.sceneObj.add(shrub);
            this.objects.push({ mesh:shrub, type:'boundary', x, z, boundingRadius:2 });
          }

          createCastle() {
            const group = new THREE.Group();
            const keep = new THREE.Mesh(
              new THREE.BoxGeometry(20,10,20),
              new THREE.MeshStandardMaterial({ color: 0xcccccc })
            );
            keep.position.set(0,5,0);
            group.add(keep);
            const towerGeo = new THREE.CylinderGeometry(3,3,15,16);
            const towerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            [[10,7.5,10],[-10,7.5,10],[10,7.5,-10],[-10,7.5,-10]].forEach(pos => {
              const tower = new THREE.Mesh(towerGeo, towerMat);
              tower.position.set(pos[0],pos[1],pos[2]);
              group.add(tower);
            });
            const door = new THREE.Mesh(
              new THREE.PlaneGeometry(4,6),
              new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide })
            );
            door.position.set(0,3,10.01);
            group.add(door);

            // "Daddy's Castle" sign
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle='black';
            ctx.fillRect(0,0,512,128);
            ctx.fillStyle='white';
            ctx.font='60px Arial';
            ctx.fillText("Daddy's Castle",50,80);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate=true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex });
            const signGeo = new THREE.PlaneGeometry(12,3);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0,8,10.1);
            group.add(signMesh);

            group.position.set(40,0,40);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type:'building', x:40, z:40, boundingRadius:15 });
            this.buildingPositions.push({ x:40, z:40 });
          }

          createHouse() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(
              new THREE.BoxGeometry(10,6,8),
              new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            base.position.set(0,3,0);
            group.add(base);
            const roof = new THREE.Mesh(
              new THREE.ConeGeometry(6,4,4),
              new THREE.MeshStandardMaterial({ color: 0x800000 })
            );
            roof.position.set(0,7,0);
            roof.rotation.y = Math.PI/4;
            group.add(roof);

            const door = new THREE.Mesh(
              new THREE.PlaneGeometry(2,4),
              new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide })
            );
            door.position.set(0,2,4.01);
            group.add(door);

            // Windows
            const winGeo = new THREE.PlaneGeometry(1,1);
            const winMat = new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent:true, opacity:0.5, side: THREE.DoubleSide });
            const w1 = new THREE.Mesh(winGeo, winMat);
            w1.position.set(-2,3,4.02);
            const w2 = new THREE.Mesh(winGeo, winMat.clone());
            w2.position.set(2,3,4.02);
            group.add(w1,w2);

            // Smaller sign
            const canvas = document.createElement('canvas');
            canvas.width=128; canvas.height=32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle='black'; ctx.fillRect(0,0,128,32);
            ctx.fillStyle='white'; ctx.font='16px Arial';
            ctx.fillText("Donia's House",5,22);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate=true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent:true });
            const signGeo = new THREE.PlaneGeometry(4,1);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0,3.8,4.05);
            group.add(signMesh);

            group.position.set(-40,0,-40);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type:'building', x:-40, z:-40, boundingRadius:10 });
            this.buildingPositions.push({ x:-40, z:-40 });
          }

          createFountain() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(
              new THREE.CylinderGeometry(3,3,1,16),
              new THREE.MeshStandardMaterial({ color: 0x808080 })
            );
            base.position.set(0,0.5,0);
            group.add(base);
            const bowl = new THREE.Mesh(
              new THREE.TorusGeometry(3,0.3,16,32),
              new THREE.MeshStandardMaterial({ color: 0x808080 })
            );
            bowl.rotation.x = Math.PI/2;
            bowl.position.y = 1;
            group.add(bowl);
            const water = new THREE.Mesh(
              new THREE.CylinderGeometry(2.8,2.8,0.2,16),
              new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent:true, opacity:0.6 })
            );
            water.position.set(0,1.1,0);
            group.add(water);

            group.position.set(0,0,20);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type:'decoration', x:0, z:20, boundingRadius:5 });
          }

          createCafe() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(
              new THREE.BoxGeometry(10,5,8),
              new THREE.MeshStandardMaterial({ color: 0x888888 })
            );
            base.position.set(0,2.5,0);
            group.add(base);
            const door = new THREE.Mesh(
              new THREE.PlaneGeometry(2,3),
              new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide })
            );
            door.position.set(0,1.5,4.01);
            group.add(door);

            // "Donia's Cafe" sign
            const canvas = document.createElement('canvas');
            canvas.width=256; canvas.height=64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle='black'; ctx.fillRect(0,0,256,64);
            ctx.fillStyle='white'; ctx.font='30px Arial'; ctx.textAlign='center';
            ctx.fillText("Donia's Cafe",128,40);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate=true;
            const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent:true });
            const signGeo = new THREE.PlaneGeometry(8,2);
            const signMesh = new THREE.Mesh(signGeo, signMat);
            signMesh.position.set(0,3.5,4.05);
            group.add(signMesh);

            group.position.set(70,0,-30);
            this.sceneObj.add(group);
            this.objects.push({ mesh: group, type:'building', x:70, z:-30, boundingRadius:10 });
            this.buildingPositions.push({ x:70, z:-30 });
          }

          addShrubsAndTreesBehindHouse() {
            // We'll place random shrubs/trees behind the house at ~(-40, -40)
            const baseX = -40; 
            const baseZ = -40;
            for (let i=0; i<10; i++) {
              const offsetX = (Math.random()*10)-5; // random offset near house
              const offsetZ = (Math.random()*10)+2; // behind the house
              const x = baseX + offsetX;
              const z = baseZ - offsetZ;
              const isTree = Math.random() < 0.5; // half shrubs, half trees
              if (isTree) {
                // tree trunk + leaves
                const trunk = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.2,0.2,2,8),
                  new THREE.MeshStandardMaterial({ color: 0x8b4513 })
                );
                trunk.position.set(x,1,z);
                const leaves = new THREE.Mesh(
                  new THREE.SphereGeometry(1,8,8),
                  new THREE.MeshStandardMaterial({ color: 0x228b22 })
                );
                leaves.position.set(x,2,z);
                this.sceneObj.add(trunk, leaves);
                this.objects.push({ mesh: trunk, type:'decoration', x, z, boundingRadius:2 });
              } else {
                // shrub
                const shrub = new THREE.Mesh(
                  new THREE.SphereGeometry(1,8,8),
                  new THREE.MeshStandardMaterial({ color: 0x228b22 })
                );
                shrub.position.set(x,1,z);
                this.sceneObj.add(shrub);
                this.objects.push({ mesh: shrub, type:'decoration', x, z, boundingRadius:2 });
              }
            }
          }

          //=========================================
          // ITEMS
          //=========================================
          createFlowers(count) { /* same as previous, omitted for brevity */ }
          createCoins(count) { /* same as previous, omitted for brevity */ }
          createGems(count) { /* same as previous, omitted for brevity */ }
          createPotions(count) { /* same as previous, omitted for brevity */ }
          createKeys(count) { /* same as previous, omitted for brevity */ }
          createArtifacts(count) { /* same as previous, omitted for brevity */ }

          // For brevity, let's define them fully:
          createFlowers(count) {
            for (let i=0; i<count; i++){
              const fx = Math.random()*this.itemRange*2 - this.itemRange;
              const fz = Math.random()*this.itemRange*2 - this.itemRange;
              const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05,0.05,1,8),
                new THREE.MeshStandardMaterial({ color: 0x008000 })
              );
              stem.position.y=0.5;
              const bloom = new THREE.Mesh(
                new THREE.SphereGeometry(0.2,8,8),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
              );
              bloom.position.y=1;
              const flowerGroup=new THREE.Group();
              flowerGroup.add(stem,bloom);
              flowerGroup.position.set(fx,0,fz);
              this.sceneObj.add(flowerGroup);
              this.objects.push({ mesh:flowerGroup, type:'flower', isPickup:true, x:fx, z:fz });
            }
          }
          createCoins(count) {
            for(let i=0;i<count;i++){
              const cx = Math.random()*this.itemRange*2 - this.itemRange;
              const cz = Math.random()*this.itemRange*2 - this.itemRange;
              const coin = new THREE.Mesh(
                new THREE.CircleGeometry(0.3,16),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
              );
              coin.rotation.x=-Math.PI/2;
              coin.position.set(cx,0.01,cz);
              this.sceneObj.add(coin);
              this.objects.push({ mesh:coin, type:'coin', isPickup:true, x:cx, z:cz });
            }
          }
          createGems(count){
            for(let i=0;i<count;i++){
              const gx=Math.random()*this.itemRange*2-this.itemRange;
              const gz=Math.random()*this.itemRange*2-this.itemRange;
              const gem=new THREE.Mesh(
                new THREE.OctahedronGeometry(0.5,0),
                new THREE.MeshStandardMaterial({ color: 0x00ffff })
              );
              gem.position.set(gx,0.5,gz);
              this.sceneObj.add(gem);
              this.objects.push({ mesh:gem, type:'gem', isPickup:true, x:gx, z:gz });
            }
          }
          createPotions(count){
            for(let i=0;i<count;i++){
              const px=Math.random()*this.itemRange*2-this.itemRange;
              const pz=Math.random()*this.itemRange*2-this.itemRange;
              const base=new THREE.Mesh(
                new THREE.CylinderGeometry(0.3,0.3,0.8,16),
                new THREE.MeshStandardMaterial({ color:0xffffff })
              );
              base.position.y=0.4;
              const liquid=new THREE.Mesh(
                new THREE.CylinderGeometry(0.25,0.25,0.6,16),
                new THREE.MeshStandardMaterial({ color:0xff4500 })
              );
              liquid.position.y=0.4;
              const group=new THREE.Group();
              group.add(base,liquid);
              group.position.set(px,0,pz);
              this.sceneObj.add(group);
              this.objects.push({ mesh:group, type:'potion', isPickup:true, x:px, z:pz });
            }
          }
          createKeys(count){
            for(let i=0;i<count;i++){
              const kx=Math.random()*this.itemRange*2-this.itemRange;
              const kz=Math.random()*this.itemRange*2-this.itemRange;
              const handle=new THREE.Mesh(
                new THREE.SphereGeometry(0.2,16,16),
                new THREE.MeshStandardMaterial({ color:0xffd700 })
              );
              const shaft=new THREE.Mesh(
                new THREE.CylinderGeometry(0.1,0.1,0.8,8),
                new THREE.MeshStandardMaterial({ color:0xffd700 })
              );
              shaft.position.y=-0.4;
              const key=new THREE.Group();
              key.add(handle,shaft);
              key.position.set(kx,0.5,kz);
              key.rotation.x=Math.PI/2;
              this.sceneObj.add(key);
              this.objects.push({ mesh:key, type:'key', isPickup:true, x:kx, z:kz });
            }
          }
          createArtifacts(count){
            for(let i=0;i<count;i++){
              const ax=Math.random()*this.itemRange*2-this.itemRange;
              const az=Math.random()*this.itemRange*2-this.itemRange;
              const artifact=new THREE.Mesh(
                new THREE.SphereGeometry(0.5,16,16),
                new THREE.MeshStandardMaterial({ color:0x9400d3 })
              );
              const glow=new THREE.Mesh(
                new THREE.SphereGeometry(0.6,16,16),
                new THREE.MeshBasicMaterial({ color:0xffeb3b, transparent:true, opacity:0.5, side:THREE.BackSide })
              );
              const group=new THREE.Group();
              group.add(artifact,glow);
              group.position.set(ax,0.5,az);
              this.sceneObj.add(group);
              this.objects.push({ mesh:group, type:'artifact', isPickup:true, x:ax, z:az });
            }
          }

          //=========================================
          // DAY/NIGHT
          //=========================================
          createSun() {
            const sunGeo=new THREE.SphereGeometry(3,16,16);
            const sunMat=new THREE.MeshBasicMaterial({ color:0xffee00 });
            this.sunMesh=new THREE.Mesh(sunGeo,sunMat);
            this.sunMesh.position.set(0,200,-200);
            this.sunMesh.visible=true;
            this.sceneObj.add(this.sunMesh);
          }
          createMoon(){
            const moonGeo=new THREE.SphereGeometry(2,16,16);
            const moonMat=new THREE.MeshBasicMaterial({ color:0xcccccc });
            this.moonMesh=new THREE.Mesh(moonGeo,moonMat);
            this.moonMesh.position.set(-100,150,100);
            this.moonMesh.visible=false;
            this.sceneObj.add(this.moonMesh);
          }
          createStars(){
            const starCount=300;
            const positions=new Float32Array(starCount*3);
            for(let i=0;i<starCount;i++){
              const radius=300+Math.random()*200;
              const angle=Math.random()*Math.PI*2;
              const ySpread=Math.random()*200-50;
              positions[i*3]=Math.cos(angle)*radius;
              positions[i*3+1]=50+ySpread;
              positions[i*3+2]=Math.sin(angle)*radius;
            }
            const starGeo=new THREE.BufferGeometry();
            starGeo.setAttribute('position',new THREE.BufferAttribute(positions,3));
            const starMat=new THREE.PointsMaterial({ color:0xffffff, size:1.2 });
            const starField=new THREE.Points(starGeo,starMat);
            starField.visible=false;
            this.sceneObj.add(starField);
            this.starsMesh=starField;
          }
          updateDayNight(){
            this.dayNightCycle=(this.dayNightCycle+1)%1200;
            this.time=this.dayNightCycle<600?'Day':'Night';
            document.getElementById('time').textContent=this.time;
            if(this.sunMesh && this.moonMesh && this.starsMesh){
              if(this.time==='Day'){
                this.sunMesh.visible=true;
                this.moonMesh.visible=false;
                this.starsMesh.visible=false;
              } else {
                this.sunMesh.visible=false;
                this.moonMesh.visible=true;
                this.starsMesh.visible=true;
              }
            }
          }

          //=========================================
          // ANIMATION LOOP
          //=========================================
          startAnimation(){
            const animate=()=>{
              requestAnimationFrame(animate);
              this.update();
              this.renderer.render(this.sceneObj,this.camera);
            };
            animate();
          }

          // We’ll define building collision radius in “objects” array so balls can bounce
          update(){
            this.updateDayNight();
            this.updateBalls();
            this.updatePlayerMovement();
            this.updateBlueNPC();
            this.updateYellowNPC();
            this.updateBird();
            this.updateWaterRipples();
            this.updateCollisions();
            this.updateCamera();
            this.updatePickups();
          }

          //=========================================
          // BALLS
          //=========================================
          updateBalls(){
            for(let i=this.thrownBalls.length-1;i>=0;i--){
              const ball=this.thrownBalls[i];
              ball.position.add(ball.userData.velocity);
              ball.userData.velocity.y-=0.01; // gravity

              // Check water collision for splash
              const waterObj=this.objects.find(o=>o.type==='water');
              if(waterObj){
                const dxW=ball.position.x - waterObj.x;
                const dzW=ball.position.z - waterObj.z;
                if(Math.abs(dxW)<150 && Math.abs(dzW)<30 && ball.position.y<0.1){
                  // spawn a ripple ring
                  this.spawnRipple(ball.position.x, ball.position.z);
                }
              }

              // Check building collisions for bounce
              for(const obj of this.objects){
                if(obj.type==='building' || obj.type==='decoration'){
                  const dxB=ball.position.x - obj.x;
                  const dzB=ball.position.z - obj.z;
                  const distSq=dxB*dxB+dzB*dzB;
                  const r=(obj.boundingRadius||5);
                  if(distSq<r*r && ball.position.y<10){
                    // reflect velocity
                    const normal=new THREE.Vector3(dxB,0,dzB).normalize();
                    // reflection
                    const v=ball.userData.velocity.clone();
                    const dot=v.dot(normal);
                    const reflection=v.sub(normal.multiplyScalar(2*dot)).multiplyScalar(0.6);
                    ball.userData.velocity.copy(reflection);
                  }
                }
              }

              // Bounce off ground
              if(ball.position.y<0){
                if(!ball.userData.bounced){
                  ball.position.y=0;
                  ball.userData.velocity.y*=-0.7;
                  ball.userData.bounced=true;
                } else if(ball.position.y<-0.5){
                  // remove
                  this.sceneObj.remove(ball);
                  this.thrownBalls.splice(i,1);
                }
              }
            }
          }
          spawnRipple(x,z){
            const rippleGeo=new THREE.RingGeometry(0.2,0.4,16);
            const rippleMat=new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.5 });
            const ripple=new THREE.Mesh(rippleGeo, rippleMat);
            ripple.rotation.x=-Math.PI/2;
            ripple.position.set(x,0.05,z);
            this.sceneObj.add(ripple);
            setTimeout(()=>{ this.sceneObj.remove(ripple); },1000);
          }

          //=========================================
          // PLAYER
          //=========================================
          updatePlayerMovement(){
            let dx=0, dz=0;
            const isKey=this.keysPressed['ArrowUp']||this.keysPressed['ArrowDown']||this.keysPressed['ArrowLeft']||this.keysPressed['ArrowRight'];
            const speed=isKey?this.player.speedKeyboard:this.player.speedJoystick;
            if(this.keysPressed['ArrowUp']) dz-=speed;
            if(this.keysPressed['ArrowDown']) dz+=speed;
            if(this.keysPressed['ArrowLeft']) dx-=speed;
            if(this.keysPressed['ArrowRight']) dx+=speed;
            if(dx!==0||dz!==0){
              this.player.lastMoveVec.set(dx,0,dz);
            }

            const newX=this.player.x + dx*Math.cos(this.player.yaw)+dz*Math.sin(this.player.yaw);
            const newZ=this.player.z - dx*Math.sin(this.player.yaw)+dz*Math.cos(this.player.yaw);
            // collision with buildings, boundary, etc
            let blocked=false;
            for(const obj of this.objects){
              if(obj.type==='beach' || obj.type==='water') continue; // can walk
              if(obj.type==='building'||obj.type==='boundary'||obj.type==='decoration'){
                const dxObj=newX-obj.x; const dzObj=newZ-obj.z;
                const distSq=dxObj*dxObj+dzObj*dzObj;
                const r=(obj.boundingRadius||5);
                if(distSq<r*r){
                  blocked=true; break;
                }
              }
            }
            if(!blocked){
              this.player.x=newX;
              this.player.z=newZ;
            }
            this.player.object.position.set(this.player.x,0.5,this.player.z);
            this.player.object.rotation.y=-this.player.yaw;

            // Walking animation
            const moving=dx!==0||dz!==0||(this.joystickLeft && this.joystickLeft.active);
            if(moving){
              this.player.object.traverse(child=>{
                if(child.isMesh&&child.userData.isBodyPart){
                  child.rotation.z=Math.sin(Date.now()*0.005)*0.1;
                }
              });
            } else {
              this.player.object.traverse(child=>{
                if(child.isMesh&&child.userData.isBodyPart){
                  child.rotation.set(0,0,0);
                }
              });
            }
          }
          updateCamera(){
            const camDist=15;
            const offsetX=camDist*Math.sin(this.player.yaw)*Math.cos(this.player.pitch);
            const offsetZ=camDist*Math.cos(this.player.yaw)*Math.cos(this.player.pitch);
            const offsetY=camDist*Math.sin(this.player.pitch)+15;
            this.camera.position.set(this.player.x+offsetX, offsetY, this.player.z+offsetZ);
            this.camera.lookAt(this.player.x,3.5,this.player.z);
          }

          //=========================================
          // NPCS
          //=========================================
          updateBlueNPC(){
            npcBlueData.angle+=npcBlueData.speed;
            const npcX=npcBlueData.radius*Math.cos(npcBlueData.angle);
            const npcZ=npcBlueData.radius*Math.sin(npcBlueData.angle);
            if(npcBlueData.object){
              npcBlueData.object.position.set(npcX,0.5,npcZ);
              npcBlueData.object.rotation.y=-npcBlueData.angle;
            }
          }
          updateYellowNPC(){
            // We'll have it walk building to building in sequence
            if(!npcYellowData.object) return;
            if(!npcYellowData.target){
              // pick a building from buildingPositions
              npcYellowData.pathIndex=(npcYellowData.pathIndex+1)%this.buildingPositions.length;
              npcYellowData.target=this.buildingPositions[npcYellowData.pathIndex];
            }
            const dx=npcYellowData.target.x - npcYellowData.object.position.x;
            const dz=npcYellowData.target.z - npcYellowData.object.position.z;
            const distSq=dx*dx+dz*dz;
            if(distSq<1){
              // arrived, pick next
              npcYellowData.pathIndex=(npcYellowData.pathIndex+1)%this.buildingPositions.length;
              npcYellowData.target=this.buildingPositions[npcYellowData.pathIndex];
            } else {
              // move
              const angle=Math.atan2(-dx,dz);
              npcYellowData.object.rotation.y=angle;
              const step=npcYellowData.speed;
              npcYellowData.object.position.x+=Math.sin(angle)*step;
              npcYellowData.object.position.z+=Math.cos(angle)*step;
            }
          }

          updateBird(){
            if(birdData.object){
              birdData.angle+=birdData.speed;
              const bx=birdData.radius*Math.cos(birdData.angle);
              const bz=birdData.radius*Math.sin(birdData.angle);
              birdData.object.position.set(bx,60,bz);
              birdData.object.rotation.y=-birdData.angle;
            }
          }

          //=========================================
          // WATER
          //=========================================
          updateWaterRipples(){
            // If player's in water, spawn ring
            const waterObj=this.objects.find(o=>o.type==='water');
            if(!waterObj) return;
            const dxW=this.player.x-waterObj.x;
            const dzW=this.player.z-waterObj.z;
            // plane is 300 wide, 60 tall => ±150 in x, ±30 in z
            if(Math.abs(dxW)<150 && Math.abs(dzW)<30 && Math.abs(this.player.object.position.y)<0.2){
              // spawn a ripple ring
              this.spawnRipple(this.player.x,this.player.z);
            }
          }

          //=========================================
          // COLLISIONS
          //=========================================
          updateCollisions(){
            // Guard text
            if(this.guardObject && !this.guardMessageShown){
              const dxG=this.player.x-this.guardObject.position.x;
              const dzG=this.player.z-this.guardObject.position.z;
              const distG=Math.sqrt(dxG*dxG+dzG*dzG);
              if(distG<5){
                this.showGuardPopup("I'm the guard of this castle. Please show your ID.");
              }
            }
            // Blue NPC text
            if(npcBlueData.object && !this.npcBlueMessageShown){
              const dxN=this.player.x-npcBlueData.object.position.x;
              const dzN=this.player.z-npcBlueData.object.position.z;
              const distN=Math.sqrt(dxN*dxN+dzN*dzN);
              if(distN<5){
                this.showGuardPopup("Hello Princess Donia!");
                this.npcBlueMessageShown=true;
                setTimeout(()=>{ this.npcBlueMessageShown=false; },2500);
              }
            }
            // Mermaid text
            if(!this.mermaidMessageShown){
              const mermaidObj=this.objects.find(o=>o.type==='mermaid');
              if(mermaidObj){
                const dxM=this.player.x-mermaidObj.x;
                const dzM=this.player.z-mermaidObj.z;
                const distM=Math.sqrt(dxM*dxM+dzM*dzM);
                if(distM<5){
                  this.showGuardPopup("Hello Princess Donia. It's me the Mermaid.");
                  this.mermaidMessageShown=true;
                  setTimeout(()=>{ this.mermaidMessageShown=false; },2500);
                }
              }
            }
          }

          //=========================================
          // PICKUPS
          //=========================================
          updatePickups(){
            // see update code for collisions
          }

          //=========================================
          // UTILITY
          //=========================================
          showDialogue(text){
            this.dialogue=text;
            document.getElementById('dialogue').textContent=text;
          }
          showGuardPopup(text){
            const popup=document.getElementById('guardPopup');
            popup.style.display='block';
            popup.textContent=text;
            this.guardMessageShown=true;
            setTimeout(()=>{
              popup.style.display='none';
              popup.textContent='';
              this.guardMessageShown=false;
            },2000);
          }
          throwBall(){
            let direction=new THREE.Vector3();
            if(this.player.lastMoveVec.lengthSq()>0.001){
              direction.copy(this.player.lastMoveVec).normalize();
            } else {
              direction.set(Math.cos(this.player.yaw),0,Math.sin(this.player.yaw)).normalize();
            }
            const ballGeo=new THREE.SphereGeometry(0.3,16,16);
            const ballMat=new THREE.MeshStandardMaterial({ color:0xff4500 });
            const ball=new THREE.Mesh(ballGeo,ballMat);
            ball.position.copy(this.player.object.position);
            ball.position.y+=1;
            ball.userData={
              velocity:direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
              bounced:false
            };
            this.sceneObj.add(ball);
            this.thrownBalls.push(ball);
            this.ballCount++;
            document.getElementById('ballCountValue').textContent=this.ballCount;
            this.showDialogue("Threw a magic ball!");
          }
          spawnRipple(x,z){
            const rippleGeo=new THREE.RingGeometry(0.2,0.4,16);
            const rippleMat=new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.5 });
            const ripple=new THREE.Mesh(rippleGeo,rippleMat);
            ripple.rotation.x=-Math.PI/2;
            ripple.position.set(x,0.05,z);
            this.sceneObj.add(ripple);
            setTimeout(()=>{ this.sceneObj.remove(ripple); },1000);
          }
          startCollectionGlow(){
            if(this.collectionGlow) this.sceneObj.remove(this.collectionGlow);
            const glowGeo=new THREE.SphereGeometry(1,16,16);
            const glowMat=new THREE.MeshBasicMaterial({ color:0xffff00, transparent:true, opacity:0.5, side:THREE.BackSide });
            const glow=new THREE.Mesh(glowGeo,glowMat);
            glow.position.copy(this.player.object.position);
            glow.position.y+=0.5;
            this.sceneObj.add(glow);
            this.collectionGlow=glow;
            setTimeout(()=>{
              if(this.collectionGlow){
                this.sceneObj.remove(this.collectionGlow);
                this.collectionGlow=null;
              }
            },1000);
          }

          initJoysticks(){
            this.joystickLeft=nipplejs.create({
              zone:document.getElementById('joystickLeft'),
              mode:'static',
              color:'white',
              size:100,
              position:{ left:'2vw', bottom:'6vh' }
            });
            this.joystickLeft.on('move',(evt,data)=>{
              if(data && data.force>0){
                const angle=data.angle.radian;
                const speed=data.force*this.player.speedJoystick;
                const dx=Math.cos(angle)*speed;
                const dz=Math.sin(angle)*speed;
                const newX=this.player.x+dx;
                const newZ=this.player.z-dz;
                let blocked=false;
                for(const obj of this.objects){
                  if(obj.type==='building'||obj.type==='wall'||obj.type==='boundary'||obj.type==='decoration'){
                    const dxObj=newX-obj.x;
                    const dzObj=newZ-obj.z;
                    const distSq=dxObj*dxObj+dzObj*dzObj;
                    const r=(obj.boundingRadius||5);
                    if(distSq<r*r){ blocked=true; break; }
                  }
                }
                if(!blocked){
                  this.player.x=newX; this.player.z=newZ;
                }
                this.joystickLeft.active=true;
              }
            });
            this.joystickLeft.on('end',()=>{ this.joystickLeft.active=false; });

            this.joystickRight=nipplejs.create({
              zone:document.getElementById('joystickRight'),
              mode:'static',
              color:'white',
              size:100,
              position:{ right:'2vw', bottom:'6vh' }
            });
            this.joystickRight.on('move',(evt,data)=>{
              if(data && data.force>0){
                const sensitivity=0.001;
                this.player.yaw+=data.vector.x*sensitivity*data.force;
                this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch+data.vector.y*sensitivity*data.force));
              }
            });
            this.joystickRight.on('end',()=>{});

            // Tap center to throw ball
            document.getElementById('gameContainer').addEventListener('click', e=>{
              const rect=e.target.getBoundingClientRect();
              const x=e.clientX-rect.left;
              const y=e.clientY-rect.top;
              if(x>rect.width/4 && x<(rect.width*3)/4 && y>rect.height/4 && y<(rect.height*3)/4){
                this.throwBall();
              }
            });
          }

          initKeyboardMouse(){
            document.addEventListener('keydown',e=>{
              this.keysPressed[e.key]=true;
              if(e.key===' ') this.throwBall();
            });
            document.addEventListener('keyup',e=>{
              this.keysPressed[e.key]=false;
            });
            document.addEventListener('mousedown',()=>{
              document.body.requestPointerLock();
            });
            document.addEventListener('mousemove',event=>{
              if(document.pointerLockElement===document.body){
                const movementX=event.movementX||0;
                const movementY=event.movementY||0;
                const sensitivity=0.001;
                this.player.yaw+=movementX*sensitivity;
                this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch+movementY*sensitivity));
              }
            });
          }
        }

        const game=new Game();

      } catch (error) {
        console.error('Error initializing the game:', error);
      }
    </script>
  </body>
</html>
