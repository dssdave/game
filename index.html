<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Simplified Princess Donia Town</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }
      /* UI boxes */
      #ui,
      #ballCount,
      #dialogue,
      #controls,
      #errorMessage,
      #guardPopup {
        background: rgba(0,0,0,0.7);
        border: 4px solid #fff;
        border-radius: 5px;
        color: #fff;
        font-size: 28px;
        padding: 40px 80px;
      }
      #ui,
      #ballCount,
      #dialogue,
      #controls {
        position: absolute;
        z-index: 10;
      }
      #ui { top: 10px; left: 10px; }
      #ballCount { top: 10px; right: 10px; }
      #dialogue { bottom: 10px; left: 10px; max-width: 600px; }
      #controls { bottom: 10px; right: 10px; }
      #errorMessage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        display: none;
        z-index: 20;
      }
      #guardPopup {
        position: absolute;
        bottom: 50%;
        left: 50%;
        transform: translate(-50%,50%);
        display: none;
        z-index: 50;
        text-align: center;
      }
      /* Joysticks: static corners */
      #joystickLeft,
      #joystickRight {
        position: absolute;
        width: 80px;
        height: 80px;
        opacity: 0.5;
        z-index: 15;
      }
      #joystickLeft { bottom: 10vh; left: 6vw; }
      #joystickRight { bottom: 10vh; right: 6vw; }
      /* Toggle UI button: top center */
      #toggleUIBtn {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 11;
        font-size: 24px;
        padding: 10px 20px;
        background: #333;
        color: #fff;
        border: 2px solid #fff;
        border-radius: 5px;
        cursor: pointer;
      }
      /* Reorient button: bottom center */
      #reorientBtn {
        position: absolute;
        bottom: 16vh;
        left: 50%;
        transform: translateX(-50%);
        width: 60px; height: 60px;
        border-radius: 50%;
        background: #666;
        color: #fff;
        border: 2px solid #fff;
        text-align: center;
        line-height: 60px;
        font-size: 20px;
        z-index: 12;
        cursor: pointer;
      }
      /* Smaller UI on narrow screens */
      @media (max-width: 768px) {
        #ui,
        #ballCount,
        #dialogue,
        #controls,
        #guardPopup,
        #errorMessage {
          font-size: 16px;
          padding: 20px 30px;
        }
        #toggleUIBtn,
        #reorientBtn {
          font-size: 16px;
          width: 50px; height: 50px; line-height: 50px;
        }
        #joystickLeft,
        #joystickRight {
          width: 60px; height: 60px;
        }
      }
    </style>

    <!-- Three.js + NippleJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  </head>

  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>

      <button id="toggleUIBtn">Toggle UI</button>
      <button id="reorientBtn">↺</button>

      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>
      <div id="ballCount">
        Balls Thrown: <span id="ballCountValue">0</span>
      </div>
      <div id="dialogue"></div>
      <div id="controls">
        Controls:<br>
        Joysticks/Arrow Keys: Move<br>
        Joysticks/Mouse: Look Around<br>
        Tap Center/Space: Throw Ball
      </div>

      <div id="joystickLeft"></div>
      <div id="joystickRight"></div>

      <div id="errorMessage">
        WebGL not supported in your browser. Please use a modern browser.
      </div>

      <div id="guardPopup"></div>
    </div>

    <script>
      // Toggle UI
      document.getElementById('toggleUIBtn').addEventListener('click', () => {
        for (let id of ["ui","ballCount","dialogue","controls","guardPopup","errorMessage"]) {
          const el = document.getElementById(id);
          if (el.style.display === "none") el.style.display = "block";
          else el.style.display = "none";
        }
      });

      // Gracefully handle pointer lock security error
      window.addEventListener('unhandledrejection', e => {
        if (e.reason && e.reason.name === 'SecurityError') {
          console.warn('Pointer lock security error ignored:', e.reason);
          e.preventDefault();
        }
      });

      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');
        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          throw new Error('WebGL not supported');
        }

        // Basic Three.js
        const scene = new THREE.Scene();
        // Place camera at (0,20,50) so you see the town from above
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0,20,50);
        camera.lookAt(0,0,0);

        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameCanvas.style.display = 'block';

        // Minimal color background
        renderer.setClearColor(0x87ceeb,1); // a sky-blue color

        // Data for NPCs
        let npcBlueData = { angle:0, speed:0.001, radius:20, object:null };
        let npcYellowData = { object:null, pathIndex:0, speed:0.02, target:null };
        let mermaidData = { object:null, route:[{x:-15,z:-25},{x:15,z:-25}], routeIndex:0, speed:0.02, splashTimer:0 };
        let guardData = {
          object:null,
          state:'idle',
          timer:0,
          route:[{x:-10,z:10},{x:-10,z:20},{x:10,z:20},{x:10,z:10},{x:0,z:10}],
          routeIndex:0,
          speed:0.03
        };

        class Game {
          constructor() {
            this.scene = scene;
            this.camera = camera;
            this.renderer = renderer;

            // Player
            this.player = {
              x:0, z:0,
              speedKeyboard:0.1,
              speedJoystick:0.06,
              yaw:0, pitch:0,
              object:null,
              lastMoveVec:new THREE.Vector3(0,0,0),
              waterSplashTimer:0
            };

            // Track items, objects
            this.objects=[];
            this.buildingPositions=[];
            this.ballCount=0;
            this.thrownBalls=[];
            this.collectionGlow=null;
            this.joystickLeft=null;
            this.joystickRight=null;
            this.keysPressed={};

            // For NPC states
            this.npcBlueData = npcBlueData;
            this.npcYellowData = npcYellowData;
            this.mermaidData = mermaidData;
            this.guardData = guardData;

            // UI
            this.flowers=0; this.coins=0; this.gems=0; this.potions=0; this.keys=0; this.artifacts=0;
            this.health=100; 
            // Hardcode "Day" in UI for now
            this.time='Day';
            document.getElementById('time').textContent=this.time;

            // Initialize scene
            this.initScene();
            this.initJoysticks();
            this.initKeyboardMouse();
            this.startAnimation();
          }

          initScene(){
            // Basic ground
            const groundGeo=new THREE.PlaneGeometry(100,100);
            const groundMat=new THREE.MeshStandardMaterial({ color:0x6bb26b, side:THREE.DoubleSide });
            const ground=new THREE.Mesh(groundGeo,groundMat);
            ground.rotation.x=-Math.PI/2;
            this.scene.add(ground);

            // Minimal ambient & directional
            const ambient=new THREE.AmbientLight(0x404040,0.6);
            this.scene.add(ambient);
            const dirLight=new THREE.DirectionalLight(0xffffff,0.8);
            dirLight.position.set(10,20,10);
            this.scene.add(dirLight);

            // Create a boundary around ±50
            this.createBoundary();

            // Player
            this.createPlayerModel();

            // Buildings
            this.createCastle();
            this.createHouse();
            this.createCafe();
            this.createFountain();

            // NPCs
            this.createBlueNPC();
            this.createYellowNPC();
            this.createGuardAtCastle();
            this.createMermaid();
          }

          /* Minimal boundary at ±50 */
          createBoundary(){
            for(let x=-50;x<=50;x+=4){
              this.addShrub(x,-50);
              this.addShrub(x,50);
            }
            for(let z=-50;z<=50;z+=4){
              this.addShrub(-50,z);
              this.addShrub(50,z);
            }
          }
          addShrub(x,z){
            const geo=new THREE.CylinderGeometry(1,1,2,8);
            const mat=new THREE.MeshStandardMaterial({ color:0x228b22 });
            const shrub=new THREE.Mesh(geo,mat);
            shrub.position.set(x,1,z);
            this.scene.add(shrub);
            this.objects.push({ mesh:shrub, type:'boundary', x, z, boundingRadius:2 });
          }

          createPlayerModel(){
            const group=new THREE.Group();
            // Body
            const body=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16), new THREE.MeshStandardMaterial({ color:0xff69b4 }));
            body.position.set(0,0.6,0);
            body.userData={ isBodyPart:true };
            group.add(body);
            // Head
            const head=new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({ color:0xffddc1 }));
            head.position.set(0,1.4,0);
            head.userData={ isBodyPart:true };
            group.add(head);
            // Hair
            const hair=new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16), new THREE.MeshStandardMaterial({ color:0x4b2e05 }));
            hair.position.set(0,1.75,0);
            group.add(hair);
            // Crown
            const crown=new THREE.Mesh(new THREE.TorusGeometry(0.25,0.09,8,16), new THREE.MeshStandardMaterial({ color:0xffd700 }));
            crown.rotation.x=Math.PI/2;
            crown.position.set(0,1.95,0);
            group.add(crown);
            // Arms
            const armGeo=new THREE.CylinderGeometry(0.1,0.1,0.8,8);
            const skinMat=new THREE.MeshStandardMaterial({ color:0xffddc1 });
            const leftArm=new THREE.Mesh(armGeo,skinMat);
            leftArm.position.set(-0.5,1.0,0);
            leftArm.userData={ isBodyPart:true };
            group.add(leftArm);
            const rightArm=new THREE.Mesh(armGeo,skinMat);
            rightArm.position.set(0.5,1.0,0);
            rightArm.userData={ isBodyPart:true };
            group.add(rightArm);
            // Legs
            const legGeo=new THREE.CylinderGeometry(0.12,0.12,0.8,8);
            const leftLeg=new THREE.Mesh(legGeo,skinMat);
            leftLeg.position.set(-0.2,0.2,0);
            leftLeg.userData={ isBodyPart:true };
            group.add(leftLeg);
            const rightLeg=new THREE.Mesh(legGeo,skinMat);
            rightLeg.position.set(0.2,0.2,0);
            rightLeg.userData={ isBodyPart:true };
            group.add(rightLeg);

            group.position.set(0,0,0); // center of map
            this.player.object=group;
            this.scene.add(group);
          }

          createCastle(){
            // Just a small box for demonstration
            const group=new THREE.Group();
            const base=new THREE.Mesh(new THREE.BoxGeometry(6,4,6), new THREE.MeshStandardMaterial({ color:0xcccccc }));
            base.position.set(0,2,0);
            group.add(base);
            // Door
            const door=new THREE.Mesh(new THREE.PlaneGeometry(2,3), new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
            door.position.set(0,1,3.01);
            group.add(door);
            // Label
            const canvas=document.createElement('canvas');
            canvas.width=256; canvas.height=64;
            const ctx=canvas.getContext('2d');
            ctx.fillStyle='black'; ctx.fillRect(0,0,256,64);
            ctx.fillStyle='white'; ctx.font='30px Arial';
            ctx.fillText("Castle",50,40);
            const tex=new THREE.Texture(canvas);
            tex.needsUpdate=true;
            const sign=new THREE.Mesh(new THREE.PlaneGeometry(4,1), new THREE.MeshBasicMaterial({ map:tex, transparent:true }));
            sign.position.set(0,3,3.05);
            group.add(sign);

            group.position.set(-10,0,10);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'building', x:-10, z:10, boundingRadius:4 });
            this.buildingPositions.push({ x:-10, z:10 });
          }
          createHouse(){
            const group=new THREE.Group();
            const base=new THREE.Mesh(new THREE.BoxGeometry(6,4,6), new THREE.MeshStandardMaterial({ color:0x8b4513 }));
            base.position.set(0,2,0);
            group.add(base);
            const roof=new THREE.Mesh(new THREE.ConeGeometry(4,3,4), new THREE.MeshStandardMaterial({ color:0x800000 }));
            roof.position.set(0,4,0);
            group.add(roof);
            // Door
            const door=new THREE.Mesh(new THREE.PlaneGeometry(2,3), new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
            door.position.set(0,1,3.01);
            group.add(door);
            // Label
            const canvas=document.createElement('canvas');
            canvas.width=256; canvas.height=64;
            const ctx=canvas.getContext('2d');
            ctx.fillStyle='black'; ctx.fillRect(0,0,256,64);
            ctx.fillStyle='white'; ctx.font='30px Arial';
            ctx.fillText("House",80,40);
            const tex=new THREE.Texture(canvas);
            tex.needsUpdate=true;
            const sign=new THREE.Mesh(new THREE.PlaneGeometry(4,1), new THREE.MeshBasicMaterial({ map:tex, transparent:true }));
            sign.position.set(0,3,3.05);
            group.add(sign);

            group.position.set(10,0,10);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'building', x:10, z:10, boundingRadius:4 });
            this.buildingPositions.push({ x:10, z:10 });
          }
          createCafe(){
            const group=new THREE.Group();
            const base=new THREE.Mesh(new THREE.BoxGeometry(6,4,6), new THREE.MeshStandardMaterial({ color:0x888888 }));
            base.position.set(0,2,0);
            group.add(base);
            // Door
            const door=new THREE.Mesh(new THREE.PlaneGeometry(2,3), new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
            door.position.set(0,1,3.01);
            group.add(door);
            // Label
            const canvas=document.createElement('canvas');
            canvas.width=256; canvas.height=64;
            const ctx=canvas.getContext('2d');
            ctx.fillStyle='black'; ctx.fillRect(0,0,256,64);
            ctx.fillStyle='white'; ctx.font='30px Arial'; ctx.fillText("Cafe",90,40);
            const tex=new THREE.Texture(canvas);
            tex.needsUpdate=true;
            const sign=new THREE.Mesh(new THREE.PlaneGeometry(4,1), new THREE.MeshBasicMaterial({ map:tex, transparent:true }));
            sign.position.set(0,3,3.05);
            group.add(sign);

            group.position.set(10,0,-10);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'building', x:10, z:-10, boundingRadius:4 });
            this.buildingPositions.push({ x:10, z:-10 });
          }
          createFountain(){
            const group=new THREE.Group();
            const base=new THREE.Mesh(new THREE.CylinderGeometry(2,2,1,16), new THREE.MeshStandardMaterial({ color:0x808080 }));
            base.position.set(0,0.5,0);
            group.add(base);
            const water=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,0.2,16), new THREE.MeshStandardMaterial({ color:0x00ffff, transparent:true, opacity:0.6 }));
            water.position.set(0,1,0);
            group.add(water);

            group.position.set(-10,0,-10);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'decoration', x:-10, z:-10, boundingRadius:3 });
            this.buildingPositions.push({ x:-10, z:-10 });
          }

          createBlueNPC(){
            const group=new THREE.Group();
            const body=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16), new THREE.MeshStandardMaterial({ color:0x0000ff }));
            body.position.set(0,0.6,0);
            group.add(body);
            const head=new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({ color:0xffddc1 }));
            head.position.set(0,1.4,0);
            group.add(head);
            // place near origin
            group.position.set(0,0,5);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'npc', x:0, z:5, boundingRadius:1 });
            this.npcBlueData.object=group;
          }
          createYellowNPC(){
            const group=new THREE.Group();
            const body=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.0,16), new THREE.MeshStandardMaterial({ color:0xffff00 }));
            body.position.set(0,0.5,0);
            group.add(body);
            const head=new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({ color:0xffddc1 }));
            head.position.set(0,1.1,0);
            group.add(head);

            group.position.set(0,0,-5);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'npc', x:0, z:-5, boundingRadius:1 });
            this.npcYellowData.object=group;
          }
          createGuardAtCastle(){
            const group=new THREE.Group();
            const body=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16), new THREE.MeshStandardMaterial({ color:0x000000 }));
            body.position.set(0,0.6,0);
            group.add(body);
            const head=new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({ color:0xffddc1 }));
            head.position.set(0,1.4,0);
            group.add(head);

            group.position.set(-10,0,10);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'guard', x:-10, z:10, boundingRadius:2 });
            this.guardData.object=group;
          }
          createMermaid(){
            const group=new THREE.Group();
            const body=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,0.6,16), new THREE.MeshStandardMaterial({ color:0xff69b4 }));
            body.position.set(0,0.9,0);
            group.add(body);
            const head=new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({ color:0xffddc1 }));
            head.position.set(0,1.4,0);
            group.add(head);
            group.position.set(-15,0,-25);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'mermaid', x:-15, z:-25, boundingRadius:1 });
            this.mermaidData.object=group;
          }

          startAnimation(){
            const animate=()=>{
              requestAnimationFrame(animate);
              this.update();
              this.renderer.render(this.scene,this.camera);
            };
            animate();
          }
          update(){
            // minimal updates
            this.updateBalls();
            this.updatePlayer();
            this.updateBlueNPC();
            this.updateYellowNPC();
            this.updateMermaid();
            this.updateGuardPatrol();
            this.updateCollisions();
            this.updatePickups();
          }
          updateBalls(){
            for(let i=this.thrownBalls.length-1;i>=0;i--){
              const ball=this.thrownBalls[i];
              ball.position.add(ball.userData.velocity);
              ball.userData.velocity.y-=0.01;
              // ground bounce
              if(ball.position.y<0){
                if(!ball.userData.bounced){
                  ball.position.y=0;
                  ball.userData.velocity.y*=-0.7;
                  ball.userData.bounced=true;
                } else if(ball.position.y<-0.5){
                  this.scene.remove(ball);
                  this.thrownBalls.splice(i,1);
                }
              }
            }
          }
          updatePlayer(){
            let dx=0, dz=0;
            if(this.keysPressed['ArrowUp'])dz-=this.player.speedKeyboard;
            if(this.keysPressed['ArrowDown'])dz+=this.player.speedKeyboard;
            if(this.keysPressed['ArrowLeft'])dx-=this.player.speedKeyboard;
            if(this.keysPressed['ArrowRight'])dx+=this.player.speedKeyboard;
            if(dx!==0||dz!==0){
              this.player.lastMoveVec.set(dx,0,dz);
            }
            const newX=this.player.x+dx;
            const newZ=this.player.z+dz;
            // boundary collision
            let blocked=false;
            for(const obj of this.objects){
              if(obj.type==='building'||obj.type==='boundary'||obj.type==='npc'){
                const dxObj=newX-obj.x;
                const dzObj=newZ-obj.z;
                const distSq=dxObj*dxObj+dzObj*dzObj;
                const r=(obj.boundingRadius||2);
                if(distSq<r*r){ blocked=true; break; }
              }
            }
            if(!blocked){
              this.player.x=newX; this.player.z=newZ;
            }
            if(this.player.object){
              this.player.object.position.set(this.player.x,0,this.player.z);
            }
          }
          updateBlueNPC(){
            this.npcBlueData.angle+=this.npcBlueData.speed;
            const x=this.npcBlueData.radius*Math.cos(this.npcBlueData.angle);
            const z=this.npcBlueData.radius*Math.sin(this.npcBlueData.angle);
            if(this.npcBlueData.object){
              this.npcBlueData.object.position.set(x,0.5,z+5);
              for(const obj of this.objects){
                if(obj.mesh===this.npcBlueData.object){
                  obj.x=x; obj.z=z+5; break;
                }
              }
            }
          }
          updateYellowNPC(){
            if(!this.npcYellowData.object)return;
            if(!this.npcYellowData.target){
              this.npcYellowData.target=this.getRandomBuildingTarget();
            }
            const dx=this.npcYellowData.target.x-this.npcYellowData.object.position.x;
            const dz=this.npcYellowData.target.z-this.npcYellowData.object.position.z;
            const distSq=dx*dx+dz*dz;
            if(distSq<1){
              this.npcYellowData.target=this.getRandomBuildingTarget();
            } else {
              const angle=Math.atan2(-dx,dz);
              this.npcYellowData.object.rotation.y=angle;
              const step=this.npcYellowData.speed;
              const newX=this.npcYellowData.object.position.x+Math.sin(angle)*step;
              const newZ=this.npcYellowData.object.position.z+Math.cos(angle)*step;
              if(Math.abs(newX)<48 && Math.abs(newZ)<48){
                this.npcYellowData.object.position.set(newX,0,newZ);
              }
            }
            for(const obj of this.objects){
              if(obj.mesh===this.npcYellowData.object){
                obj.x=this.npcYellowData.object.position.x;
                obj.z=this.npcYellowData.object.position.z;
                break;
              }
            }
          }
          getRandomBuildingTarget(){
            const i=Math.floor(Math.random()*this.buildingPositions.length);
            return this.buildingPositions[i];
          }
          updateMermaid(){
            if(!this.mermaidData.object)return;
            const m=this.mermaidData;
            const currentPt=m.route[m.routeIndex];
            const dx=currentPt.x - m.object.position.x;
            const dz=currentPt.z - m.object.position.z;
            const distSq=dx*dx+dz*dz;
            if(distSq<1){
              m.routeIndex=(m.routeIndex+1)%m.route.length;
            }
            const angle=Math.atan2(-dx,dz);
            m.object.rotation.y=angle;
            const step=m.speed;
            const newX=m.object.position.x+Math.sin(angle)*step;
            const newZ=m.object.position.z+Math.cos(angle)*step;
            m.object.position.set(newX,0,newZ);

            for(const obj of this.objects){
              if(obj.mesh===m.object){
                obj.x=newX; obj.z=newZ; break;
              }
            }
          }
          updateGuardPatrol(){
            if(!this.guardData.object)return;
            this.guardData.timer++;
            if(this.guardData.state==='idle'){
              if(this.guardData.timer>600){ // 600 frames ~ 10s
                this.guardData.state='patrol';
                this.guardData.timer=0;
                this.guardData.routeIndex=0;
              }
            } else if(this.guardData.state==='patrol'){
              const route=this.guardData.route;
              const guard=this.guardData.object;
              const target=route[this.guardData.routeIndex];
              const dx=target.x-guard.position.x;
              const dz=target.z-guard.position.z;
              const distSq=dx*dx+dz*dz;
              if(distSq<1){
                this.guardData.routeIndex++;
                if(this.guardData.routeIndex>=route.length){
                  this.guardData.state='idle';
                  this.guardData.timer=0;
                }
              } else {
                const angle=Math.atan2(-dx,dz);
                guard.rotation.y=angle;
                const step=this.guardData.speed;
                const newX=guard.position.x+Math.sin(angle)*step;
                const newZ=guard.position.z+Math.cos(angle)*step;
                guard.position.set(newX,0,newZ);
                for(const obj of this.objects){
                  if(obj.mesh===guard){
                    obj.x=newX; obj.z=newZ; break;
                  }
                }
              }
            }
          }
          updateCollisions(){
            // If near guard
            for(const obj of this.objects){
              if(obj.type==='guard'){
                const dxG=this.player.x-obj.x;
                const dzG=this.player.z-obj.z;
                const distG=Math.sqrt(dxG*dxG+dzG*dzG);
                if(distG<3){
                  // guard message
                  this.showDialogue("I'm the guard. Show your ID!");
                }
              }
            }
          }
          updatePickups(){
            // none in this simplified code
          }

          throwBall(){
            // Check if player object is present
            if(!this.player.object){
              console.warn('No player object, ignoring throwBall.');
              return;
            }
            const direction=new THREE.Vector3(
              Math.sin(this.player.yaw),
              0,
              Math.cos(this.player.yaw)
            ).normalize();
            const ballGeo=new THREE.SphereGeometry(0.3,16,16);
            const ballMat=new THREE.MeshStandardMaterial({ color:0xff4500 });
            const ball=new THREE.Mesh(ballGeo,ballMat);
            ball.position.copy(this.player.object.position);
            ball.position.y+=1;
            ball.userData={
              velocity:direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
              bounced:false
            };
            this.scene.add(ball);
            this.thrownBalls.push(ball);
            this.ballCount++;
            document.getElementById('ballCountValue').textContent=this.ballCount;
            this.showDialogue("Threw a magic ball!");
          }
          showDialogue(text){
            document.getElementById('dialogue').textContent=text;
          }
          startCollectionGlow(){
            // not used in this minimal version
          }

          initJoysticks(){
            // Left joystick
            this.joystickLeft=nipplejs.create({
              zone:document.getElementById('joystickLeft'),
              mode:'static',
              color:'white',
              size:80,
              position:{ left:'50%', top:'50%' }
            });
            this.joystickLeft.on('move',(evt,data)=>{
              if(data&&data.force>0){
                const angle=data.angle.radian;
                const speed=data.force*this.player.speedJoystick;
                const dx=Math.cos(angle)*speed;
                const dz=Math.sin(angle)*speed;
                const newX=this.player.x+dx;
                const newZ=this.player.z-dz;
                // boundary collision
                let blocked=false;
                for(const obj of this.objects){
                  if(obj.type==='building'||obj.type==='boundary'||obj.type==='npc'){
                    const dxObj=newX-obj.x;
                    const dzObj=newZ-obj.z;
                    const distSq=dxObj*dxObj+dzObj*dzObj;
                    const r=(obj.boundingRadius||2);
                    if(distSq<r*r){ blocked=true; break; }
                  }
                }
                if(!blocked){
                  this.player.x=newX;
                  this.player.z=newZ;
                }
                if(this.player.object){
                  this.player.object.position.set(this.player.x,0,this.player.z);
                }
                this.joystickLeft.active=true;
              }
            });
            this.joystickLeft.on('end',()=>{ this.joystickLeft.active=false; });

            // Right joystick
            this.joystickRight=nipplejs.create({
              zone:document.getElementById('joystickRight'),
              mode:'static',
              color:'white',
              size:80,
              position:{ left:'50%', top:'50%' }
            });
            this.joystickRight.on('move',(evt,data)=>{
              if(data&&data.force>0){
                const sensitivity=0.001;
                this.player.yaw+=data.vector.x*sensitivity*data.force;
                // optional pitch
                //this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch+data.vector.y*sensitivity*data.force));
              }
            });
            this.joystickRight.on('end',()=>{});

            // Tapping center => throw ball
            document.getElementById('gameContainer').addEventListener('click', e=>{
              const rect=e.target.getBoundingClientRect();
              const x=e.clientX-rect.left;
              const y=e.clientY-rect.top;
              if(x>rect.width/4 && x<(rect.width*3)/4 && y>rect.height/4 && y<(rect.height*3)/4){
                this.throwBall();
              }
            });
          }
          initKeyboardMouse(){
            document.addEventListener('keydown', e=>{
              if(e.key===' ')this.throwBall();
              this.keysPressed[e.key]=true;
            });
            document.addEventListener('keyup', e=>{
              this.keysPressed[e.key]=false;
            });
            document.addEventListener('mousedown', ()=>{
              try{
                document.body.requestPointerLock();
              }catch(err){
                console.warn('Pointer lock request failed:',err);
              }
            });
            document.addEventListener('mousemove', evt=>{
              if(document.pointerLockElement===document.body){
                const movementX=evt.movementX||0;
                const movementY=evt.movementY||0;
                const sensitivity=0.001;
                this.player.yaw+=movementX*sensitivity;
                // optional pitch
                //this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch+movementY*sensitivity));
              }
            });
          }
        }

        // Create the game
        const game=new Game();

        // Reorient button
        document.getElementById('reorientBtn').addEventListener('click',()=>{
          game.player.yaw=0;
          game.player.pitch=0;
        });
      } catch(err){
        console.error('Error initializing the game:',err);
      }
    </script>
  </body>
</html>
