<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Princess Donia’s Town - Stars + Beach + Larger Buildings</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }

      /* UI boxes – large style for desktop; smaller on mobile */
      #ui,
      #ballCount,
      #dialogue,
      #controls,
      #errorMessage,
      #guardPopup {
        background: rgba(0,0,0,0.7);
        border: 4px solid #fff;
        border-radius: 5px;
        color: #fff;
        font-size: 28px;
        padding: 40px 80px;
      }
      #ui,
      #ballCount,
      #dialogue,
      #controls {
        position: absolute;
        z-index: 10;
      }
      #ui {
        top: 10px; 
        left: 10px;
      }
      #ballCount {
        top: 10px; 
        right: 10px;
      }
      #dialogue {
        bottom: 10px; 
        left: 10px;
        max-width: 600px;
      }
      #controls {
        bottom: 10px; 
        right: 10px;
      }
      #errorMessage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        display: none;
        z-index: 20;
      }
      #guardPopup {
        position: absolute;
        bottom: 50%;
        left: 50%;
        transform: translate(-50%,50%);
        display: none;
        z-index: 50;
        text-align: center;
      }

      /* Joystick containers – static approach in corners */
      #joystickLeft,
      #joystickRight {
        position: absolute;
        width: 80px;
        height: 80px;
        opacity: 0.5;
        z-index: 15;
      }
      #joystickLeft {
        bottom: 10vh;
        left: 6vw;
      }
      #joystickRight {
        bottom: 10vh;
        right: 6vw;
      }

      /* Button to toggle UI (top center) */
      #toggleUIBtn {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 11;
        font-size: 24px;
        padding: 10px 20px;
        background: #333;
        color: #fff;
        border: 2px solid #fff;
        border-radius: 5px;
        cursor: pointer;
      }

      /* Reorient button – small circle at bottom center */
      #reorientBtn {
        position: absolute;
        bottom: 16vh;
        left: 50%;
        transform: translateX(-50%);
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: #666;
        color: #fff;
        border: 2px solid #fff;
        text-align: center;
        line-height: 60px;
        font-size: 20px;
        z-index: 12;
        cursor: pointer;
      }

      /* Smaller UI on narrower screens */
      @media (max-width: 768px) {
        #ui,
        #ballCount,
        #dialogue,
        #controls,
        #guardPopup,
        #errorMessage {
          font-size: 16px;
          padding: 20px 30px;
        }
        #toggleUIBtn,
        #reorientBtn {
          font-size: 16px;
          width: 50px; 
          height: 50px; 
          line-height: 50px;
        }
        #joystickLeft,
        #joystickRight {
          width: 60px; 
          height: 60px;
        }
      }
    </style>

    <!-- Three.js + NippleJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>

      <button id="toggleUIBtn">Toggle UI</button>
      <button id="reorientBtn">↺</button>

      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>

      <div id="ballCount">
        Balls Thrown: <span id="ballCountValue">0</span>
      </div>

      <div id="dialogue"></div>
      <div id="controls">
        Controls:<br>
        Joysticks/Arrow Keys: Move<br>
        Joysticks/Mouse: Look Around<br>
        Tap Center/Space: Throw Ball
      </div>

      <div id="joystickLeft"></div>
      <div id="joystickRight"></div>

      <div id="errorMessage">
        WebGL not supported in your browser. Please use a modern browser.
      </div>

      <div id="guardPopup"></div>
    </div>

    <script>
      // Toggle UI
      document.getElementById('toggleUIBtn').addEventListener('click', () => {
        for (let id of ["ui","ballCount","dialogue","controls","guardPopup","errorMessage"]) {
          const el = document.getElementById(id);
          if (el.style.display === "none") el.style.display = "block";
          else el.style.display = "none";
        }
      });

      // Gracefully handle pointer lock security error
      window.addEventListener('unhandledrejection', e => {
        if (e.reason && e.reason.name === 'SecurityError') {
          console.warn('Pointer lock security error ignored:', e.reason);
          e.preventDefault();
        }
      });

      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');
        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          throw new Error('WebGL not supported');
        }

        // Basic Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameCanvas.style.display = 'block';

        // We'll keep day/night with sun & moon + stars
        let sunMesh=null, moonMesh=null, starField=null;

        // NPC data
        let npcBlueData = { angle:0, speed:0.001, radius:120, object:null };
        let npcYellowData = { object:null, pathIndex:0, speed:0.03, target:null };
        let guardData = {
          object:null,
          state:'idle',
          timer:0,
          route:[{x:30,z:40},{x:30,z:50},{x:50,z:50},{x:50,z:40},{x:40,z:40}],
          routeIndex:0,
          speed:0.02
        };
        let mermaidData = { object:null, route:[{x:-15,z:-70},{x:15,z:-70}], routeIndex:0, speed:0.02, splashTimer:0 };

        class Game {
          constructor(){
            // Game state
            this.scene = scene;
            this.camera = camera;
            this.renderer = renderer;

            this.time='Day';
            this.dayNightCycle=0;

            this.player = {
              x:0, z:0,
              speedKeyboard:0.1,
              speedJoystick:0.05,
              yaw:0, pitch:-0.2,
              object:null,
              lastMoveVec:new THREE.Vector3(1,0,0),
              waterSplashTimer:0
            };
            this.dialogue='';
            this.dialogueTimer=0;
            this.objects=[];
            this.buildingPositions=[];
            this.ballCount=0;
            this.thrownBalls=[];
            this.collectionGlow=null;
            this.joystickLeft=null;
            this.joystickRight=null;
            this.keysPressed={};

            // Day/Night
            this.sunMesh=null;
            this.moonMesh=null;
            this.starsMesh=null;

            // Interactions
            this.guardObject=null;
            this.guardMessageShown=false;
            this.npcBlueMessageShown=false;
            this.mermaidMessageShown=false;
            this.npcYellowMessageShown=false;

            // NPC data
            this.npcBlueData=npcBlueData;
            this.npcYellowData=npcYellowData;
            this.guardData=guardData;
            this.mermaidData=mermaidData;

            // init
            this.initScene();
            this.initJoysticks();
            this.initKeyboardMouse();
            this.startAnimation();
          }

          initScene(){
            // Large environment
            // Ground (300x300)
            const groundGeo=new THREE.PlaneGeometry(300,300);
            const groundMat=new THREE.MeshStandardMaterial({ color:0x6bb26b, side:THREE.DoubleSide });
            const ground=new THREE.Mesh(groundGeo,groundMat);
            ground.rotation.x=Math.PI/2;
            this.scene.add(ground);

            // Rolling hills
            for(let i=0;i<100;i++){
              const r=80+Math.random()*60;
              const x=(Math.random()>0.5?1:-1)*(300+Math.random()*500);
              const z=(Math.random()>0.5?1:-1)*(300+Math.random()*500);
              const hillGeo=new THREE.SphereGeometry(r,16,16);
              const hillMat=new THREE.MeshStandardMaterial({ color:0x228b22, roughness:0.9 });
              const hill=new THREE.Mesh(hillGeo,hillMat);
              hill.position.set(x,-r/2,z);
              this.scene.add(hill);
            }

            // Boundary ±130
            for(let x=-130;x<=130;x+=4){
              this.addShrub(x,-130);
              this.addShrub(x,130);
            }
            for(let z=-130;z<=130;z+=4){
              this.addShrub(-130,z);
              this.addShrub(130,z);
            }

            // Beach + water
            this.createBeach();

            // Lighting
            const ambient=new THREE.AmbientLight(0x404040,0.6);
            this.scene.add(ambient);
            const dirLight=new THREE.DirectionalLight(0xffffff,0.8);
            dirLight.position.set(10,20,10);
            this.scene.add(dirLight);

            // Create sun & moon
            const sunGeo=new THREE.SphereGeometry(3,16,16);
            const sunMat=new THREE.MeshBasicMaterial({ color:0xffee00 });
            this.sunMesh=new THREE.Mesh(sunGeo,sunMat);
            this.sunMesh.position.set(0,200,-200);
            this.sunMesh.visible=true;
            this.scene.add(this.sunMesh);

            const moonGeo=new THREE.SphereGeometry(2,16,16);
            const moonMat=new THREE.MeshBasicMaterial({ color:0xcccccc });
            this.moonMesh=new THREE.Mesh(moonGeo,moonMat);
            this.moonMesh.position.set(-100,150,100);
            this.moonMesh.visible=false;
            this.scene.add(this.moonMesh);

            // Stars behind everything
            this.createStars();

            // Player
            this.createPlayerModel();

            // Buildings
            this.createCastle();
            this.createHouse();  // bigger house
            this.createCafe();   // bigger cafe
            this.createFountain();

            // NPCs
            this.createBlueNPC();
            this.createYellowNPC();
            this.createGuardAtCastle();
            this.createMermaid();

            // Items
            this.createFlowers(10);
            this.createCoins(8);
            this.createGems(4);
            this.createPotions(3);
            this.createKeys(2);
            this.createArtifacts(2);

            // Position camera behind the player
            this.camera.position.set(this.player.x+15,15,this.player.z+15);
            this.camera.lookAt(this.player.x,0.5,this.player.z);
          }

          addShrub(x,z){
            const geo=new THREE.CylinderGeometry(1,1,2,8);
            const mat=new THREE.MeshStandardMaterial({ color:0x228b22 });
            const shrub=new THREE.Mesh(geo,mat);
            shrub.position.set(x,1,z);
            this.scene.add(shrub);
            this.objects.push({ mesh:shrub, type:'boundary', x, z, boundingRadius:2 });
          }

          createBeach(){
            // Beach plane
            const beachGeo = new THREE.PlaneGeometry(300,30);
            const beachMat = new THREE.MeshStandardMaterial({
              color: 0xD2B48C,
              polygonOffset:true,
              polygonOffsetFactor:-1,
              polygonOffsetUnits:1
            });
            const beach = new THREE.Mesh(beachGeo, beachMat);
            beach.rotation.x = -Math.PI/2;
            beach.position.set(0,0.01,-40);
            this.scene.add(beach);
            this.objects.push({ mesh: beach, type:'beach', x:0, z:-40, boundingRadius:0 });

            // Water plane
            const waterGeo = new THREE.PlaneGeometry(300,30);
            const waterMat = new THREE.MeshStandardMaterial({
              color: 0x1E90FF,
              transparent:true,
              opacity:0.8,
              polygonOffset:true,
              polygonOffsetFactor:-2,
              polygonOffsetUnits:1
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI/2;
            water.position.set(0,0.02,-70);
            this.scene.add(water);
            this.objects.push({ mesh: water, type:'water', x:0, z:-70, boundingRadius:0 });
          }

          createStars(){
            const starCount=300;
            const positions=new Float32Array(starCount*3);
            for(let i=0;i<starCount;i++){
              const radius=2000+Math.random()*800;
              const angle=Math.random()*Math.PI*2;
              const ySpread=Math.random()*200-50;
              positions[i*3]=Math.cos(angle)*radius;
              positions[i*3+1]=50+ySpread;
              positions[i*3+2]=Math.sin(angle)*radius;
            }
            const starGeo=new THREE.BufferGeometry();
            starGeo.setAttribute('position',new THREE.BufferAttribute(positions,3));
            const starMat=new THREE.PointsMaterial({ color:0xffffff, size:1.2, depthTest:false });
            const starField=new THREE.Points(starGeo,starMat);
            starField.visible=false;
            this.scene.add(starField);
            this.starsMesh=starField;
          }

          createPlayerModel(){/* same as previous snippet */}
          createCastle(){
            // Same as snippet, 20x10, etc.
            const group=new THREE.Group();
            const base=new THREE.Mesh(new THREE.BoxGeometry(20,10,20), new THREE.MeshStandardMaterial({ color:0xcccccc }));
            base.position.set(0,5,0);
            group.add(base);

            const towerGeo=new THREE.CylinderGeometry(3,3,15,16);
            const towerMat=new THREE.MeshStandardMaterial({ color:0xcccccc });
            [[10,7.5,10],[-10,7.5,10],[10,7.5,-10],[-10,7.5,-10]].forEach(pos=>{
              const tower=new THREE.Mesh(towerGeo,towerMat);
              tower.position.set(pos[0],pos[1],pos[2]);
              group.add(tower);
            });
            const door=new THREE.Mesh(new THREE.PlaneGeometry(4,6), new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
            door.position.set(0,3,10.01);
            group.add(door);

            group.position.set(40,0,40);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'building', x:40, z:40, boundingRadius:15 });
          }
          createHouse(){
            // bigger house, e.g. base 12x12, height=8
            const group=new THREE.Group();
            const base=new THREE.Mesh(new THREE.BoxGeometry(12,8,10), new THREE.MeshStandardMaterial({ color:0x8b4513 }));
            base.position.set(0,4,0);
            group.add(base);

            const roof=new THREE.Mesh(new THREE.ConeGeometry(6,4,4), new THREE.MeshStandardMaterial({ color:0x800000 }));
            roof.position.set(0,8,0);
            roof.rotation.y=Math.PI/4;
            group.add(roof);

            const door=new THREE.Mesh(new THREE.PlaneGeometry(2,4), new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
            door.position.set(0,2,5.01);
            group.add(door);

            group.position.set(-40,0,-40);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'building', x:-40, z:-40, boundingRadius:8 });
          }
          createCafe(){
            // bigger cafe, e.g. base 12x7, depth=10
            const group=new THREE.Group();
            const base=new THREE.Mesh(new THREE.BoxGeometry(12,7,10), new THREE.MeshStandardMaterial({ color:0x888888 }));
            base.position.set(0,3.5,0);
            group.add(base);

            const door=new THREE.Mesh(new THREE.PlaneGeometry(2,3), new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
            door.position.set(0,1.5,5.01);
            group.add(door);

            group.position.set(70,0,-30);
            this.scene.add(group);
            this.objects.push({ mesh:group, type:'building', x:70, z:-30, boundingRadius:8 });
          }
          createFountain(){/* same as snippet */}
          createBlueNPC(){/* same as snippet */}
          createYellowNPC(){/* same as snippet */}
          createGuardAtCastle(){/* same as snippet */}
          createMermaid(){/* same as snippet */}

          createFlowers(count){/* same as snippet */}
          createCoins(count){/* same as snippet */}
          createGems(count){/* same as snippet */}
          createPotions(count){/* same as snippet */}
          createKeys(count){/* same as snippet */}
          createArtifacts(count){/* same as snippet */}

          startAnimation(){
            const animate=()=>{
              requestAnimationFrame(animate);
              this.update();
              this.renderer.render(this.scene,this.camera);
            };
            animate();
          }

          update(){
            this.updateDayNight();
            this.updateBalls();
            this.updatePlayer();
            this.updateBlueNPC();
            this.updateYellowNPC();
            this.updateMermaid();
            this.updateGuardPatrol();
            this.updateCollisions();
            this.updateCamera();
            this.updatePickups();
          }

          // Day/night toggling sun, moon, starField
          updateDayNight(){
            this.dayNightCycle=(this.dayNightCycle+1)%1200;
            this.time=this.dayNightCycle<600?'Day':'Night';
            document.getElementById('time').textContent=this.time;
            if(this.sunMesh&&this.moonMesh&&this.starsMesh){
              if(this.time==='Day'){
                this.sunMesh.visible=true;
                this.moonMesh.visible=false;
                this.starsMesh.visible=false;
              } else {
                this.sunMesh.visible=false;
                this.moonMesh.visible=true;
                this.starsMesh.visible=true;
              }
            }
          }
          updateBalls(){/* same as snippet */}
          spawnRipple(x,z){/* optional */}
          updatePlayer(){/* same as snippet */}
          updateBlueNPC(){/* same */}
          updateYellowNPC(){/* same */}
          getRandomBuildingTarget(){/* same */}
          updateMermaid(){/* same */}
          updateGuardPatrol(){/* same */}
          updateCollisions(){/* same */}
          updateCamera(){
            // third-person vantage behind the player
            const camDist=15;
            const offsetX=camDist*Math.sin(this.player.yaw)*Math.cos(this.player.pitch);
            const offsetZ=camDist*Math.cos(this.player.yaw)*Math.cos(this.player.pitch);
            const offsetY=camDist*Math.sin(this.player.pitch)+15;
            this.camera.position.set(this.player.x+offsetX, offsetY, this.player.z+offsetZ);
            this.camera.lookAt(this.player.x,0.5,this.player.z);
          }
          updatePickups(){/* same as snippet */}

          showDialogue(text){
            document.getElementById('dialogue').textContent=text;
          }
          showGuardPopup(text){
            const popup=document.getElementById('guardPopup');
            popup.style.display='block';
            popup.textContent=text;
            setTimeout(()=>{
              popup.style.display='none';
              popup.textContent='';
            },2000);
          }
          throwBall(){
            if(!this.player.object){
              console.warn('No player object, ignoring throwBall.');
              return;
            }
            const direction=new THREE.Vector3(
              Math.cos(this.player.yaw),
              0,
              Math.sin(this.player.yaw)
            ).normalize();
            const ballGeo=new THREE.SphereGeometry(0.3,16,16);
            const ballMat=new THREE.MeshStandardMaterial({ color:0xff4500 });
            const ball=new THREE.Mesh(ballGeo,ballMat);
            ball.position.copy(this.player.object.position);
            ball.position.y+=1;
            ball.userData={
              velocity:direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
              bounced:false
            };
            this.scene.add(ball);
            this.thrownBalls.push(ball);
            this.ballCount++;
            document.getElementById('ballCountValue').textContent=this.ballCount;
            this.showDialogue("Threw a magic ball!");
          }

          initJoysticks(){
            // threshold:0 to reduce "wiggling" needed
            this.joystickLeft=nipplejs.create({
              zone:document.getElementById('joystickLeft'),
              mode:'static',
              color:'white',
              size:80,
              threshold:0, /* <= This might help reduce required movement */
              position:{ left:'50%', top:'50%' }
            });
            this.joystickLeft.on('move',(evt,data)=>{
              if(data&&data.force>0){
                const angle=data.angle.radian;
                const speed=data.force*this.player.speedJoystick;
                const dx=Math.cos(angle)*speed;
                const dz=Math.sin(angle)*speed;
                const newX=this.player.x+dx;
                const newZ=this.player.z-dz;
                let blocked=false;
                for(const obj of this.objects){
                  if(obj.type==='building'||obj.type==='wall'||obj.type==='boundary'||obj.type==='decoration'||obj.type==='npc'){
                    const dxObj=newX-obj.x;
                    const dzObj=newZ-obj.z;
                    const distSq=dxObj*dxObj+dzObj*dzObj;
                    const r=(obj.boundingRadius||5);
                    if(distSq<r*r){
                      blocked=true; 
                      break;
                    }
                  }
                }
                if(!blocked){
                  this.player.x=newX;
                  this.player.z=newZ;
                }
                if(this.player.object){
                  this.player.object.position.set(this.player.x,0.5,this.player.z);
                }
                this.joystickLeft.active=true;
              }
            });
            this.joystickLeft.on('end',()=>{ this.joystickLeft.active=false; });

            this.joystickRight=nipplejs.create({
              zone:document.getElementById('joystickRight'),
              mode:'static',
              color:'white',
              size:80,
              threshold:0,
              position:{ left:'50%', top:'50%' }
            });
            this.joystickRight.on('move',(evt,data)=>{
              if(data&&data.force>0){
                const sensitivity=0.001;
                this.player.yaw-=data.vector.x*sensitivity*data.force;
                this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch+(-data.vector.y*sensitivity*data.force)));
              }
            });
            this.joystickRight.on('end',()=>{});

            // Tapping center => throw ball
            document.getElementById('gameContainer').addEventListener('click', e=>{
              const rect=e.target.getBoundingClientRect();
              const x=e.clientX-rect.left;
              const y=e.clientY-rect.top;
              if(x>rect.width/4 && x<(rect.width*3)/4 && y>rect.height/4 && y<(rect.height*3)/4){
                this.throwBall();
              }
            });
          }

          initKeyboardMouse(){
            document.addEventListener('keydown', e=>{
              if(e.key===' ')this.throwBall();
              this.keysPressed[e.key]=true;
            });
            document.addEventListener('keyup', e=>{
              this.keysPressed[e.key]=false;
            });
            document.addEventListener('mousedown', ()=>{
              try{
                document.body.requestPointerLock();
              }catch(err){
                console.warn('Pointer lock request failed:',err);
              }
            });
            document.addEventListener('mousemove', evt=>{
              if(document.pointerLockElement===document.body){
                const movementX=evt.movementX||0;
                const movementY=evt.movementY||0;
                const sensitivity=0.001;
                this.player.yaw-=movementX*sensitivity;
                this.player.pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.player.pitch-(movementY*sensitivity)));
              }
            });
          }
        }

        // Finally, create the game
        const game=new Game();

        // Reorient button
        document.getElementById('reorientBtn').addEventListener('click',()=>{
          game.player.yaw=0;
          game.player.pitch=0;
        });
      } catch(err){
        console.error('Error initializing the game:',err);
      }
    </script>
  </body>
</html>
