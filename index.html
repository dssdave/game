<!DOCTYPE html>
<html>
  <head>
    <title>Princess Doniaâ€™s Town - Enhanced 3D RPG</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: 'Arial', sans-serif;
        background: #000;
      }
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      canvas {
        display: block;
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-size: 16px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
      #ballCount {
        position: absolute;
        top: 10px;
        right: 10px;
        color: #fff;
        font-size: 16px;
        background: rgba(0, 0, 0, 0.7);
        padding: 5px;
        border-radius: 5px;
        z-index: 10;
      }
      #dialogue {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: #fff;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        max-width: 600px;
        z-index: 10;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        color: #fff;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
      #errorMessage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 5px;
        z-index: 20;
        display: none;
      }
      #joystickLeft,
      #joystickRight {
        position: absolute;
        width: 150px;
        height: 150px;
        opacity: 0.5;
        z-index: 15;
      }
      #joystickLeft {
        bottom: 20px;
        left: 20px;
      }
      #joystickRight {
        bottom: 20px;
        right: 20px;
      }
    </style>
    <!-- Include Three.js and NippleJS from CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <div id="ui">
        Flowers: <span id="flowers">0</span> |
        Coins: <span id="coins">0</span> |
        Gems: <span id="gems">0</span> |
        Potions: <span id="potions">0</span> |
        Keys: <span id="keys">0</span> |
        Artifacts: <span id="artifacts">0</span> |
        Health: <span id="health">100</span> |
        Mana: <span id="mana">50</span> |
        Time: <span id="time">Day</span> |
        Location: <span id="location">Town</span>
      </div>
      <div id="ballCount">
        Balls Thrown: <span id="ballCountValue">0</span>
      </div>
      <div id="dialogue"></div>
      <div id="controls">
        Controls:<br>
        Joysticks/Arrow Keys: Move<br>
        Joysticks/Mouse: Look Around<br>
        Tap Center/Space: Throw Ball
      </div>
      <div id="joystickLeft"></div>
      <div id="joystickRight"></div>
      <div id="errorMessage">
        WebGL is not supported in your browser. Please use a modern browser like Chrome, Firefox, or Edge.
      </div>
    </div>

    <script>
      // Error handling for WebGL
      try {
        const errorMessage = document.getElementById('errorMessage');
        const gameCanvas = document.getElementById('gameCanvas');

        if (!window.WebGLRenderingContext) {
          errorMessage.style.display = 'block';
          gameCanvas.style.display = 'none';
          document.getElementById('ui').style.display = 'none';
          document.getElementById('ballCount').style.display = 'none';
          document.getElementById('dialogue').style.display = 'none';
          document.getElementById('controls').style.display = 'none';
          document.getElementById('joystickLeft').style.display = 'none';
          document.getElementById('joystickRight').style.display = 'none';
          throw new Error('WebGL not supported');
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        if (!renderer.domElement) {
          throw new Error('Renderer initialization failed');
        }

        // Show game canvas
        gameCanvas.style.display = 'block';

        // Main game object
        let game;

        class Game {
          constructor() {
            this.scene = 'town';
            this.flowers = 0;
            this.coins = 0;
            this.gems = 0;
            this.potions = 0;
            this.keys = 0;
            this.artifacts = 0;
            this.health = 100;
            this.mana = 50;
            this.time = 'Day';
            this.dayNightCycle = 0;

            // Slower speed to avoid "wild" joystick movement
            this.player = {
              x: 0,
              z: 0,
              speed: 0.2, // reduced from 0.5
              yaw: 0,
              pitch: 0,
              object: null
            };

            this.dialogue = '';
            this.dialogueTimer = 0;
            this.objects = [];
            this.npcs = [];
            this.quests = {
              townGuard: { active: false, completed: false },
              castleKing: { active: false, completed: false },
              villager: { active: false, completed: false },
              storyteller: { active: false, completed: false }
            };
            this.ballCount = 0;
            this.ballLimit = 1000000;
            this.thrownBalls = [];
            this.collectionGlow = null;
            this.joystickLeft = null;
            this.joystickRight = null;
            this.keys = {}; // Keyboard input state
            this.sceneObj = scene;
            this.camera = camera;
            this.renderer = renderer;

            this.initScene();
            this.initJoysticks();
            this.initKeyboardMouse();
            this.startAnimation();
            console.log('Game initialized successfully:', this);
          }

          showDialogue(text) {
            this.dialogue = text;
            this.dialogueTimer = 120;
            document.getElementById('dialogue').textContent = this.dialogue;
          }

          updateDayNight() {
            this.dayNightCycle = (this.dayNightCycle + 1) % 1200;
            this.time = this.dayNightCycle < 600 ? 'Day' : 'Night';
            document.getElementById('time').textContent = this.time;
          }

          throwBall() {
            if (this.ballCount < this.ballLimit && this.mana >= 5) {
              this.mana -= 5;
              const ballGeometry = new THREE.SphereGeometry(0.3, 16, 16);
              const ballMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4500,
                metalness: 0.1,
                roughness: 0.7
              });
              const ball = new THREE.Mesh(ballGeometry, ballMaterial);

              // Start at player's position
              ball.position.copy(this.player.object.position);
              ball.position.y += 1;

              // Direction based on yaw
              const direction = new THREE.Vector3(
                Math.cos(this.player.yaw),
                0,
                Math.sin(this.player.yaw)
              ).normalize();
              ball.userData = {
                velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0, 0.3, 0))
              };

              this.sceneObj.add(ball);
              this.thrownBalls.push(ball);
              this.ballCount++;
              document.getElementById('ballCountValue').textContent = this.ballCount;
              this.showDialogue('Threw a magic ball!');
              document.getElementById('mana').textContent = this.mana;
            } else if (this.ballCount >= this.ballLimit) {
              this.showDialogue('Reached maximum ball throws (1,000,000)!');
            } else {
              this.showDialogue('Not enough mana to throw a ball!');
            }
          }

          startCollectionGlow() {
            // Brief glow effect when picking up items
            if (this.collectionGlow) this.sceneObj.remove(this.collectionGlow);
            const glowGeometry = new THREE.SphereGeometry(1, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: 0xffff00,
              transparent: true,
              opacity: 0.5,
              side: THREE.BackSide
            });
            this.collectionGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            this.collectionGlow.position.copy(this.player.object.position);
            this.collectionGlow.position.y += 0.5;
            this.sceneObj.add(this.collectionGlow);

            setTimeout(() => {
              if (this.collectionGlow) {
                this.sceneObj.remove(this.collectionGlow);
                this.collectionGlow = null;
              }
            }, 1000);
          }

          startAnimation() {
            const animate = () => {
              requestAnimationFrame(animate);
              if (game && game.renderer && game.sceneObj && game.camera) {
                game.update();
                game.renderer.render(game.sceneObj, game.camera);
              } else {
                console.error('Game, renderer, scene, or camera not properly initialized.', {
                  game,
                  renderer,
                  scene,
                  camera
                });
              }
            };
            animate();
          }

          update() {
            this.updateDayNight();

            // Movement from arrow keys or left joystick
            let dx = 0,
              dz = 0;
            if (this.keys['ArrowUp'] || (this.joystickLeft && this.joystickLeft.active)) {
              dz -= this.player.speed;
            }
            if (this.keys['ArrowDown']) {
              dz += this.player.speed;
            }
            if (this.keys['ArrowLeft']) {
              dx -= this.player.speed;
            }
            if (this.keys['ArrowRight']) {
              dx += this.player.speed;
            }

            // Calculate new position
            const newX =
              this.player.x + dx * Math.cos(this.player.yaw) + dz * Math.sin(this.player.yaw);
            const newZ =
              this.player.z -
              dx * Math.sin(this.player.yaw) +
              dz * Math.cos(this.player.yaw);

            // Check collisions (buildings, walls, boundaries)
            const blocked = this.objects.some(obj => {
              const distX = Math.abs(obj.x - newX);
              const distZ = Math.abs(obj.z - newZ);
              return (
                (obj.type === 'building' ||
                  obj.type === 'wall' ||
                  obj.type === 'boundary') &&
                distX < 5 &&
                distZ < 5
              );
            });

            if (!blocked) {
              this.player.x = newX;
              this.player.z = newZ;
            }

            // Update player mesh
            this.player.object.position.set(this.player.x, 0.5, this.player.z);
            this.player.object.rotation.y = -this.player.yaw;

            // Simple walking animation
            const isMoving =
              Object.values(this.keys).some(k => k) ||
              (this.joystickLeft && this.joystickLeft.active);
            if (isMoving) {
              this.player.object.traverse(child => {
                if (
                  child.isMesh &&
                  child.material.color.equals(new THREE.Color(0xff69b4))
                ) {
                  child.rotation.z = Math.sin(Date.now() * 0.005) * 0.1;
                }
              });
            } else {
              this.player.object.traverse(child => {
                if (
                  child.isMesh &&
                  child.material.color.equals(new THREE.Color(0xff69b4))
                ) {
                  child.rotation.copy(child.userData.originalRotation || new THREE.Euler());
                }
              });
            }

            // Update camera
            this.camera.position.set(
              this.player.x + 15 * Math.sin(this.player.yaw) * Math.cos(this.player.pitch),
              15 + 15 * Math.sin(this.player.pitch),
              this.player.z + 15 * Math.cos(this.player.yaw) * Math.cos(this.player.pitch)
            );
            this.camera.lookAt(this.player.x, 0.5, this.player.z);

            // Update thrown balls (gravity + removal)
            this.thrownBalls.forEach((ball, index) => {
              ball.position.add(ball.userData.velocity);
              ball.userData.velocity.y -= 0.01; // gravity
              if (ball.position.y < 0) {
                this.sceneObj.remove(ball);
                this.thrownBalls.splice(index, 1);
              }
            });

            // Check for picking up items
            this.objects.forEach(obj => {
              const distX = Math.abs(obj.x - this.player.x);
              const distZ = Math.abs(obj.z - this.player.z);
              // If close enough, "pick up" certain objects
              if (distX < 1 && distZ < 1) {
                if (obj.type === 'flower') {
                  this.flowers++;
                  document.getElementById('flowers').textContent = this.flowers;
                  this.sceneObj.remove(obj.mesh);
                  this.objects = this.objects.filter(o => o !== obj);
                  this.showDialogue('You picked a flower!');
                  this.startCollectionGlow();
                } else if (obj.type === 'coin') {
                  this.coins++;
                  document.getElementById('coins').textContent = this.coins;
                  this.sceneObj.remove(obj.mesh);
                  this.objects = this.objects.filter(o => o !== obj);
                  this.showDialogue('You picked up a coin!');
                  this.startCollectionGlow();
                }
              }
            });
          }

          initScene() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({
              color: 0x6bb26b,
              side: THREE.DoubleSide,
              roughness: 0.8,
              metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = Math.PI / 2;
            ground.castShadow = true;
            ground.receiveShadow = true;
            this.sceneObj.add(ground);

            // Skybox (with offset as vec3 fix)
            const skyGeometry = new THREE.SphereGeometry(500, 60, 40);
            const skyMaterial = new THREE.ShaderMaterial({
              uniforms: {
                topColor: { value: new THREE.Color(0x87ceeb) },
                bottomColor: { value: new THREE.Color(0x2f4f4f) },
                offset: { value: 0.5 },
                exponent: { value: 0.6 }
              },
              vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                  vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                  vWorldPosition = worldPosition.xyz;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                  float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
                  gl_FragColor = vec4(
                    mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)),
                    1.0
                  );
                }
              `,
              side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            sky.name = 'sky';
            this.sceneObj.add(sky);

            // Basic lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            this.sceneObj.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            this.sceneObj.add(directionalLight);

            // Create the princess (player character)
            this.createPlayerModel();

            // Add boundary shrubs/trees around edges
            this.createBoundary();

            // Add a simple castle with collision
            this.createCastle();

            // Add a simple house with collision
            this.createHouse();

            // Add some flowers and coins to pick up
            this.createPickups();
          }

          createBoundary() {
            // Large square boundary at +/- 50
            const boundaryGroup = new THREE.Group();
            const boundarySize = 50;

            // Helper function to create a single shrub or small tree
            const createShrub = () => {
              const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
              const material = new THREE.MeshStandardMaterial({ color: 0x228b22 });
              const mesh = new THREE.Mesh(geometry, material);
              mesh.castShadow = true;
              mesh.receiveShadow = true;
              return mesh;
            };

            // Top & bottom edges
            for (let x = -boundarySize; x <= boundarySize; x += 2) {
              const shrubTop = createShrub();
              shrubTop.position.set(x, 0.75, -boundarySize);
              boundaryGroup.add(shrubTop);

              const shrubBottom = createShrub();
              shrubBottom.position.set(x, 0.75, boundarySize);
              boundaryGroup.add(shrubBottom);
            }

            // Left & right edges
            for (let z = -boundarySize; z <= boundarySize; z += 2) {
              const shrubLeft = createShrub();
              shrubLeft.position.set(-boundarySize, 0.75, z);
              boundaryGroup.add(shrubLeft);

              const shrubRight = createShrub();
              shrubRight.position.set(boundarySize, 0.75, z);
              boundaryGroup.add(shrubRight);
            }

            boundaryGroup.position.set(0, 0, 0);

            // Push into objects with type 'boundary' so collisions block movement
            this.objects.push({ mesh: boundaryGroup, type: 'boundary', x: 0, z: 0 });
            this.sceneObj.add(boundaryGroup);
          }

          createCastle() {
            // Simple big box as a "castle" with collision
            const castleGeometry = new THREE.BoxGeometry(10, 10, 10);
            const castleMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const castleMesh = new THREE.Mesh(castleGeometry, castleMaterial);
            // Center is at y=5 because box is 10 high
            castleMesh.position.set(20, 5, 20);
            castleMesh.castShadow = true;
            castleMesh.receiveShadow = true;

            // Add to objects with type 'building'
            this.objects.push({ mesh: castleMesh, type: 'building', x: 20, z: 20 });
            this.sceneObj.add(castleMesh);
          }

          createHouse() {
            // Simple box as a "house" with collision
            const houseGeometry = new THREE.BoxGeometry(6, 6, 6);
            const houseMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const houseMesh = new THREE.Mesh(houseGeometry, houseMaterial);
            // Center is y=3 because box is 6 high
            houseMesh.position.set(-20, 3, -20);
            houseMesh.castShadow = true;
            houseMesh.receiveShadow = true;

            // Add to objects with type 'building'
            this.objects.push({ mesh: houseMesh, type: 'building', x: -20, z: -20 });
            this.sceneObj.add(houseMesh);
          }

          createPickups() {
            // Flower pickup
            const flowerGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
            const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xff00ff });
            const flowerMesh = new THREE.Mesh(flowerGeometry, flowerMaterial);
            // Put it near origin
            flowerMesh.position.set(0, 0.15, 0);
            this.objects.push({ mesh: flowerMesh, type: 'flower', x: 0, z: 0 });
            this.sceneObj.add(flowerMesh);

            // Coin pickup
            const coinGeometry = new THREE.CircleGeometry(0.2, 16);
            const coinMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            const coinMesh = new THREE.Mesh(coinGeometry, coinMaterial);
            coinMesh.position.set(5, 0.01, 5);
            // Lay flat
            coinMesh.rotation.x = -Math.PI / 2;
            this.objects.push({ mesh: coinMesh, type: 'coin', x: 5, z: 5 });
            this.sceneObj.add(coinMesh);
          }

          createPlayerModel() {
            // A low-poly "princess" made of basic shapes
            const princessGroup = new THREE.Group();

            // Materials
            const bodyMaterial = new THREE.MeshStandardMaterial({
              color: 0xff69b4,
              metalness: 0.1,
              roughness: 0.5
            }); // Pink
            const skinMaterial = new THREE.MeshStandardMaterial({
              color: 0xffe4c4,
              metalness: 0.1,
              roughness: 0.5
            }); // Skin
            const goldMaterial = new THREE.MeshStandardMaterial({
              color: 0xffd700,
              metalness: 0.9,
              roughness: 0.2
            }); // Gold

            // Torso segments
            for (let i = 0; i < 3; i++) {
              const torsoSegment = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.4, 0.5),
                bodyMaterial
              );
              torsoSegment.position.y = 0.6 + i * 0.4;
              princessGroup.add(torsoSegment);
            }

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), skinMaterial);
            head.position.y = 1.5;
            princessGroup.add(head);

            // Facial features
            const eyeSize = 0.05;
            const leftEye = new THREE.Mesh(
              new THREE.BoxGeometry(eyeSize, eyeSize, eyeSize),
              new THREE.MeshStandardMaterial({ color: 0x000000 })
            );
            leftEye.position.set(-0.15, 1.6, 0.3);
            const rightEye = new THREE.Mesh(
              new THREE.BoxGeometry(eyeSize, eyeSize, eyeSize),
              new THREE.MeshStandardMaterial({ color: 0x000000 })
            );
            rightEye.position.set(0.15, 1.6, 0.3);
            const mouth = new THREE.Mesh(
              new THREE.BoxGeometry(0.1, 0.05, 0.05),
              new THREE.MeshStandardMaterial({ color: 0xff0000 })
            );
            mouth.position.set(0, 1.45, 0.3);
            const leftBlush = new THREE.Mesh(
              new THREE.BoxGeometry(0.1, 0.05, 0.05),
              new THREE.MeshStandardMaterial({ color: 0xff8c8c })
            );
            leftBlush.position.set(-0.15, 1.5, 0.3);
            const rightBlush = new THREE.Mesh(
              new THREE.BoxGeometry(0.1, 0.05, 0.05),
              new THREE.MeshStandardMaterial({ color: 0xff8c8c })
            );
            rightBlush.position.set(0.15, 1.5, 0.3);
            head.add(leftEye, rightEye, mouth, leftBlush, rightBlush);

            // Arms
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), bodyMaterial);
            leftArm.position.set(-0.5, 1.0, 0);
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), bodyMaterial);
            rightArm.position.set(0.5, 1.0, 0);
            princessGroup.add(leftArm, rightArm);

            // Legs
            const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), bodyMaterial);
            leftLeg.position.set(-0.2, 0.3, 0);
            const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), bodyMaterial);
            rightLeg.position.set(0.2, 0.3, 0);
            princessGroup.add(leftLeg, rightLeg);

            // Crown
            const crownSize = 0.05;
            const crownBase = new THREE.Mesh(new THREE.BoxGeometry(0.5, crownSize, 0.5), goldMaterial);
            crownBase.position.y = 1.9;
            const crownSpike1 = new THREE.Mesh(new THREE.BoxGeometry(crownSize, 0.3, crownSize), goldMaterial);
            crownSpike1.position.set(0, 2.05, 0.25);
            const crownSpike2 = new THREE.Mesh(new THREE.BoxGeometry(crownSize, 0.3, crownSize), goldMaterial);
            crownSpike2.position.set(0, 2.05, -0.25);
            const crownSpike3 = new THREE.Mesh(new THREE.BoxGeometry(crownSize, 0.3, crownSize), goldMaterial);
            crownSpike3.position.set(0.25, 2.05, 0);
            const crownSpike4 = new THREE.Mesh(new THREE.BoxGeometry(crownSize, 0.3, crownSize), goldMaterial);
            crownSpike4.position.set(-0.25, 2.05, 0);
            princessGroup.add(crownBase, crownSpike1, crownSpike2, crownSpike3, crownSpike4);

            // Jewelry
            const necklaceCube = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.05, 0.05), goldMaterial);
            necklaceCube.position.set(0, 1.0, 0.3);
            const leftEarring = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.05), goldMaterial);
            leftEarring.position.set(-0.5, 1.5, 0.3);
            const rightEarring = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.05), goldMaterial);
            rightEarring.position.set(0.5, 1.5, 0.3);
            princessGroup.add(necklaceCube, leftEarring, rightEarring);

            // Position princess at (0,0)
            princessGroup.position.set(this.player.x, 0.5, this.player.z);
            this.player.object = princessGroup;
            this.sceneObj.add(princessGroup);

            // Save original rotation for walking animation reset
            this.player.object.traverse(child => {
              if (
                child.isMesh &&
                child.material.color.equals(new THREE.Color(0xff69b4))
              ) {
                child.userData.originalRotation = child.rotation.clone();
              }
            });
          }

          initJoysticks() {
            // Left joystick (movement)
            this.joystickLeft = nipplejs.create({
              zone: document.getElementById('joystickLeft'),
              mode: 'static',
              position: { left: '50px', bottom: '50px' },
              color: 'white',
              size: 100
            });

            this.joystickLeft.on('move', (evt, data) => {
              if (data && data.force > 0) {
                const angle = data.angle.radian;
                // Slower speed based on player.speed
                const speed = data.force * this.player.speed;
                const dx = Math.cos(angle) * speed;
                const dz = Math.sin(angle) * speed;
                const newX = this.player.x + dx;
                const newZ = this.player.z - dz;

                // Collision check
                const blocked = this.objects.some(obj => {
                  const distX = Math.abs(obj.x - newX);
                  const distZ = Math.abs(obj.z - newZ);
                  return (
                    (obj.type === 'building' ||
                      obj.type === 'wall' ||
                      obj.type === 'boundary') &&
                    distX < 5 &&
                    distZ < 5
                  );
                });

                if (!blocked) {
                  this.player.x = newX;
                  this.player.z = newZ;
                }
              }
            });

            this.joystickLeft.on('end', () => {
              this.joystickLeft.active = false;
            });
            this.joystickLeft.on('start', () => {
              this.joystickLeft.active = true;
            });

            // Right joystick (look)
            this.joystickRight = nipplejs.create({
              zone: document.getElementById('joystickRight'),
              mode: 'static',
              position: { right: '50px', bottom: '50px' },
              color: 'white',
              size: 100
            });

            this.joystickRight.on('move', (evt, data) => {
              if (data && data.force > 0) {
                const sensitivity = 0.002;
                this.player.yaw += data.vector.x * sensitivity * data.force;
                this.player.pitch = Math.max(
                  -Math.PI / 2,
                  Math.min(Math.PI / 2, this.player.pitch + data.vector.y * sensitivity * data.force)
                );
              }
            });

            this.joystickRight.on('end', () => {});
            this.joystickRight.on('start', () => {});

            // Tap center of screen (between joysticks) to throw ball
            document.getElementById('gameContainer').addEventListener('click', e => {
              const rect = document.getElementById('gameContainer').getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              if (
                x > rect.width / 4 &&
                x < (rect.width * 3) / 4 &&
                y > rect.height / 4 &&
                y < (rect.height * 3) / 4
              ) {
                this.throwBall();
              }
            });
          }

          initKeyboardMouse() {
            // Keyboard
            document.addEventListener('keydown', e => {
              this.keys[e.key] = true;
              if (e.key === ' ') this.throwBall();
            });
            document.addEventListener('keyup', e => {
              this.keys[e.key] = false;
            });

            // Mouse pointer lock for looking around
            document.addEventListener('mousedown', () => {
              document.body.requestPointerLock();
            });
            document.addEventListener('mousemove', event => {
              if (document.pointerLockElement === document.body) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                this.player.yaw += movementX * 0.002;
                this.player.pitch = Math.max(
                  -Math.PI / 2,
                  Math.min(Math.PI / 2, this.player.pitch + movementY * 0.002)
                );
              }
            });
          }

          createNPCs(scene) {
            // Example: create a guard NPC in town
            const npcs = [];
            if (scene === 'town') {
              const npcGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
              const npcMaterial = new THREE.MeshStandardMaterial({
                color: 0x00008b,
                metalness: 0.3,
                roughness: 0.6
              });
              const guard = new THREE.Mesh(npcGeometry, npcMaterial);
              guard.position.set(0, 1, 0);
              guard.castShadow = true;
              npcs.push({ mesh: guard, x: 0, z: 0, role: 'guard' });
            }
            return npcs;
          }

          updateObjects() {
            // For switching scenes, remove existing objects and re-add new ones
            this.sceneObj.remove(...this.objects.map(obj => obj.mesh));
            this.sceneObj.remove(...this.npcs.map(npc => npc.mesh));

            this.objects = this.createObjects(this.scene);
            this.npcs = this.createNPCs(this.scene);

            this.objects.forEach(obj => this.sceneObj.add(obj.mesh));
            this.npcs.forEach(npc => this.sceneObj.add(npc.mesh));
          }

          createObjects(scene) {
            // Example of re-creating objects for different scenes
            const objects = [];
            // Always push the player so they remain in the scene
            objects.push({ mesh: this.player.object, type: 'player', x: this.player.x, z: this.player.z });

            // If we wanted to conditionally add objects based on scene:
            if (scene === 'town') {
              // Town objects (castle, house, pickups) are already created in initScene for now
            } else if (scene === 'castle') {
              // Possibly add interior objects
            }
            return objects;
          }
        }

        // Initialize the game
        game = new Game();
      } catch (error) {
        console.error('Error initializing the game:', error);
      }
    </script>
  </body>
</html>
