<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town - Updated</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      -webkit-user-select: none; -webkit-touch-callout: none;
      user-select: none; touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw; height: 100vh;
    }
    canvas { display: block; }

    /* UI boxes */
    #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
      background: rgba(0,0,0,0.7);
      border: 4px solid #fff;
      border-radius: 5px;
      color: #fff;
      font-size: 28px;
      padding: 40px 80px;
      position: absolute;
      z-index: 10;
    }
    #ui         { top: 10px; left: 10px; }
    #ballCount  { top: 10px; right: 10px; }
    #dialogue   { bottom: 10px; left: 10px; max-width: 600px; display: none; }
    #controls   { bottom: 10px; right: 10px; }
    #errorMessage {
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      display: none; z-index: 20;
    }
    #guardPopup {
      bottom: 50%; left: 50%;
      transform: translate(-50%,50%);
      display: none; z-index: 50; text-align: center;
    }

    /* Toggle UI button */
    #toggleUIBtn {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      font-size: 24px;
      padding: 10px 20px;
      background: #333; color: #fff;
      border: 2px solid #fff; border-radius: 5px;
      cursor: pointer;
    }

    /* On-screen Controller */
    #dpadContainer, #turnContainer, #actionContainer {
      position: absolute; z-index: 15;
    }
    /* D-Pad as a grid with a small gap */
    #dpadContainer {
      bottom: 16vh; left: 5vw;
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
    }
    #btnUp    { grid-column: 2; grid-row: 1; }
    #btnDown  { grid-column: 2; grid-row: 3; }
    #btnLeft  { grid-column: 1; grid-row: 2; }
    #btnRight { grid-column: 3; grid-row: 2; }

    #dpadContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 20px; color: #fff;
      cursor: pointer;
    }
    #turnContainer {
      bottom: 16vh; left: calc(5vw + 200px);
      display: flex; flex-direction: column; gap: 10px;
    }
    #turnContainer button, #actionContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px; color: #fff;
      cursor: pointer;
    }
    #actionContainer {
      bottom: 16vh; left: calc(5vw + 200px + 70px);
      display: flex; flex-direction: column; gap: 10px;
    }

    /* Smaller UI on narrower screens */
    @media (max-width: 768px) {
      #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
        font-size: 16px; padding: 20px 30px;
      }
      #toggleUIBtn { font-size: 16px; }
      #dpadContainer {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
      }
      #dpadContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
      #turnContainer button, #actionContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>

    <!-- Stats -->
    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifacts: <span id="artifacts">0</span> |
      Health: <span id="health">100</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
    <div id="dialogue"></div>
    <div id="controls">
      Controls:<br>
      [Desktop] Arrow Up/Down = forward/back, Left/Right = turn, Space = throw ball<br>
      [Mobile] D‑Pad Up/Down = forward/back, Left/Right = strafe, L/R = turn, A = throw ball, B = jump
    </div>
    <div id="errorMessage">WebGL not supported in your browser.</div>
    <div id="guardPopup"></div>

    <!-- On-screen D-Pad, Turn, and Action Buttons -->
    <div id="dpadContainer">
      <button id="btnUp">▲</button>
      <button id="btnDown">▼</button>
      <button id="btnLeft">◀</button>
      <button id="btnRight">▶</button>
    </div>
    <div id="turnContainer">
      <button id="btnTurnLeft">L</button>
      <button id="btnTurnRight">R</button>
    </div>
    <div id="actionContainer">
      <button id="btnThrow">A</button>
      <button id="btnBigThrow">B</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Toggle UI
    document.getElementById('toggleUIBtn').addEventListener('click', () => {
      const ids = ["ui","ballCount","dialogue","controls","guardPopup","errorMessage"];
      for(const id of ids){
        const el = document.getElementById(id);
        el.style.display = (el.style.display==="none") ? "block":"none";
      }
    });

    // Prevent highlight on mobile
    function disableHighlight(id){
      const btn=document.getElementById(id);
      ["touchstart","mousedown"].forEach(evt=>{
        btn.addEventListener(evt, e=>{
          e.preventDefault();
        }, { passive:false });
      });
    }
    ["btnUp","btnDown","btnLeft","btnRight","btnTurnLeft","btnTurnRight","btnThrow","btnBigThrow"].forEach(disableHighlight);

    // On-screen controller state
    const controllerState={
      dpadUp:false, dpadDown:false,
      dpadLeft:false, dpadRight:false,
      turnLeft:false, turnRight:false
    };
    function setButtonListener(btnId, stateProp){
      const btn=document.getElementById(btnId);
      ["mousedown","touchstart"].forEach(evt=>{
        btn.addEventListener(evt, e=>{
          e.preventDefault();
          controllerState[stateProp]=true;
        }, { passive:false });
      });
      ["mouseup","touchend","mouseleave"].forEach(evt=>{
        btn.addEventListener(evt, e=>{
          controllerState[stateProp]=false;
        });
      });
    }
    setButtonListener('btnUp','dpadUp');
    setButtonListener('btnDown','dpadDown');
    setButtonListener('btnLeft','dpadLeft');
    setButtonListener('btnRight','dpadRight');
    setButtonListener('btnTurnLeft','turnLeft');
    setButtonListener('btnTurnRight','turnRight');

    let game=null;
    // A => throwBall, B => jump
    function addButtonAction(btnId, action){
      const btn=document.getElementById(btnId);
      ["mousedown","touchstart"].forEach(evt=>{
        btn.addEventListener(evt, e=>{
          e.preventDefault();
          action();
        }, { passive:false });
      });
    }
    addButtonAction("btnThrow", ()=>{ game?.throwBall(); });
    addButtonAction("btnBigThrow", ()=>{ game?.jump(); });

    try{
      const errorMsg=document.getElementById('errorMessage');
      const gameCanvas=document.getElementById('gameCanvas');
      if(!window.WebGLRenderingContext){
        errorMsg.style.display='block';
        gameCanvas.style.display='none';
        throw new Error('WebGL not supported');
      }
      const scene=new THREE.Scene();
      const camera=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,3000);
      const renderer=new THREE.WebGLRenderer({ canvas:gameCanvas });
      renderer.setSize(window.innerWidth,window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled=true;
      renderer.shadowMap.type=THREE.PCFSoftShadowMap;
      gameCanvas.style.display='block';

      // We'll store on-screen input in controllerState, plus keyboard in keysPressed
      const keysPressed={};

      class Game{
        constructor(){
          this.scene=scene;
          this.camera=camera;
          this.renderer=renderer;
          this.time='Day';
          this.dayNightCycle=0;
          this.player={
            x:0, y:0.5, z:0,
            speedKeyboard:0.1,
            yaw:0, pitch:0,
            jumpVelocity:0,
            object:null
          };
          this.flowers=0; this.coins=0; this.gems=0; this.potions=0; this.keys=0; this.artifacts=0;
          this.health=100;
          this.dialogue='';
          this.dialogueTimer=0;
          this.objects=[];
          this.buildingPositions=[];
          this.ballCount=0;
          this.thrownBalls=[];
          this.collectionGlow=null;
          this.keysPressed=keysPressed;
          this.itemRange=80;
          this.sunMesh=null; this.moonMesh=null; this.starsMesh=null;

          // NPC data
          this.npcBlueData={ angle:0, speed:0.001, radius:120, object:null };
          this.npcYellowData={ object:null, speed:0.03, target:null };
          this.guardData={
            object:null,
            state:'idle',
            timer:0,
            route:[
              { x:35, z:60 }, { x:35, z:70 },
              { x:55, z:70 }, { x:55, z:60 },
              { x:45, z:55 }
            ],
            routeIndex:0,
            speed:0.02
          };
          this.mermaidData={ object:null, route:[{x:-15,z:-70},{x:15,z:-70}], routeIndex:0, speed:0.02 };
          this.birdData={ angle:0, speed:0.002, radius:140, object:null };
          this.guardObject=null; this.guardMessageShown=false;
          this.npcBlueMessageShown=false; this.mermaidMessageShown=false; this.npcYellowMessageShown=false;

          // Bind needed methods
          this.updateMovement=this.updateMovement.bind(this);
          this.animateArms=this.animateArms.bind(this);

          this.initScene();
          this.initKeyboardMouse();
          this.startAnimation();
        }

        initScene(){
          // ground
          const groundGeo=new THREE.PlaneGeometry(300,300);
          const groundMat=new THREE.MeshStandardMaterial({ color:0x6bb26b, side:THREE.DoubleSide });
          const ground=new THREE.Mesh(groundGeo,groundMat);
          ground.rotation.x=Math.PI/2;
          this.scene.add(ground);

          // rolling hills
          for(let i=0;i<100;i++){
            const r=80+Math.random()*60;
            const x=(Math.random()>0.5?1:-1)*(300+Math.random()*500);
            const z=(Math.random()>0.5?1:-1)*(300+Math.random()*500);
            const hillGeo=new THREE.SphereGeometry(r,16,16);
            const hillMat=new THREE.MeshStandardMaterial({ color:0x228b22, roughness:0.9 });
            const hill=new THREE.Mesh(hillGeo,hillMat);
            hill.position.set(x,-r/2,z);
            this.scene.add(hill);
          }

          // boundary shrubs
          for(let x=-130;x<=130;x+=4){
            this.addShrub(x,-130);
            this.addShrub(x,130);
          }
          for(let z=-130;z<=130;z+=4){
            this.addShrub(-130,z);
            this.addShrub(130,z);
          }

          // beach + water
          this.createBeach();

          // lighting
          const ambient=new THREE.AmbientLight(0x404040,0.6);
          this.scene.add(ambient);
          const dirLight=new THREE.DirectionalLight(0xffffff,0.8);
          dirLight.position.set(10,20,10);
          this.scene.add(dirLight);

          // sun, moon, stars
          this.createSun();
          this.createMoon();
          this.createStars();

          // player
          this.createPlayerModel();

          // buildings
          this.createCastle();
          this.createHouse();
          this.createCafe();
          this.createFountain();
          this.buildingPositions.push({ x:40, z:40 });
          this.buildingPositions.push({ x:-40, z:-40 });
          this.buildingPositions.push({ x:70, z:-30 });

          // NPCs
          this.createBlueNPC();
          this.createYellowNPC();
          this.createGuardAtCastle();
          this.createMermaid();
          this.createBird();

          // items
          this.createFlowers(10);
          this.createCoins(8);
          this.createGems(4);
          this.createPotions(3);
          this.createKeys(2);
          this.createArtifacts(2);

          // lamp posts
          this.createLampPosts();

          // camera
          this.camera.position.set(this.player.x+15,15,this.player.z+15);
          this.camera.lookAt(this.player.x,1,this.player.z);
        }

        addShrub(x,z){
          const geo=new THREE.CylinderGeometry(1,1,2,8);
          const mat=new THREE.MeshStandardMaterial({ color:0x228b22 });
          const shrub=new THREE.Mesh(geo,mat);
          shrub.position.set(x,1,z);
          this.scene.add(shrub);
          this.objects.push({ mesh:shrub, type:'boundary', x, z, boundingRadius:2 });
        }

        createBeach(){
          const beachGeo=new THREE.PlaneGeometry(300,30);
          const beachMat=new THREE.MeshStandardMaterial({ color:0xD2B48C, polygonOffset:true, polygonOffsetFactor:-1, polygonOffsetUnits:1 });
          const beach=new THREE.Mesh(beachGeo,beachMat);
          beach.rotation.x=-Math.PI/2;
          beach.position.set(0,0.01,-40);
          this.scene.add(beach);
          this.objects.push({ mesh:beach, type:'beach', x:0, z:-40, boundingRadius:0 });

          const waterGeo=new THREE.PlaneGeometry(300,30);
          const waterMat=new THREE.MeshStandardMaterial({ color:0x1E90FF, transparent:true, opacity:0.8, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:1 });
          const water=new THREE.Mesh(waterGeo,waterMat);
          water.rotation.x=-Math.PI/2;
          water.position.set(0,0.02,-70);
          this.scene.add(water);
          this.objects.push({ mesh:water, type:'water', x:0, z:-70, boundingRadius:0 });
        }

        createSun(){
          const sunGeo=new THREE.SphereGeometry(9,16,16);
          const sunMat=new THREE.MeshBasicMaterial({ color:0xffee00 });
          this.sunMesh=new THREE.Mesh(sunGeo,sunMat);
          this.sunMesh.position.set(0,200,-200);
          this.sunMesh.visible=true;
          this.scene.add(this.sunMesh);
          const glowGeo=new THREE.SphereGeometry(12,16,16);
          const glowMat=new THREE.MeshBasicMaterial({ color:0xffee00, transparent:true, opacity:0.3, blending:THREE.AdditiveBlending });
          const glow=new THREE.Mesh(glowGeo,glowMat);
          this.sunMesh.add(glow);
        }

        createMoon(){
          const moonGeo=new THREE.SphereGeometry(6,16,16);
          const moonMat=new THREE.MeshBasicMaterial({ color:0xcccccc });
          this.moonMesh=new THREE.Mesh(moonGeo,moonMat);
          this.moonMesh.position.set(-100,150,100);
          this.moonMesh.visible=false;
          this.scene.add(this.moonMesh);
          const moonGlowGeo=new THREE.SphereGeometry(8,16,16);
          const moonGlowMat=new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.2, blending:THREE.AdditiveBlending });
          const moonGlow=new THREE.Mesh(moonGlowGeo,moonGlowMat);
          this.moonMesh.add(moonGlow);
        }

        createStars(){
          const starCount=300;
          const positions=new Float32Array(starCount*3);
          for(let i=0;i<starCount;i++){
            const radius=300+Math.random()*200;
            const angle=Math.random()*Math.PI*2;
            const ySpread=Math.random()*200-50;
            positions[i*3]=Math.cos(angle)*radius;
            positions[i*3+1]=50+ySpread;
            positions[i*3+2]=Math.sin(angle)*radius;
          }
          const starGeo=new THREE.BufferGeometry();
          starGeo.setAttribute('position',new THREE.BufferAttribute(positions,3));
          const starMat=new THREE.PointsMaterial({ color:0xffffff, size:1.2, depthTest:false });
          const starField=new THREE.Points(starGeo,starMat);
          starField.visible=false;
          this.scene.add(starField);
          this.starsMesh=starField;
        }

        createPlayerModel(){
          const group=new THREE.Group();
          const body=new THREE.Mesh(
            new THREE.CylinderGeometry(0.4,0.5,1.2,16),
            new THREE.MeshStandardMaterial({ color:0xff69b4 })
          );
          body.position.set(0,0.6,0);
          group.add(body);
          const head=new THREE.Mesh(
            new THREE.SphereGeometry(0.3,16,16),
            new THREE.MeshStandardMaterial({ color:0xffddc1 })
          );
          head.position.set(0,1.4,0);
          group.add(head);
          const hair=new THREE.Mesh(
            new THREE.SphereGeometry(0.4,16,16),
            new THREE.MeshStandardMaterial({ color:0x4b2e05 })
          );
          hair.position.set(0,1.75,0);
          group.add(hair);
          const crown=new THREE.Mesh(
            new THREE.TorusGeometry(0.25,0.09,8,16),
            new THREE.MeshStandardMaterial({ color:0xffd700 })
          );
          crown.rotation.x=Math.PI/2;
          crown.position.set(0,1.95,0);
          group.add(crown);

          const armGeo=new THREE.CylinderGeometry(0.1,0.1,0.8,8);
          const skinMat=new THREE.MeshStandardMaterial({ color:0xffddc1 });
          const leftArm=new THREE.Mesh(armGeo,skinMat);
          leftArm.position.set(-0.5,1.0,0);
          leftArm.userData={ isArm:true, side:'left' };
          group.add(leftArm);
          const rightArm=new THREE.Mesh(armGeo,skinMat);
          rightArm.position.set(0.5,1.0,0);
          rightArm.userData={ isArm:true, side:'right' };
          group.add(rightArm);

          const legGeo=new THREE.CylinderGeometry(0.12,0.12,0.8,8);
          const leftLeg=new THREE.Mesh(legGeo,skinMat);
          leftLeg.position.set(-0.2,0.2,0);
          group.add(leftLeg);
          const rightLeg=new THREE.Mesh(legGeo,skinMat);
          rightLeg.position.set(0.2,0.2,0);
          group.add(rightLeg);

          group.position.set(this.player.x,this.player.y,this.player.z);
          this.player.object=group;
          this.scene.add(group);
        }

        createCastle(){/* same as before */}
        createHouse(){/* same as before */}
        createCafe(){/* same as before */}
        createFountain(){/* same as before */}
        createBlueNPC(){/* same as before */}
        createYellowNPC(){/* same as before */}
        createGuardAtCastle(){/* same as before */}
        createMermaid(){/* same as before */}
        createBird(){/* same as before */}
        createLampPosts(){/* same as before */}
        createFlowers(count){}
        createCoins(count){}
        createGems(count){}
        createPotions(count){}
        createKeys(count){}
        createArtifacts(count){}

        startAnimation(){
          const animate=()=>{
            requestAnimationFrame(animate);
            this.update();
            this.renderer.render(this.scene,this.camera);
          };
          animate();
        }

        update(){
          this.updateDayNight();
          this.updateBalls();
          this.updateGuard();
          this.updateMovement(); // important!

          this.updateBlueNPC();
          this.updateYellowNPC();
          // mermaid, bird, collisions, camera
          this.updateMermaid();
          this.updateBird();
          this.updateCollisions();
          this.updateCamera();
        }

        updateMovement(){
          // Keyboard
          let keyboardForward=0, keyboardTurn=0;
          if(this.keysPressed['ArrowUp']) keyboardForward+=1;
          if(this.keysPressed['ArrowDown']) keyboardForward-=1;
          if(this.keysPressed['ArrowLeft']) keyboardTurn+=1;
          if(this.keysPressed['ArrowRight']) keyboardTurn-=1;

          // Touch D-Pad
          let touchForward=0, touchStrafe=0;
          if(controllerState.dpadUp) touchForward+=1;
          if(controllerState.dpadDown) touchForward-=1;
          if(controllerState.dpadLeft) touchStrafe-=1;
          if(controllerState.dpadRight) touchStrafe+=1;

          let forwardInput=(keyboardForward!==0? keyboardForward: touchForward);
          let strafeInput=touchStrafe;

          // Turn from keyboard + L/R
          let turnInput=keyboardTurn;
          if(controllerState.turnLeft) turnInput+=1;
          if(controllerState.turnRight) turnInput-=1;

          // Movement
          const forwardVec=new THREE.Vector3(Math.sin(this.player.yaw),0,Math.cos(this.player.yaw));
          const rightVec=new THREE.Vector3(Math.cos(this.player.yaw),0,-Math.sin(this.player.yaw));
          const movement=forwardVec.clone().multiplyScalar(forwardInput)
                          .add(rightVec.clone().multiplyScalar(strafeInput));
          if(movement.length()>1) movement.normalize();
          movement.multiplyScalar(this.player.speedKeyboard);

          // Simple no-collision
          this.player.x+=movement.x;
          this.player.z+=movement.z;

          // Turn
          this.player.yaw+=turnInput*0.02;

          // Jump physics
          if(this.player.jumpVelocity!==0 || this.player.y>0.5){
            this.player.jumpVelocity-=0.02;
            this.player.y+=this.player.jumpVelocity;
            if(this.player.y<0.5){
              this.player.y=0.5; this.player.jumpVelocity=0;
            }
          }

          // Update player object
          if(this.player.object){
            this.player.object.position.set(this.player.x,this.player.y,this.player.z);
            this.player.object.rotation.y=this.player.yaw;
          }

          // Animate arms if moving
          if(forwardInput!==0 || strafeInput!==0){
            this.animateArms(this.player.object,true);
          } else {
            this.animateArms(this.player.object,false);
          }
        }

        updateDayNight(){/* same as before */}
        updateGuard(){/* same as before */}
        updateBlueNPC(){/* same as before */}
        updateYellowNPC(){/* same as before */}
        updateMermaid(){/* stub */}
        updateBird(){/* stub */}
        updateCollisions(){/* stub for dialogues */}
        updateCamera(){
          // 3rd-person camera behind player
          const camDist=15;
          const offsetX=-Math.sin(this.player.yaw)*camDist;
          const offsetZ=-Math.cos(this.player.yaw)*camDist;
          const offsetY=10;
          this.camera.position.set(
            this.player.x+offsetX,
            this.player.y+offsetY,
            this.player.z+offsetZ
          );
          this.camera.lookAt(
            this.player.x,
            this.player.y+1,
            this.player.z
          );
        }

        updateBalls(){
          for(let i=this.thrownBalls.length-1; i>=0; i--){
            const ball=this.thrownBalls[i];
            ball.position.add(ball.userData.velocity);
            ball.userData.velocity.y-=0.01;
            // Let’s remove after 5s
            if(!ball.userData.timer) ball.userData.timer=0;
            ball.userData.timer++;
            if(ball.userData.timer>300){ // ~5s at 60fps
              this.scene.remove(ball);
              this.thrownBalls.splice(i,1);
              continue;
            }
            // If ball hits ground, bounce once
            if(ball.position.y<0){
              if(!ball.userData.bounced){
                ball.position.y=0;
                ball.userData.velocity.y*=-0.7;
                ball.userData.bounced=true;
              } else if(ball.position.y<-0.5){
                this.scene.remove(ball);
                this.thrownBalls.splice(i,1);
              }
            }
          }
        }

        animateArms(obj, isMoving){
          if(!obj) return;
          const t=Date.now()*0.002;
          obj.traverse(child=>{
            if(child.userData && child.userData.isArm){
              if(isMoving){
                if(child.userData.side==='left'){
                  child.rotation.x=Math.sin(t)*0.5;
                } else {
                  child.rotation.x=-Math.sin(t)*0.5;
                }
              } else {
                child.rotation.x=0;
              }
            }
          });
        }

        throwBall(){
          // Show in console that button is pressed
          console.log("A button pressed -> throwBall()");
          const direction=new THREE.Vector3(Math.sin(this.player.yaw),0,Math.cos(this.player.yaw));
          const ballGeo=new THREE.SphereGeometry(0.3,16,16);
          const ballMat=new THREE.MeshStandardMaterial({ color:0xff4500 });
          const ball=new THREE.Mesh(ballGeo,ballMat);
          ball.position.set(this.player.x,this.player.y,this.player.z);
          ball.position.y+=1;
          ball.userData={
            velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
            bounced:false,
            timer:0
          };
          this.scene.add(ball);
          this.thrownBalls.push(ball);
          this.ballCount++;
          document.getElementById('ballCountValue').textContent=this.ballCount;
          this.showDialogue("Threw a magic ball!");
        }

        jump(){
          // Show in console that button is pressed
          console.log("B button pressed -> jump()");
          if(this.player.y<=0.5){
            this.player.jumpVelocity=0.3;
            this.showDialogue("Jump!");
          }
        }

        showDialogue(text){
          const dlg=document.getElementById('dialogue');
          dlg.style.display='block';
          dlg.textContent=text;
          setTimeout(()=>{
            dlg.style.display='none';
            dlg.textContent='';
          },1500);
        }

        initKeyboardMouse(){
          document.addEventListener('keydown', e=>{
            this.keysPressed[e.key]=true;
            if(e.key===' ') this.throwBall();
          });
          document.addEventListener('keyup', e=>{
            this.keysPressed[e.key]=false;
          });
          document.addEventListener('mousedown', ()=>{
            try{ document.body.requestPointerLock(); }
            catch(err){ console.warn('Pointer lock failed:',err); }
          });
          document.addEventListener('mousemove', evt=>{
            if(document.pointerLockElement===document.body){
              const movementX=evt.movementX||0;
              const sensitivity=0.001;
              this.player.yaw+=movementX*sensitivity;
            }
          });
        }
      }

      window.game=new Game();
    }catch(err){
      console.error('Error initializing the game:',err);
    }
  </script>
</body>
</html>
