<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town – Full Game</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas { display: block; }

    /* UI boxes */
    #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
      background: rgba(0,0,0,0.7);
      border: 4px solid #fff;
      border-radius: 5px;
      color: #fff;
      font-size: 28px;
      padding: 20px 30px;
      position: absolute;
      z-index: 10;
    }
    #ui         { top: 10px; left: 10px; }
    #ballCount  { top: 10px; right: 10px; }
    #dialogue   { bottom: 10px; left: 10px; max-width: 600px; display: none; }
    #controls   { bottom: 10px; right: 10px; }
    #errorMessage {
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      display: none;
    }
    #guardPopup {
      bottom: 50%; left: 50%;
      transform: translate(-50%,50%);
      display: none; text-align: center;
    }
    /* Toggle UI button */
    #toggleUIBtn {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      font-size: 24px;
      padding: 10px 20px;
      background: #333;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 5px;
      cursor: pointer;
    }
    /* On-screen Controller Panels */
    #dpadContainer, #turnContainer, #actionContainer {
      position: absolute;
      z-index: 15;
    }
    /* D-Pad as a grid with a small gap */
    #dpadContainer {
      bottom: 16vh;
      left: 5vw;
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
    }
    #btnUp    { grid-column: 2; grid-row: 1; }
    #btnDown  { grid-column: 2; grid-row: 3; }
    #btnLeft  { grid-column: 1; grid-row: 2; }
    #btnRight { grid-column: 3; grid-row: 2; }
    #dpadContainer button {
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
    }
    #turnContainer {
      bottom: 16vh;
      left: calc(5vw + 200px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #turnContainer button, #actionContainer button {
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px;
      color: #fff;
      cursor: pointer;
    }
    #actionContainer {
      bottom: 16vh;
      left: calc(5vw + 200px + 70px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    /* Responsive adjustments */
    @media (max-width: 768px) {
      #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
        font-size: 16px;
        padding: 10px 15px;
      }
      #toggleUIBtn { font-size: 16px; }
      #dpadContainer {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
      }
      #dpadContainer button {
        width: 50px;
        height: 50px;
        font-size: 14px;
      }
      #turnContainer button, #actionContainer button {
        width: 50px;
        height: 50px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>
    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifacts: <span id="artifacts">0</span> |
      Health: <span id="health">100</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
    <div id="dialogue"></div>
    <div id="controls">
      Controls:<br>
      [Desktop] Arrow Up/Down = forward/back, Left/Right = turn, Space = throw ball<br>
      [Mobile] D‑Pad Up/Down = forward/back, Left/Right = strafe, L/R = turn, A = throw ball, B = jump
    </div>
    <div id="errorMessage">WebGL not supported in your browser.</div>
    <div id="guardPopup"></div>
    <!-- On-screen Controller Panels -->
    <div id="dpadContainer">
      <button id="btnUp">▲</button>
      <button id="btnDown">▼</button>
      <button id="btnLeft">◀</button>
      <button id="btnRight">▶</button>
    </div>
    <div id="turnContainer">
      <button id="btnTurnLeft">L</button>
      <button id="btnTurnRight">R</button>
    </div>
    <div id="actionContainer">
      <button id="btnThrow">A</button>
      <button id="btnBigThrow">B</button>
    </div>
  </div>

  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Toggle UI
    document.getElementById('toggleUIBtn').addEventListener('click', () => {
      const ids = ["ui", "ballCount", "dialogue", "controls", "guardPopup", "errorMessage"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        el.style.display = (el.style.display === "none") ? "block" : "none";
      });
    });

    // Prevent text highlighting on mobile
    function disableHighlight(id) {
      const btn = document.getElementById(id);
      ["touchstart", "mousedown"].forEach(evt => {
        btn.addEventListener(evt, e => { e.preventDefault(); }, { passive: false });
      });
    }
    ["btnUp", "btnDown", "btnLeft", "btnRight", "btnTurnLeft", "btnTurnRight", "btnThrow", "btnBigThrow"]
      .forEach(disableHighlight);

    // On-screen controller state
    const controllerState = {
      dpadUp: false, dpadDown: false, dpadLeft: false, dpadRight: false,
      turnLeft: false, turnRight: false
    };
    function setButtonListener(btnId, stateProp) {
      const btn = document.getElementById(btnId);
      ["mousedown", "touchstart"].forEach(evt => {
        btn.addEventListener(evt, e => {
          e.preventDefault();
          controllerState[stateProp] = true;
        }, { passive: false });
      });
      ["mouseup", "touchend", "mouseleave"].forEach(evt => {
        btn.addEventListener(evt, e => { controllerState[stateProp] = false; });
      });
    }
    setButtonListener('btnUp', 'dpadUp');
    setButtonListener('btnDown', 'dpadDown');
    setButtonListener('btnLeft', 'dpadLeft');
    setButtonListener('btnRight', 'dpadRight');
    setButtonListener('btnTurnLeft', 'turnLeft');
    setButtonListener('btnTurnRight', 'turnRight');

    // A/B button actions
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game && typeof window.game.throwBall === "function") {
          window.game.throwBall();
        }
      }, { passive: false });
    });
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnBigThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game && typeof window.game.jump === "function") {
          window.game.jump();
        }
      }, { passive: false });
    });

    // Global variables for scene switching
    let game = null;
    const keysPressed = {};
    const outsideScene = new THREE.Scene();
    const insideScene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
    let activeScene = outsideScene;
    let isInsideCastle = false;

    // Main Game class
    class Game {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        const isMobile = (window.innerWidth < 768);
        this.renderer.setPixelRatio(isMobile ? 1 : window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('gameCanvas').style.display = 'block';

        // Player
        this.player = {
          x: 0, y: 0.5, z: 0,
          speedKeyboard: 0.1,
          yaw: 0, pitch: 0,
          jumpVelocity: 0,
          object: null
        };

        // Stats
        this.flowers = 0; this.coins = 0; this.gems = 0;
        this.potions = 0; this.keys = 0; this.artifacts = 0;
        this.health = 100;
        this.ballCount = 0;
        this.thrownBalls = [];
        this.keysPressed = keysPressed;
        this.dayNightCounter = 0;
        this.time = "Day";

        // Collision arrays
        this.outsideObjects = [];
        this.insideObjects = [];

        // NPC and Piazza data
        this.npcBlueData = null;
        this.npcYellowData = null;
        this.birdData = null;
        this.piazzaNPCData = [];

        // Initialize scenes
        this.initOutsideScene();
        this.initInsideScene();
        activeScene = outsideScene;
        isInsideCastle = false;
        document.getElementById('location').textContent = "Town";

        // Set up input and start animation
        this.initKeyboardMouse();
        this.startAnimation();
      }

      // Outside Scene Initialization
      initOutsideScene() {
        outsideScene.background = new THREE.Color(0x87CEEB);
        // Ground
        const groundGeo = new THREE.PlaneGeometry(300, 300);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x6bb26b, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = Math.PI / 2;
        outsideScene.add(ground);

        // Lighting
        const ambient = new THREE.AmbientLight(0x404040, 0.6);
        outsideScene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        outsideScene.add(dirLight);

        // Sun/Moon/Stars
        this.createSun(outsideScene);
        this.createMoon(outsideScene);
        this.createStars(outsideScene);

        // Player model
        this.createPlayerModel();
        outsideScene.add(this.player.object);
        this.player.x = 0; this.player.y = 0.5; this.player.z = 0;

        // Boundary shrubs
        for (let x = -130; x <= 130; x += 4) {
          this.addShrub(outsideScene, x, -130);
          this.addShrub(outsideScene, x, 130);
        }
        for (let z = -130; z <= 130; z += 4) {
          this.addShrub(outsideScene, -130, z);
          this.addShrub(outsideScene, 130, z);
        }

        // Beach/Water
        this.createBeach(outsideScene);

        // Hills
        const hillCount = (window.innerWidth < 768) ? 30 : 60;
        for (let i = 0; i < hillCount; i++) {
          const r = 80 + Math.random() * 60;
          const hx = (Math.random() > 0.5 ? 1 : -1) * (300 + Math.random() * 500);
          const hz = (Math.random() > 0.5 ? 1 : -1) * (300 + Math.random() * 500);
          const hillGeo = new THREE.SphereGeometry(r, 16, 16);
          const hillMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.9 });
          const hill = new THREE.Mesh(hillGeo, hillMat);
          hill.position.set(hx, -r / 2, hz);
          outsideScene.add(hill);
        }

        // Buildings
        this.createCastle(outsideScene);
        this.createHouse(outsideScene);
        this.createCafe(outsideScene);
        this.createFountain(outsideScene);

        // NPCs
        this.createBlueNPC(outsideScene);
        this.createYellowNPC(outsideScene);
        this.createGuardAtCastle(outsideScene);
        this.createMermaid(outsideScene);
        this.createBird(outsideScene);

        // Items
        this.createFlowers(outsideScene, 10);
        this.createCoins(outsideScene, 8);
        this.createGems(outsideScene, 4);
        this.createPotions(outsideScene, 3);
        this.createKeys(outsideScene, 2);
        this.createArtifacts(outsideScene, 2);

        // Piazza
        this.createPiazza(outsideScene);
        this.createPiazzaNPCs(outsideScene);

        // Lamp posts
        this.createLampPosts(outsideScene);

        // Position camera
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 1, 0);
      }

      // Inside Scene Initialization
      initInsideScene() {
        insideScene.background = new THREE.Color(0x333333);
        // Floor
        const floorSize = 60;
        const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize);
        const floorTex = this.generateStoneTexture();
        const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        insideScene.add(floor);

        // Walls and Ceiling
        const wallHeight = 20, thickness = 1;
        const wallMat = new THREE.MeshStandardMaterial({ map: floorTex });
        const frontWall = new THREE.Mesh(new THREE.BoxGeometry(floorSize, wallHeight, thickness), wallMat.clone());
        frontWall.position.set(0, wallHeight / 2, floorSize / 2);
        insideScene.add(frontWall);
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(floorSize, wallHeight, thickness), wallMat.clone());
        backWall.position.set(0, wallHeight / 2, -floorSize / 2);
        insideScene.add(backWall);
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(thickness, wallHeight, floorSize), wallMat.clone());
        leftWall.position.set(-floorSize / 2, wallHeight / 2, 0);
        insideScene.add(leftWall);
        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(thickness, wallHeight, floorSize), wallMat.clone());
        rightWall.position.set(floorSize / 2, wallHeight / 2, 0);
        insideScene.add(rightWall);
        const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), wallMat);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = wallHeight;
        insideScene.add(ceiling);

        // Lighting
        const amb = new THREE.AmbientLight(0xffffff, 0.4);
        insideScene.add(amb);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(10, 20, 10);
        insideScene.add(dir);

        // Exit door
        const doorGeo = new THREE.PlaneGeometry(4, 6);
        const doorMat = new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide });
        const exitDoor = new THREE.Mesh(doorGeo, doorMat);
        exitDoor.position.set(0, 3, -floorSize / 2 + 1);
        insideScene.add(exitDoor);
        this.castleExit = { x: 0, z: -28, boundingRadius: 2 };
      }

      // Castle entry/exit logic
      enterCastle() {
        isInsideCastle = true;
        document.getElementById('location').textContent = "Castle Interior";
        if (this.player.object && outsideScene.children.includes(this.player.object)) {
          outsideScene.remove(this.player.object);
        }
        insideScene.add(this.player.object);
        this.player.x = 0; this.player.y = 0.5; this.player.z = 0;
        this.player.yaw = Math.PI;
        activeScene = insideScene;
      }
      exitCastle() {
        isInsideCastle = false;
        document.getElementById('location').textContent = "Town";
        if (this.player.object && insideScene.children.includes(this.player.object)) {
          insideScene.remove(this.player.object);
        }
        outsideScene.add(this.player.object);
        this.player.x = 40; this.player.y = 0.5; this.player.z = 55;
        this.player.yaw = 0;
        activeScene = outsideScene;
      }
      checkCastleDoor() {
        if (isInsideCastle) return;
        const dx = this.player.x - 40;
        const dz = this.player.z - 50;
        if (dx * dx + dz * dz < 9) {
          this.enterCastle();
        }
      }
      checkCastleExitDoor() {
        if (!isInsideCastle || !this.castleExit) return;
        const dx = this.player.x - this.castleExit.x;
        const dz = this.player.z - this.castleExit.z;
        if (dx * dx + dz * dz < this.castleExit.boundingRadius * this.castleExit.boundingRadius) {
          this.exitCastle();
        }
      }

      // Animation loop
      startAnimation() {
        const animate = () => {
          requestAnimationFrame(animate);
          this.update();
          this.renderer.render(activeScene, camera);
        };
        animate();
      }

      // Update functions
      update() {
        this.updateDayNight();
        this.updateBalls();
        this.updateMovement();
        this.updateCollisions();
        if (!isInsideCastle) {
          this.updateBlueNPC();
          this.updateYellowNPC();
          this.updateMermaid();
          this.updateBird();
          this.updatePiazzaNPCs();
          this.updatePickups();
          this.checkCastleDoor();
        } else {
          this.checkCastleExitDoor();
        }
        this.updateCamera();
      }

      updateDayNight() {
        if (!isInsideCastle) {
          this.dayNightCounter = (this.dayNightCounter + 1) % 18000;
          this.time = (this.dayNightCounter < 9000) ? "Day" : "Night";
          document.getElementById('time').textContent = this.time;
          if (this.time === "Day") {
            outsideScene.background = new THREE.Color(0x87CEEB);
            if (this.sunMesh) this.sunMesh.visible = true;
            if (this.moonMesh) this.moonMesh.visible = false;
            if (this.starsMesh) this.starsMesh.visible = false;
          } else {
            outsideScene.background = new THREE.Color(0x000000);
            if (this.sunMesh) this.sunMesh.visible = false;
            if (this.moonMesh) this.moonMesh.visible = true;
            if (this.starsMesh) this.starsMesh.visible = true;
          }
        }
      }

      getCollisionObjects() {
        return isInsideCastle ? this.insideObjects : this.outsideObjects;
      }

      updateMovement() {
        let keyboardForward = 0, keyboardTurn = 0;
        if (this.keysPressed['ArrowUp']) keyboardForward++;
        if (this.keysPressed['ArrowDown']) keyboardForward--;
        if (this.keysPressed['ArrowLeft']) keyboardTurn++;
        if (this.keysPressed['ArrowRight']) keyboardTurn--;
        let touchForward = 0, touchStrafe = 0;
        if (controllerState.dpadUp) touchForward++;
        if (controllerState.dpadDown) touchForward--;
        if (controllerState.dpadLeft) touchStrafe++;
        if (controllerState.dpadRight) touchStrafe--;
        let finalForward = (keyboardForward !== 0 ? keyboardForward : touchForward);
        let finalStrafe = touchStrafe;
        let finalTurn = keyboardTurn;
        if (controllerState.turnLeft) finalTurn++;
        if (controllerState.turnRight) finalTurn--;
        const forwardVec = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
        const rightVec = new THREE.Vector3(Math.cos(this.player.yaw), 0, -Math.sin(this.player.yaw));
        const movement = forwardVec.clone().multiplyScalar(finalForward)
                           .add(rightVec.clone().multiplyScalar(finalStrafe));
        if (movement.length() > 1) movement.normalize();
        const speedMult = isInsideCastle ? 1.0 : 2.5;
        movement.multiplyScalar(this.player.speedKeyboard * speedMult);
        const newX = this.player.x + movement.x;
        const newZ = this.player.z + movement.z;
        let canMove = true;
        const collObjs = this.getCollisionObjects();
        for (const obj of collObjs) {
          if (['boundary', 'building', 'decoration', 'npc', 'guard', 'mermaid'].includes(obj.type)) {
            const dx = newX - obj.x;
            const dz = newZ - obj.z;
            const minDist = (obj.boundingRadius || 1) + 0.5;
            if (dx * dx + dz * dz < minDist * minDist) {
              canMove = false;
              break;
            }
          }
        }
        if (canMove) {
          this.player.x = newX;
          this.player.z = newZ;
        }
        if (isInsideCastle) {
          const floorSize = 60;
          const minX = -floorSize / 2 + 2;
          const maxX = floorSize / 2 - 2;
          const minZ = -floorSize / 2 + 2;
          const maxZ = floorSize / 2 - 2;
          this.player.x = Math.max(minX, Math.min(maxX, this.player.x));
          this.player.z = Math.max(minZ, Math.min(maxZ, this.player.z));
        }
        this.player.yaw += finalTurn * 0.02;
        // Jump physics
        if (this.player.jumpVelocity !== 0 || this.player.y > 0.5) {
          this.player.jumpVelocity -= 0.02;
          this.player.y += this.player.jumpVelocity;
          if (this.player.y < 0.5) {
            this.player.y = 0.5;
            this.player.jumpVelocity = 0;
          }
        }
        if (this.player.object) {
          this.player.object.position.set(this.player.x, this.player.y, this.player.z);
          this.player.object.rotation.y = this.player.yaw;
        }
        if (finalForward !== 0 || finalStrafe !== 0) {
          this.animateArms(this.player.object, true);
        } else {
          this.animateArms(this.player.object, false);
        }
      }

      updateCamera() {
        const camDist = 15;
        const offsetX = -Math.sin(this.player.yaw) * camDist;
        const offsetZ = -Math.cos(this.player.yaw) * camDist;
        const offsetY = 10;
        camera.position.set(this.player.x + offsetX, this.player.y + offsetY, this.player.z + offsetZ);
        camera.lookAt(this.player.x, this.player.y + 1, this.player.z);
      }

      updateCollisions() {}

      // Player Model and Animation
      createPlayerModel() {
        if (!this.player.object) {
          const group = new THREE.Group();
          const body = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16),
            new THREE.MeshStandardMaterial({ color: 0xff69b4 })
          );
          body.position.y = 0.6;
          group.add(body);
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xffddc1 })
          );
          head.position.y = 1.4;
          group.add(head);
          const hair = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x4b2e05 })
          );
          hair.position.y = 1.75;
          group.add(hair);
          const crown = new THREE.Mesh(
            new THREE.TorusGeometry(0.25, 0.09, 8, 16),
            new THREE.MeshStandardMaterial({ color: 0xffd700 })
          );
          crown.rotation.x = Math.PI / 2;
          crown.position.y = 1.95;
          group.add(crown);
          const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
          const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
          const leftArm = new THREE.Mesh(armGeo, skinMat);
          leftArm.position.set(-0.5, 1.0, 0);
          leftArm.userData = { isArm: true, side: 'left' };
          group.add(leftArm);
          const rightArm = new THREE.Mesh(armGeo, skinMat);
          rightArm.position.set(0.5, 1.0, 0);
          rightArm.userData = { isArm: true, side: 'right' };
          group.add(rightArm);
          const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 8);
          const leftLeg = new THREE.Mesh(legGeo, skinMat);
          leftLeg.position.set(-0.2, 0.2, 0);
          group.add(leftLeg);
          const rightLeg = new THREE.Mesh(legGeo, skinMat);
          rightLeg.position.set(0.2, 0.2, 0);
          group.add(rightLeg);
          group.position.set(this.player.x, this.player.y, this.player.z);
          this.player.object = group;
        }
      }

      animateArms(obj, isMoving) {
        if (!obj) return;
        const t = Date.now() * 0.002;
        obj.traverse(child => {
          if (child.userData && child.userData.isArm) {
            if (isMoving) {
              child.rotation.x = (child.userData.side === 'left') ? Math.sin(t) * 0.5 : -Math.sin(t) * 0.5;
            } else {
              child.rotation.x = 0;
            }
          }
        });
      }

      // Environment Helpers
      generateStoneTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        for (let y = 0; y < canvas.height; y += 16) {
          for (let x = 0; x < canvas.width; x += 16) {
            const shade = 120 + Math.floor(Math.random() * 40);
            ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
            ctx.fillRect(x, y, 16, 16);
          }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(1, 1);
        return tex;
      }

      createSun(sceneRef) {
        const sunGeo = new THREE.SphereGeometry(9, 16, 16);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xffee00 });
        this.sunMesh = new THREE.Mesh(sunGeo, sunMat);
        this.sunMesh.position.set(0, 200, -200);
        this.sunMesh.visible = true;
        sceneRef.add(this.sunMesh);
        const glowGeo = new THREE.SphereGeometry(12, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xffee00, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        this.sunMesh.add(glow);
      }
      createMoon(sceneRef) {
        const moonGeo = new THREE.SphereGeometry(6, 16, 16);
        const moonMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
        this.moonMesh = new THREE.Mesh(moonGeo, moonMat);
        this.moonMesh.position.set(-100, 150, 100);
        this.moonMesh.visible = false;
        sceneRef.add(this.moonMesh);
        const moonGlowGeo = new THREE.SphereGeometry(8, 16, 16);
        const moonGlowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
        const moonGlow = new THREE.Mesh(moonGlowGeo, moonGlowMat);
        this.moonMesh.add(moonGlow);
      }
      createStars(sceneRef) {
        const starCount = 300;
        const positions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
          const radius = 300 + Math.random() * 200;
          const angle = Math.random() * Math.PI * 2;
          const ySpread = Math.random() * 200 - 50;
          positions[i * 3] = Math.cos(angle) * radius;
          positions[i * 3 + 1] = 50 + ySpread;
          positions[i * 3 + 2] = Math.sin(angle) * radius;
        }
        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, depthTest: false });
        const starField = new THREE.Points(starGeo, starMat);
        starField.visible = false;
        sceneRef.add(starField);
        this.starsMesh = starField;
      }

      addShrub(sceneRef, x, z) {
        const geo = new THREE.CylinderGeometry(1, 1, 2, 8);
        const mat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
        const shrub = new THREE.Mesh(geo, mat);
        shrub.position.set(x, 1, z);
        sceneRef.add(shrub);
        this.outsideObjects.push({ mesh: shrub, type: 'boundary', x: x, z: z, boundingRadius: 2 });
      }

      createBeach(sceneRef) {
        const beachGeo = new THREE.PlaneGeometry(300, 30);
        const beachMat = new THREE.MeshStandardMaterial({ color: 0xD2B48C, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: 1 });
        const beach = new THREE.Mesh(beachGeo, beachMat);
        beach.rotation.x = -Math.PI / 2;
        beach.position.set(0, 0.01, -40);
        sceneRef.add(beach);
        this.outsideObjects.push({ mesh: beach, type: 'boundary', x: 0, z: -40, boundingRadius: 2 });
        const waterGeo = new THREE.PlaneGeometry(300, 30);
        const waterMat = new THREE.MeshStandardMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.8, polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: 1 });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.rotation.x = -Math.PI / 2;
        water.position.set(0, 0.02, -70);
        sceneRef.add(water);
        this.outsideObjects.push({ mesh: water, type: 'water', x: 0, z: -70, boundingRadius: 2 });
      }

      // Building Creation
      createCastle(sceneRef) {
        const group = new THREE.Group();
        const stoneTex = this.generateStoneTexture();
        const baseMat = new THREE.MeshStandardMaterial({ map: stoneTex, roughness: 0.6, metalness: 0.1 });
        const base = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 20), baseMat);
        base.position.set(0, 5, 0);
        group.add(base);
        const towerGeo = new THREE.CylinderGeometry(3, 3, 15, 16);
        [[10,7.5,10],[-10,7.5,10],[10,7.5,-10],[-10,7.5,-10]].forEach(coords => {
          const tower = new THREE.Mesh(towerGeo, baseMat.clone());
          tower.position.set(coords[0], coords[1], coords[2]);
          group.add(tower);
        });
        const door = new THREE.Mesh(new THREE.PlaneGeometry(4, 6),
          new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide }));
        door.position.set(0, 3, 10.01);
        group.add(door);
        group.position.set(40, 0, 40);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'building', x: 40, z: 40, boundingRadius: 8 });
      }
      createHouse(sceneRef) {
        const group = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(12, 8, 10),
          new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7 }));
        base.position.set(0, 4, 0);
        group.add(base);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(6, 4, 4),
          new THREE.MeshStandardMaterial({ color: 0x800000, roughness: 0.6 }));
        roof.position.set(0, 8, 0);
        roof.rotation.y = Math.PI / 4;
        group.add(roof);
        const door = new THREE.Mesh(new THREE.PlaneGeometry(2, 4),
          new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide }));
        door.position.set(0, 2, 5.01);
        group.add(door);
        const doorLight = new THREE.PointLight(0xffeeaa, 0.8, 10);
        doorLight.position.set(3, 3, 6);
        group.add(doorLight);
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'black'; ctx.fillRect(0, 0, 128, 32);
        ctx.fillStyle = 'white'; ctx.font = '16px Arial';
        ctx.fillText("Donia's House", 5, 22);
        const tex = new THREE.Texture(canvas);
        tex.needsUpdate = true;
        const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
        const signGeo = new THREE.PlaneGeometry(4, 1);
        const signMesh = new THREE.Mesh(signGeo, signMat);
        signMesh.position.set(0, 5, 4.05);
        group.add(signMesh);
        group.position.set(-40, 0, -40);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'building', x: -40, z: -40, boundingRadius: 10 });
      }
      createCafe(sceneRef) {
        const group = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(12, 7, 10),
          new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.3, roughness: 0.5 }));
        base.position.set(0, 3.5, 0);
        group.add(base);
        const door = new THREE.Mesh(new THREE.PlaneGeometry(2, 3),
          new THREE.MeshStandardMaterial({ color: 0x553300, side: THREE.DoubleSide }));
        door.position.set(0, 1.5, 5.01);
        group.add(door);
        const doorLight = new THREE.PointLight(0xffeeaa, 0.8, 10);
        doorLight.position.set(-3, 2.5, 6.5);
        group.add(doorLight);
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'black'; ctx.fillRect(0, 0, 256, 64);
        ctx.fillStyle = 'white'; ctx.font = '30px Arial'; ctx.textAlign = 'center';
        ctx.fillText("Donia's Cafe", 128, 40);
        const tex = new THREE.Texture(canvas);
        tex.needsUpdate = true;
        const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
        const signGeo = new THREE.PlaneGeometry(8, 2);
        const signMesh = new THREE.Mesh(signGeo, signMat);
        signMesh.position.set(0, 3.5, 4.05);
        group.add(signMesh);
        group.position.set(70, 0, -30);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'building', x: 70, z: -30, boundingRadius: 10 });
      }
      createFountain(sceneRef) {
        const group = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 1, 16),
          new THREE.MeshStandardMaterial({ color: 0x808080 }));
        base.position.set(0, 0.5, 0);
        group.add(base);
        const bowl = new THREE.Mesh(new THREE.TorusGeometry(3, 0.3, 16, 32),
          new THREE.MeshStandardMaterial({ color: 0x808080 }));
        bowl.rotation.x = Math.PI / 2;
        bowl.position.y = 1;
        group.add(bowl);
        const water = new THREE.Mesh(new THREE.CylinderGeometry(2.8, 2.8, 0.2, 16),
          new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 }));
        water.position.set(0, 1.1, 0);
        group.add(water);
        group.position.set(0, 0, 20);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'decoration', x: 0, z: 20, boundingRadius: 3 });
      }

      // NPCs and Items
      createBlueNPC(sceneRef) {
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16),
          new THREE.MeshStandardMaterial({ color: 0x0000ff })
        );
        body.position.y = 0.6;
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 })
        );
        head.position.y = 1.4;
        group.add(head);
        const hair = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0x4b2e05 })
        );
        hair.position.y = 1.75;
        group.add(hair);
        const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5, 1.0, 0);
        leftArm.userData = { isArm: true, side: 'left' };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5, 1.0, 0);
        rightArm.userData = { isArm: true, side: 'right' };
        group.add(rightArm);
        group.position.set(120, 0.5, 0);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'npc', x: 120, z: 0, boundingRadius: 1 });
        this.npcBlueData = { angle: 0, speed: 0.001, radius: 120, object: group };
      }
      createYellowNPC(sceneRef) {
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 1.0, 16),
          new THREE.MeshStandardMaterial({ color: 0xffff00 })
        );
        body.position.y = 0.5;
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 })
        );
        head.position.y = 1.1;
        group.add(head);
        const hair = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0x4b2e05 })
        );
        hair.position.y = 1.55;
        group.add(hair);
        const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5, 0.8, 0);
        leftArm.userData = { isArm: true, side: 'left' };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5, 0.8, 0);
        rightArm.userData = { isArm: true, side: 'right' };
        group.add(rightArm);
        group.position.set(-30, 0.3, 30);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'npc', x: -30, z: 30, boundingRadius: 1 });
        this.npcYellowData = { object: group, speed: 0.03, target: null };
      }
      createGuardAtCastle(sceneRef) {
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16),
          new THREE.MeshStandardMaterial({ color: 0x000000 })
        );
        body.position.y = 0.6;
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 })
        );
        head.position.y = 1.4;
        group.add(head);
        const hair = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0x4b2e05 })
        );
        hair.position.y = 1.75;
        group.add(hair);
        const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5, 1.0, 0);
        leftArm.userData = { isArm: true, side: 'left' };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5, 1.0, 0);
        rightArm.userData = { isArm: true, side: 'right' };
        group.add(rightArm);
        group.position.set(45, 0.5, 55.5);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'guard', x: 45, z: 55.5, boundingRadius: 2 });
      }
      createMermaid(sceneRef) {
        const group = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.5, 0.6, 16),
          new THREE.MeshStandardMaterial({ color: 0xff69b4 })
        );
        body.position.y = 0.9;
        group.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffddc1 })
        );
        head.position.y = 1.4;
        group.add(head);
        const hair = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0x4b2e05 })
        );
        hair.position.y = 1.8;
        group.add(hair);
        const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5, 1.1, 0);
        leftArm.userData = { isArm: true, side: 'left' };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5, 1.1, 0);
        rightArm.userData = { isArm: true, side: 'right' };
        group.add(rightArm);
        group.position.set(20, -0.5, -70);
        sceneRef.add(group);
        this.outsideObjects.push({ mesh: group, type: 'mermaid', x: 20, z: -70, boundingRadius: 2 });
      }
      createBird(sceneRef) {
        const bird = new THREE.Mesh(
          new THREE.SphereGeometry(0.5, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        bird.position.set(0, 60, 0);
        sceneRef.add(bird);
        this.birdData = { angle: 0, speed: 0.002, radius: 140, object: bird };
      }
      createLampPosts(sceneRef) {
        for (let i = 0; i < 20; i++) {
          const angle = (i / 20) * Math.PI * 2;
          const radius = 130;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          const postGeo = new THREE.CylinderGeometry(0.2, 0.2, 4, 8);
          const postMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
          const post = new THREE.Mesh(postGeo, postMat);
          post.position.set(x, 2, z);
          const lampGeo = new THREE.SphereGeometry(0.4, 8, 8);
          const lampMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 0.4 });
          const lamp = new THREE.Mesh(lampGeo, lampMat);
          lamp.position.set(x, 4, z);
          const light = new THREE.PointLight(0xffffaa, 0.7, 20);
          light.position.set(x, 4, z);
          sceneRef.add(post, lamp, light);
        }
      }
      createPiazza(sceneRef) {
        const size = 15;
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        for (let y = 0; y < canvas.height; y += 16) {
          for (let x = 0; x < canvas.width; x += 16) {
            const shade = 150 + Math.floor(Math.random() * 50);
            ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
            ctx.fillRect(x, y, 16, 16);
          }
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(2, 2);
        const piazzaGeo = new THREE.PlaneGeometry(size, size);
        const piazzaMat = new THREE.MeshStandardMaterial({ map: texture });
        const piazza = new THREE.Mesh(piazzaGeo, piazzaMat);
        piazza.rotation.x = -Math.PI / 2;
        piazza.position.set(0, 0.02, 0);
        sceneRef.add(piazza);
        const corners = [ { x: 7, z: 7 }, { x: 7, z: -7 }, { x: -7, z: 7 }, { x: -7, z: -7 } ];
        corners.forEach(c => {
          const pl = new THREE.PointLight(0xffeeaa, 0.6, 10);
          pl.position.set(c.x, 3, c.z);
          sceneRef.add(pl);
        });
      }
      createPiazzaNPCs(sceneRef) {
        const makeNPC = (color, x, z, dialogue) => {
          const group = new THREE.Group();
          const body = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16),
            new THREE.MeshStandardMaterial({ color: color })
          );
          body.position.y = 0.6;
          group.add(body);
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xffddc1 })
          );
          head.position.y = 1.4;
          group.add(head);
          const hair = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x4b2e05 })
          );
          hair.position.y = 1.75;
          group.add(hair);
          const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
          const skinMat = new THREE.MeshStandardMaterial({ color: 0xffddc1 });
          const leftArm = new THREE.Mesh(armGeo, skinMat);
          leftArm.position.set(-0.5, 1.0, 0);
          leftArm.userData = { isArm: true, side: 'left' };
          group.add(leftArm);
          const rightArm = new THREE.Mesh(armGeo, skinMat);
          rightArm.position.set(0.5, 1.0, 0);
          rightArm.userData = { isArm: true, side: 'right' };
          group.add(rightArm);
          group.position.set(x, 0.5, z);
          group.userData = { dialogue: dialogue, target: null };
          sceneRef.add(group);
          this.outsideObjects.push({ mesh: group, type: 'npc', x: x, z: z, boundingRadius: 1 });
          return group;
        };
        const npc1 = makeNPC(0x800080, -3, -3, "Hello Princess Donia, where are you going?");
        const npc2 = makeNPC(0xffa500, 3, 3, "Hello Princess Donia, where have you been?");
        this.piazzaNPCData = [
          { object: npc1, speed: 0.02 },
          { object: npc2, speed: 0.02 }
        ];
      }

      // Items / Pickups
      createFlowers(sceneRef, count) {
        for (let i = 0; i < count; i++) {
          const fx = Math.random() * 160 - 80;
          const fz = Math.random() * 160 - 80;
          const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1, 8),
            new THREE.MeshStandardMaterial({ color: 0x008000 }));
          stem.position.y = 0.5;
          const bloom = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8),
            new THREE.MeshStandardMaterial({ color: 0xff0000 }));
          bloom.position.y = 1;
          const flower = new THREE.Group();
          flower.add(stem, bloom);
          flower.position.set(fx, 0, fz);
          sceneRef.add(flower);
          this.outsideObjects.push({ mesh: flower, type: 'flower', x: fx, z: fz, boundingRadius: 0.5 });
        }
      }
      createCoins(sceneRef, count) {
        for (let i = 0; i < count; i++) {
          const cx = Math.random() * 160 - 80;
          const cz = Math.random() * 160 - 80;
          const coin = new THREE.Mesh(new THREE.CircleGeometry(0.3, 16),
            new THREE.MeshStandardMaterial({ color: 0xffff00 }));
          coin.rotation.x = -Math.PI / 2;
          coin.position.set(cx, 0.01, cz);
          sceneRef.add(coin);
          this.outsideObjects.push({ mesh: coin, type: 'coin', x: cx, z: cz, boundingRadius: 0.3 });
        }
      }
      createGems(sceneRef, count) {
        for (let i = 0; i < count; i++) {
          const gx = Math.random() * 160 - 80;
          const gz = Math.random() * 160 - 80;
          const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.5, 0),
            new THREE.MeshStandardMaterial({ color: 0x00ffff }));
          gem.position.set(gx, 0.5, gz);
          sceneRef.add(gem);
          this.outsideObjects.push({ mesh: gem, type: 'gem', x: gx, z: gz, boundingRadius: 0.5 });
        }
      }
      createPotions(sceneRef, count) {
        for (let i = 0; i < count; i++) {
          const px = Math.random() * 160 - 80;
          const pz = Math.random() * 160 - 80;
          const base = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16),
            new THREE.MeshStandardMaterial({ color: 0xffffff }));
          base.position.y = 0.4;
          const liquid = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.6, 16),
            new THREE.MeshStandardMaterial({ color: 0xff4500 }));
          liquid.position.y = 0.4;
          const potion = new THREE.Group();
          potion.add(base, liquid);
          potion.position.set(px, 0, pz);
          sceneRef.add(potion);
          this.outsideObjects.push({ mesh: potion, type: 'potion', x: px, z: pz, boundingRadius: 0.5 });
        }
      }
      createKeys(sceneRef, count) {
        for (let i = 0; i < count; i++) {
          const kx = Math.random() * 160 - 80;
          const kz = Math.random() * 160 - 80;
          const handle = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xffd700 }));
          const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
            new THREE.MeshStandardMaterial({ color: 0xffd700 }));
          shaft.position.y = -0.4;
          const key = new THREE.Group();
          key.add(handle, shaft);
          key.position.set(kx, 0.5, kz);
          key.rotation.x = Math.PI / 2;
          sceneRef.add(key);
          this.outsideObjects.push({ mesh: key, type: 'key', x: kx, z: kz, boundingRadius: 0.5 });
        }
      }
      createArtifacts(sceneRef, count) {
        for (let i = 0; i < count; i++) {
          const ax = Math.random() * 160 - 80;
          const az = Math.random() * 160 - 80;
          const artifact = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x9400d3 }));
          const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffeb3b, transparent: true, opacity: 0.5, side: THREE.BackSide }));
          const group = new THREE.Group();
          group.add(artifact, glow);
          group.position.set(ax, 0.5, az);
          sceneRef.add(group);
          this.outsideObjects.push({ mesh: group, type: 'artifact', x: ax, z: az, boundingRadius: 0.5 });
        }
      }

      // NPC and Other Updates
      updateBlueNPC() {
        if (!this.npcBlueData || !this.npcBlueData.object) return;
        this.npcBlueData.angle += this.npcBlueData.speed;
        const x = this.npcBlueData.radius * Math.cos(this.npcBlueData.angle);
        const z = this.npcBlueData.radius * Math.sin(this.npcBlueData.angle);
        this.npcBlueData.object.position.set(x, 0.5, z);
        this.npcBlueData.object.rotation.y = -this.npcBlueData.angle;
        this.animateArms(this.npcBlueData.object, true);
      }
      updateYellowNPC() {
        if (!this.npcYellowData || !this.npcYellowData.object) return;
        const npc = this.npcYellowData.object;
        if (!this.npcYellowData.target) {
          const targets = [{ x: 40, z: 40 }, { x: -40, z: -40 }, { x: 70, z: -30 }];
          this.npcYellowData.target = targets[Math.floor(Math.random() * targets.length)];
        }
        const dx = this.npcYellowData.target.x - npc.position.x;
        const dz = this.npcYellowData.target.z - npc.position.z;
        if (dx * dx + dz * dz < 1) {
          this.npcYellowData.target = null;
        } else {
          this.animateArms(npc, true);
          const angle = Math.atan2(dx, dz);
          npc.rotation.y = angle;
          const step = this.npcYellowData.speed;
          npc.position.x += Math.sin(angle) * step;
          npc.position.z += Math.cos(angle) * step;
        }
      }
      updateMermaid() {}
      updateBird() {
        if (!this.birdData || !this.birdData.object) return;
        this.birdData.angle += this.birdData.speed;
        const bx = this.birdData.radius * Math.cos(this.birdData.angle);
        const bz = this.birdData.radius * Math.sin(this.birdData.angle);
        this.birdData.object.position.set(bx, 60, bz);
        this.birdData.object.rotation.y = -this.birdData.angle;
      }
      updatePiazzaNPCs() {
        if (!this.piazzaNPCData) return;
        for (const data of this.piazzaNPCData) {
          const npc = data.object;
          const d = npc.userData;
          if (!d.target) {
            d.target = { x: Math.random() * 10 - 5, z: Math.random() * 10 - 5 };
          }
          const dx = d.target.x - npc.position.x;
          const dz = d.target.z - npc.position.z;
          if (dx * dx + dz * dz < 1) {
            d.target = { x: Math.random() * 10 - 5, z: Math.random() * 10 - 5 };
          } else {
            this.animateArms(npc, true);
            const angle = Math.atan2(dx, dz);
            npc.rotation.y = angle;
            const step = data.speed;
            npc.position.x += Math.sin(angle) * step;
            npc.position.z += Math.cos(angle) * step;
          }
        }
      }
      updatePickups() {
        for (let i = this.outsideObjects.length - 1; i >= 0; i--) {
          const obj = this.outsideObjects[i];
          if (["flower", "coin", "gem", "potion", "key", "artifact"].includes(obj.type)) {
            const dx = this.player.x - obj.x;
            const dz = this.player.z - obj.z;
            if (dx * dx + dz * dz < 1.0) {
              switch (obj.type) {
                case "flower": this.flowers++; document.getElementById('flowers').textContent = this.flowers; break;
                case "coin": this.coins++; document.getElementById('coins').textContent = this.coins; break;
                case "gem": this.gems++; document.getElementById('gems').textContent = this.gems; break;
                case "potion": this.potions++; document.getElementById('potions').textContent = this.potions; break;
                case "key": this.keys++; document.getElementById('keys').textContent = this.keys; break;
                case "artifact": this.artifacts++; document.getElementById('artifacts').textContent = this.artifacts; break;
              }
              const glow = new THREE.Mesh(
                new THREE.SphereGeometry(1, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5, side: THREE.BackSide })
              );
              glow.position.set(obj.x, 0.5, obj.z);
              outsideScene.add(glow);
              setTimeout(() => { outsideScene.remove(glow); }, 1000);
              outsideScene.remove(obj.mesh);
              this.outsideObjects.splice(i, 1);
            }
          }
        }
      }

      updateBalls() {
        const coll = isInsideCastle ? this.insideObjects : this.outsideObjects;
        for (let i = this.thrownBalls.length - 1; i >= 0; i--) {
          const ball = this.thrownBalls[i];
          ball.position.add(ball.userData.velocity);
          ball.userData.velocity.y -= 0.01;
          for (const obj of coll) {
            if (['building', 'decoration', 'boundary'].includes(obj.type)) {
              const dx = ball.position.x - obj.x;
              const dz = ball.position.z - obj.z;
              const r = (obj.boundingRadius || 1) + 0.3;
              if (dx * dx + dz * dz < r * r && ball.position.y < 10) {
                const normal = new THREE.Vector3(dx, 0, dz).normalize();
                const v = ball.userData.velocity.clone();
                const dot = v.dot(normal);
                const reflection = v.sub(normal.multiplyScalar(2 * dot)).multiplyScalar(0.6);
                ball.userData.velocity.copy(reflection);
              }
            }
          }
          if (!ball.userData.timer) ball.userData.timer = 0;
          ball.userData.timer++;
          if (ball.userData.timer > 150) {
            (isInsideCastle ? insideScene : outsideScene).remove(ball);
            this.thrownBalls.splice(i, 1);
            continue;
          }
          if (ball.position.y < 0) {
            if (!ball.userData.bounced) {
              ball.position.y = 0;
              ball.userData.velocity.y *= -0.7;
              ball.userData.bounced = true;
            } else if (ball.position.y < -0.5) {
              (isInsideCastle ? insideScene : outsideScene).remove(ball);
              this.thrownBalls.splice(i, 1);
            }
          }
        }
      }

      throwBall() {
        const direction = new THREE.Vector3(Math.sin(this.player.yaw), 0, Math.cos(this.player.yaw));
        const ballGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4500 });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.position.set(this.player.x, this.player.y + 1, this.player.z);
        ball.userData = {
          velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0, 0.3, 0)),
          bounced: false,
          timer: 0
        };
        (isInsideCastle ? insideScene : outsideScene).add(ball);
        this.thrownBalls.push(ball);
        this.ballCount++;
        document.getElementById('ballCountValue').textContent = this.ballCount;
        this.showDialogue("Threw a magic ball!");
      }

      jump() {
        if (this.player.y <= 0.5) {
          this.player.jumpVelocity = 0.3;
          this.showDialogue("Jump!");
        }
      }

      showDialogue(text) {
        const dlg = document.getElementById('dialogue');
        dlg.style.display = 'block';
        dlg.textContent = text;
        setTimeout(() => {
          dlg.style.display = 'none';
          dlg.textContent = '';
        }, 1500);
      }

      updateCollisions() {
        if (this.npcBlueData && this.npcBlueData.object) {
          const dx = this.player.x - this.npcBlueData.object.position.x;
          const dz = this.player.z - this.npcBlueData.object.position.z;
          if (Math.sqrt(dx * dx + dz * dz) < 5) {
            this.showDialogue("Hello Princess Donia!");
          }
        }
      }

      initKeyboardMouse() {
        document.addEventListener('keydown', e => {
          this.keysPressed[e.key] = true;
          if (e.key === ' ') this.throwBall();
        });
        document.addEventListener('keyup', e => {
          this.keysPressed[e.key] = false;
        });
        document.addEventListener('mousedown', () => {
          try { document.body.requestPointerLock(); }
          catch (err) { console.warn('Pointer lock failed:', err); }
        });
        document.addEventListener('mousemove', evt => {
          if (document.pointerLockElement === document.body) {
            const movementX = evt.movementX || 0;
            const sensitivity = 0.001;
            this.player.yaw += movementX * sensitivity;
          }
        });
      }
    }

    // Initialize the game
    try {
      window.game = new Game();
    } catch (err) {
      console.error('Error initializing the game:', err);
    }
  </script>
</body>
</html>
