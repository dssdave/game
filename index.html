<!DOCTYPE html>
<html>
<head>
    <title>Princess RPG - Minimal Debug</title>
    <style>
        #gameContainer {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported!');
            throw new Error('WebGL not supported');
        }

        // Simplified shaders for debugging
        const vertexShaderSource = `
            attribute vec3 a_position;
            uniform mat4 u_projection;
            uniform mat4 u_view;
            uniform mat4 u_model;
            void main() {
                gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Solid red
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }
        gl.useProgram(program);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        const projLoc = gl.getUniformLocation(program, 'u_projection');
        const viewLoc = gl.getUniformLocation(program, 'u_view');
        const modelLoc = gl.getUniformLocation(program, 'u_model');

        function mat4() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        function perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
            return out;
        }

        function multiply(out, a, b) {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    out[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        out[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return out;
        }

        function translate(out, x, y, z) {
            out[12] = x; out[13] = y; out[14] = z;
            return out;
        }

        const positionBuffer = gl.createBuffer();
        const vertices = [
            -5, -5, -5,   5, -5, -5,   5, 5, -5,   -5, 5, -5,    // Front face
            -5, -5,  5,   5, -5,  5,   5, 5,  5,   -5, 5,  5     // Back face
        ];
        const indices = [
            0, 1, 2,  0, 2, 3,    // Front
            4, 5, 6,  4, 6, 7     // Back
        ];

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        function draw() {
            gl.clearColor(0.53, 0.81, 0.98, 1); // Sky blue background
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            let projection = mat4();
            perspective(projection, Math.PI / 3, canvas.width / canvas.height, 0.1, 1000);
            gl.uniformMatrix4fv(projLoc, false, projection);

            let view = mat4();
            view = translate(view, 0, 0, -50);
            gl.uniformMatrix4fv(viewLoc, false, view);

            let model = mat4();
            model = translate(model, 0, 0, 0);
            gl.uniformMatrix4fv(modelLoc, false, model);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionLoc);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        function gameLoop() {
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
