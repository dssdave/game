<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town - Castle Interior with Walls</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
    }
    /* UI boxes */
    #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
      background: rgba(0,0,0,0.7);
      border: 2px solid #fff;
      border-radius: 5px;
      color: #fff;
      font-size: 14px;
      padding: 10px 15px;
      position: absolute;
      z-index: 10;
    }
    #ui         { top: 10px; left: 10px; }
    #ballCount  { top: 10px; right: 10px; }
    #dialogue   { bottom: 10px; left: 10px; max-width: 400px; display: none; }
    #controls   { bottom: 10px; right: 10px; width: 300px; }
    #errorMessage {
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      display: none;
    }
    #guardPopup {
      bottom: 50%; left: 50%;
      transform: translate(-50%,50%);
      display: none; text-align: center;
    }
    /* Toggle UI button */
    #toggleUIBtn {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      font-size: 14px;
      padding: 5px 10px;
      background: #333;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 5px;
      cursor: pointer;
    }
    /* On-screen Controller Panels */
    #dpadContainer, #turnContainer, #actionContainer {
      position: absolute; z-index: 15;
    }
    /* D-Pad as a grid with a small gap */
    #dpadContainer {
      bottom: 16vh; left: 5vw;
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 8px;
    }
    #btnUp    { grid-column: 2; grid-row: 1; }
    #btnDown  { grid-column: 2; grid-row: 3; }
    #btnLeft  { grid-column: 1; grid-row: 2; }
    #btnRight { grid-column: 3; grid-row: 2; }
    #dpadContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 20px; color: #fff;
      cursor: pointer;
    }
    #turnContainer {
      bottom: 16vh; left: calc(5vw + 200px);
      display: flex; flex-direction: column; gap: 8px;
    }
    #turnContainer button, #actionContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px;
      color: #fff;
      cursor: pointer;
    }
    #actionContainer {
      bottom: 16vh; left: calc(5vw + 200px + 70px);
      display: flex; flex-direction: column; gap: 8px;
    }
    @media (max-width: 768px) {
      #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
        font-size: 12px; padding: 8px 10px;
      }
      #toggleUIBtn { font-size: 12px; }
      #dpadContainer {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
        bottom: 30vh;
      }
      #dpadContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
      #turnContainer, #actionContainer { bottom: 30vh; }
      #turnContainer button, #actionContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>
    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifacts: <span id="artifacts">0</span> |
      Health: <span id="health">100</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
    <div id="dialogue"></div>
    <div id="controls">
      <strong>Controls:</strong><br>
      [Desktop] Arrow Up/Down = forward/back, Left/Right = turn, Space = throw ball<br>
      [Mobile] D‑Pad Up/Down = forward/back, Left/Right = strafe, L/R = turn, A = throw ball, B = jump
    </div>
    <div id="errorMessage">WebGL not supported in your browser.</div>
    <div id="guardPopup"></div>
    <!-- On-screen Controller Panels -->
    <div id="dpadContainer">
      <button id="btnUp">▲</button>
      <button id="btnDown">▼</button>
      <button id="btnLeft">◀</button>
      <button id="btnRight">▶</button>
    </div>
    <div id="turnContainer">
      <button id="btnTurnLeft">L</button>
      <button id="btnTurnRight">R</button>
    </div>
    <div id="actionContainer">
      <button id="btnThrow">A</button>
      <button id="btnBigThrow">B</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Toggle UI
    (function(){
      const toggleBtn = document.getElementById("toggleUIBtn");
      let uiVisible = true;
      toggleBtn.addEventListener("click", () => {
        uiVisible = !uiVisible;
        const ids = ["ui","ballCount","dialogue","controls","guardPopup","errorMessage"];
        ids.forEach(id => {
          const el = document.getElementById(id);
          el.style.display = uiVisible ? "block" : "none";
        });
      });
    })();

    // Prevent text highlighting on mobile for certain buttons
    function disableHighlight(id){
      const btn = document.getElementById(id);
      ["touchstart","mousedown"].forEach(evt => {
        btn.addEventListener(evt, e => { e.preventDefault(); }, { passive:false });
      });
    }
    ["btnUp","btnDown","btnLeft","btnRight","btnTurnLeft","btnTurnRight","btnThrow","btnBigThrow"]
      .forEach(disableHighlight);

    // On-screen controller state
    const controllerState = {
      dpadUp:false, dpadDown:false, dpadLeft:false, dpadRight:false,
      turnLeft:false, turnRight:false
    };
    function setButtonListener(btnId, stateProp){
      const btn = document.getElementById(btnId);
      ["mousedown","touchstart"].forEach(evt => {
        btn.addEventListener(evt, e => {
          e.preventDefault();
          controllerState[stateProp] = true;
        }, { passive:false });
      });
      ["mouseup","touchend","mouseleave","touchcancel"].forEach(evt => {
        btn.addEventListener(evt, e => { controllerState[stateProp] = false; });
      });
    }
    setButtonListener("btnUp","dpadUp");
    setButtonListener("btnDown","dpadDown");
    setButtonListener("btnLeft","dpadLeft");
    setButtonListener("btnRight","dpadRight");
    setButtonListener("btnTurnLeft","turnLeft");
    setButtonListener("btnTurnRight","turnRight");

    // A/B button actions
    ["pointerdown","click"].forEach(evt => {
      document.getElementById("btnThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game && typeof window.game.throwBall === "function"){
          window.game.throwBall();
        }
      }, { passive:false });
    });
    ["pointerdown","click"].forEach(evt => {
      document.getElementById("btnBigThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game && typeof window.game.jump === "function"){
          window.game.jump();
        }
      }, { passive:false });
    });

    /****************************************
     * Helper to generate random stone texture
     ****************************************/
    function generateStoneTexture() {
      const canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext("2d");
      for (let y=0; y<256; y+=16){
        for (let x=0; x<256; x+=16){
          const shade = 120 + Math.floor(Math.random()*40);
          ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
          ctx.fillRect(x,y,16,16);
        }
      }
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(1,1);
      return tex;
    }

    class Game {
      constructor(){
        // Basic scene/camera/renderer
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("gameCanvas") });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        // On mobile, clamp pixel ratio
        this.renderer.setPixelRatio(window.innerWidth < 768 ? Math.min(window.devicePixelRatio,1) : window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Day/Night
        this.dayNightCycle = 0;
        this.dayNightMax = 18000; // ~5 min
        this.time = "Day";

        // Player
        this.player = {
          x: 0, y: 0.5, z: 0,
          baseSpeed: 0.1, // multiplied outside by 2.5
          yaw: 0, pitch: 0,
          jumpVelocity: 0,
          object: null
        };

        // Stats
        this.flowers=0; this.coins=0; this.gems=0; this.potions=0; this.keys=0; this.artifacts=0;
        this.health=100;

        this.objects = []; // collidable objects or pickups
        this.buildingPositions = [];
        this.ballCount = 0;
        this.thrownBalls = [];
        this.keysPressed = {};

        // Groups: outside vs inside
        this.outsideGroup = new THREE.Group();
        this.insideGroup = new THREE.Group();
        this.scene.add(this.outsideGroup);
        this.scene.add(this.insideGroup);
        this.outsideColliders = [];
        this.insideColliders = [];
        this.interior = false; // are we inside castle or not

        // Door areas for transitions
        this.castleDoorArea = { x: 40, z: 50, radius: 5 };
        this.insideDoorArea = { x: 0, z: -45, radius: 4 };

        // NPC data
        this.npcBlueData = { angle:0, speed:0.001, radius:120, object:null };
        this.npcYellowData = { object:null, speed:0.03, target:null };
        this.guardData = { object:null, state:"idle", timer:0,
                           route:[{x:35,z:60},{x:35,z:70},{x:55,z:70},{x:55,z:60},{x:45,z:55}],
                           routeIndex:0, speed:0.02 };
        this.mermaidData = { object:null, route:[{x:-15,z:-70},{x:15,z:-70}], routeIndex:0, speed:0.02, messaged:false };
        this.birdData = { angle:0, speed:0.002, radius:140, object:null };
        this.guardObject=null; this.guardMessageShown=false;
        this.npcBlueMessageShown=false; this.npcYellowMessageShown=false;

        // Additional Piazza NPC data
        this.piazzaNPCData = [];

        // Initialize outside/inside
        this.initOutside();
        this.initInside();

        // Create the player model
        this.createPlayerModel();

        // Bind methods
        this.updateMovement = this.updateMovement.bind(this);
        this.animateArms = this.animateArms.bind(this);

        // Input
        this.initKeyboardMouse();

        // Start animation
        this.startAnimation();
      }

      /*******************************
       * OUTSIDE
       *******************************/
      initOutside(){
        this.outsideGroup.visible = true;
        this.insideGroup.visible = false;
        // Basic environment
        this.scene.background = new THREE.Color(0x87CEEB);

        // Ground
        const groundGeo = new THREE.PlaneGeometry(300,300);
        const groundMat = new THREE.MeshStandardMaterial({ color:0x6bb26b, side:THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI/2;
        this.outsideGroup.add(ground);

        // Rolling hills
        const hillCount = (window.innerWidth < 768 ? 40 : 80);
        for(let i=0; i<hillCount; i++){
          const r = 80 + Math.random()*60;
          const x = (Math.random()>0.5?1:-1)*(300+Math.random()*500);
          const z = (Math.random()>0.5?1:-1)*(300+Math.random()*500);
          const hillGeo = new THREE.SphereGeometry(r,16,16);
          const hillMat = new THREE.MeshStandardMaterial({ color:0x228b22, roughness:0.9 });
          const hill = new THREE.Mesh(hillGeo, hillMat);
          hill.position.set(x, -r/2, z);
          this.outsideGroup.add(hill);
        }

        // Boundary shrubs
        for(let x=-130; x<=130; x+=4){
          this.addShrub(x, -130);
          this.addShrub(x, 130);
        }
        for(let z=-130; z<=130; z+=4){
          this.addShrub(-130,z);
          this.addShrub(130,z);
        }

        // Beach & water
        this.createBeach();

        // Lighting
        const ambient = new THREE.AmbientLight(0x404040, 0.6);
        this.outsideGroup.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50,100,50);
        this.outsideGroup.add(dirLight);

        // Sun, Moon, Stars
        this.createSun();
        this.createMoon();
        this.createStars();

        // Buildings
        this.createCastle();
        this.createHouse();
        this.createCafe();
        this.createFountain();
        this.buildingPositions.push({ x:40, z:40 });
        this.buildingPositions.push({ x:-40, z:-40 });
        this.buildingPositions.push({ x:70, z:-30 });

        // NPCs
        this.createBlueNPC();
        this.createYellowNPC();
        this.createGuardAtCastle();
        this.createMermaid();
        this.createBird();

        // Items
        this.createFlowers(10);
        this.createCoins(8);
        this.createGems(4);
        this.createPotions(3);
        this.createKeys(2);
        this.createArtifacts(2);

        // Piazza
        this.createPiazza();
        this.createPiazzaNPCs();

        // Lamp posts
        this.createBoundaryLampPosts();
        this.createBuildingLampPosts();
      }
      addShrub(x,z){
        const geo = new THREE.CylinderGeometry(1,1,2,8);
        const mat = new THREE.MeshStandardMaterial({ color:0x228b22 });
        const shrub = new THREE.Mesh(geo,mat);
        shrub.position.set(x,1,z);
        this.outsideGroup.add(shrub);
      }
      createBeach(){
        const beachGeo = new THREE.PlaneGeometry(300,30);
        const beachMat = new THREE.MeshStandardMaterial({ color:0xD2B48C });
        const beach = new THREE.Mesh(beachGeo, beachMat);
        beach.rotation.x = -Math.PI/2;
        beach.position.set(0,0.01,-40);
        this.outsideGroup.add(beach);

        const waterGeo = new THREE.PlaneGeometry(300,30);
        const waterMat = new THREE.MeshStandardMaterial({ color:0x1E90FF, transparent:true, opacity:0.8 });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.rotation.x = -Math.PI/2;
        water.position.set(0,0.02,-70);
        this.outsideGroup.add(water);
      }
      createSun(){
        const sunGeo = new THREE.SphereGeometry(9,16,16);
        const sunMat = new THREE.MeshBasicMaterial({ color:0xffee00 });
        this.sunMesh = new THREE.Mesh(sunGeo, sunMat);
        this.sunMesh.position.set(0,200,-200);
        this.sunMesh.visible = true;
        this.outsideGroup.add(this.sunMesh);
        const glowGeo = new THREE.SphereGeometry(12,16,16);
        const glowMat = new THREE.MeshBasicMaterial({ color:0xffee00, transparent:true, opacity:0.3, blending:THREE.AdditiveBlending });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        this.sunMesh.add(glow);
      }
      createMoon(){
        const moonGeo = new THREE.SphereGeometry(6,16,16);
        const moonMat = new THREE.MeshBasicMaterial({ color:0xcccccc });
        this.moonMesh = new THREE.Mesh(moonGeo, moonMat);
        this.moonMesh.position.set(-100,150,100);
        this.moonMesh.visible = false;
        this.outsideGroup.add(this.moonMesh);
        const moonGlowGeo = new THREE.SphereGeometry(8,16,16);
        const moonGlowMat = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.2, blending:THREE.AdditiveBlending });
        const moonGlow = new THREE.Mesh(moonGlowGeo, moonGlowMat);
        this.moonMesh.add(moonGlow);
      }
      createStars(){
        const starCount = 300;
        const positions = new Float32Array(starCount*3);
        for(let i=0; i<starCount; i++){
          const radius = 300 + Math.random()*200;
          const angle = Math.random()*Math.PI*2;
          const ySpread = Math.random()*200 - 50;
          positions[i*3] = Math.cos(angle)*radius;
          positions[i*3+1] = 50 + ySpread;
          positions[i*3+2] = Math.sin(angle)*radius;
        }
        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute("position", new THREE.BufferAttribute(positions,3));
        const starMat = new THREE.PointsMaterial({ color:0xffffff, size:1.2, depthTest:false });
        const starField = new THREE.Points(starGeo, starMat);
        starField.visible = false;
        this.outsideGroup.add(starField);
        this.starsMesh = starField;
      }

      createCastle(){
        const group = new THREE.Group();
        const stoneTex = generateStoneTexture();
        const castleMat = new THREE.MeshStandardMaterial({ map:stoneTex, roughness:0.6, metalness:0.1 });
        // Base
        const base = new THREE.Mesh(new THREE.BoxGeometry(20,10,20), castleMat);
        base.position.set(40,5,40);
        group.add(base);
        // Towers
        const towerGeo = new THREE.CylinderGeometry(3,3,15,16);
        const coords = [[10,7.5,10],[-10,7.5,10],[10,7.5,-10],[-10,7.5,-10]];
        for(const c of coords){
          const tower = new THREE.Mesh(towerGeo, castleMat.clone());
          tower.position.set(40+c[0], c[1], 40+c[2]);
          group.add(tower);
        }
        // Door
        const door = new THREE.Mesh(new THREE.PlaneGeometry(4,6),
          new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
        door.position.set(40,3,50.01);
        group.add(door);
        // Door Light
        const doorLight = new THREE.PointLight(0xffeeaa, 0.8, 15);
        doorLight.position.set(37,5,50);
        group.add(doorLight);
        // Sign
        const signCanvas = document.createElement("canvas");
        signCanvas.width = 512; signCanvas.height = 128;
        const ctx = signCanvas.getContext("2d");
        ctx.fillStyle="black"; ctx.fillRect(0,0,512,128);
        ctx.fillStyle="white"; ctx.font="60px Arial";
        ctx.fillText("Daddy's Castle", 50,80);
        const signTex = new THREE.Texture(signCanvas);
        signTex.needsUpdate=true;
        const signMat = new THREE.MeshBasicMaterial({ map:signTex });
        const signGeo = new THREE.PlaneGeometry(12,3);
        const signMesh = new THREE.Mesh(signGeo, signMat);
        signMesh.position.set(40,8,50.1);
        group.add(signMesh);
        this.outsideGroup.add(group);
      }
      createHouse(){
        const group = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(12,8,10),
          new THREE.MeshStandardMaterial({ color:0x8b4513, roughness:0.7 }));
        base.position.set(-40,4,-40);
        group.add(base);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(6,4,4),
          new THREE.MeshStandardMaterial({ color:0x800000, roughness:0.6 }));
        roof.position.set(-40,8,-40);
        roof.rotation.y = Math.PI/4;
        group.add(roof);
        const door = new THREE.Mesh(new THREE.PlaneGeometry(2,4),
          new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
        door.position.set(-40,2,-34.99);
        group.add(door);
        this.outsideGroup.add(group);
      }
      createCafe(){
        const group = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(12,7,10),
          new THREE.MeshStandardMaterial({ color:0x888888, metalness:0.3, roughness:0.5 }));
        base.position.set(70,3.5,-30);
        group.add(base);
        const door = new THREE.Mesh(new THREE.PlaneGeometry(2,3),
          new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
        door.position.set(70,1.5,-24.99);
        group.add(door);
        this.outsideGroup.add(group);
      }
      createFountain(){
        const group = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(3,3,1,16),
          new THREE.MeshStandardMaterial({ color:0x808080 }));
        base.position.y=0.5;
        group.add(base);
        const bowl = new THREE.Mesh(new THREE.TorusGeometry(3,0.3,16,32),
          new THREE.MeshStandardMaterial({ color:0x808080 }));
        bowl.rotation.x = Math.PI/2;
        bowl.position.y=1;
        group.add(bowl);
        const water = new THREE.Mesh(new THREE.CylinderGeometry(2.8,2.8,0.2,16),
          new THREE.MeshStandardMaterial({ color:0x00ffff, transparent:true, opacity:0.6 }));
        water.position.set(0,1.1,0);
        group.add(water);
        group.position.set(0,0,20);
        this.outsideGroup.add(group);
      }
      createPlayerModel(){
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16),
          new THREE.MeshStandardMaterial({ color:0xff69b4 }));
        body.position.y=0.6;
        group.add(body);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16),
          new THREE.MeshStandardMaterial({ color:0xffddc1 }));
        head.position.y=1.4;
        group.add(head);
        const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16),
          new THREE.MeshStandardMaterial({ color:0x4b2e05 }));
        hair.position.y=1.75;
        group.add(hair);
        const crown = new THREE.Mesh(new THREE.TorusGeometry(0.25,0.09,8,16),
          new THREE.MeshStandardMaterial({ color:0xffd700 }));
        crown.rotation.x = Math.PI/2;
        crown.position.set(0,1.95,0);
        group.add(crown);
        const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.8,8);
        const skinMat = new THREE.MeshStandardMaterial({ color:0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5,1.0,0);
        leftArm.userData = { isArm:true, side:"left" };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5,1.0,0);
        rightArm.userData = { isArm:true, side:"right" };
        group.add(rightArm);
        const legGeo = new THREE.CylinderGeometry(0.12,0.12,0.8,8);
        const leftLeg = new THREE.Mesh(legGeo, skinMat);
        leftLeg.position.set(-0.2,0.2,0);
        group.add(leftLeg);
        const rightLeg = new THREE.Mesh(legGeo, skinMat);
        rightLeg.position.set(0.2,0.2,0);
        group.add(rightLeg);
        group.position.set(this.player.x,this.player.y,this.player.z);
        this.player.object = group;
        this.outsideGroup.add(group);
      }

      /*******************************
       * NPCs
       *******************************/
      createBlueNPC(){
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16),
          new THREE.MeshStandardMaterial({ color:0x0000ff }));
        body.position.y=0.6;
        group.add(body);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16),
          new THREE.MeshStandardMaterial({ color:0xffddc1 }));
        head.position.y=1.4;
        group.add(head);
        const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16),
          new THREE.MeshStandardMaterial({ color:0x4b2e05 }));
        hair.position.y=1.75;
        group.add(hair);
        const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.8,8);
        const skinMat = new THREE.MeshStandardMaterial({ color:0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5,1.0,0);
        leftArm.userData = { isArm:true, side:"left" };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5,1.0,0);
        rightArm.userData = { isArm:true, side:"right" };
        group.add(rightArm);
        group.position.set(120,0.5,0);
        this.outsideGroup.add(group);
        this.objects.push({ mesh:group, type:"npc", x:120, z:0, boundingRadius:1 });
        this.npcBlueData.object = group;
      }
      createYellowNPC(){
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.0,16),
          new THREE.MeshStandardMaterial({ color:0xffff00 }));
        body.position.y=0.5;
        group.add(body);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16),
          new THREE.MeshStandardMaterial({ color:0xffddc1 }));
        head.position.y=1.1;
        group.add(head);
        const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16),
          new THREE.MeshStandardMaterial({ color:0x4b2e05 }));
        hair.position.y=1.55;
        group.add(hair);
        const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.6,8);
        const skinMat = new THREE.MeshStandardMaterial({ color:0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5,0.8,0);
        leftArm.userData = { isArm:true, side:"left" };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5,0.8,0);
        rightArm.userData = { isArm:true, side:"right" };
        group.add(rightArm);
        group.position.set(-30,0.3,30);
        this.outsideGroup.add(group);
        this.objects.push({ mesh:group, type:"npc", x:-30, z:30, boundingRadius:1 });
        this.npcYellowData.object = group;
      }
      createGuardAtCastle(){
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16),
          new THREE.MeshStandardMaterial({ color:0x000000 }));
        body.position.y=0.6;
        group.add(body);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16),
          new THREE.MeshStandardMaterial({ color:0xffddc1 }));
        head.position.y=1.4;
        group.add(head);
        const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16),
          new THREE.MeshStandardMaterial({ color:0x4b2e05 }));
        hair.position.y=1.75;
        group.add(hair);
        const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.8,8);
        const skinMat = new THREE.MeshStandardMaterial({ color:0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5,1.0,0);
        leftArm.userData = { isArm:true, side:"left" };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5,1.0,0);
        rightArm.userData = { isArm:true, side:"right" };
        group.add(rightArm);
        group.position.set(45,0.5,55.5);
        this.outsideGroup.add(group);
        this.objects.push({ mesh:group, type:"guard", x:45, z:55.5, boundingRadius:3 });
        this.guardData.object = group;
        this.guardObject = group;
      }
      createMermaid(){
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,0.6,16),
          new THREE.MeshStandardMaterial({ color:0xff69b4 }));
        body.position.y=0.9;
        group.add(body);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16),
          new THREE.MeshStandardMaterial({ color:0xffddc1 }));
        head.position.y=1.4;
        group.add(head);
        const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16),
          new THREE.MeshStandardMaterial({ color:0x4b2e05 }));
        hair.position.y=1.8;
        group.add(hair);
        const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.6,8);
        const skinMat = new THREE.MeshStandardMaterial({ color:0xffddc1 });
        const leftArm = new THREE.Mesh(armGeo, skinMat);
        leftArm.position.set(-0.5,1.1,0);
        leftArm.userData = { isArm:true, side:"left" };
        group.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, skinMat);
        rightArm.position.set(0.5,1.1,0);
        rightArm.userData = { isArm:true, side:"right" };
        group.add(rightArm);
        group.position.set(20,-0.5,-70);
        this.outsideGroup.add(group);
        this.objects.push({ mesh:group, type:"mermaid", x:20, z:-70, boundingRadius:3 });
        this.mermaidData.object = group;
      }
      createBird(){
        const bird = new THREE.Mesh(new THREE.SphereGeometry(0.5,8,8),
          new THREE.MeshStandardMaterial({ color:0xffffff }));
        bird.position.set(0,60,0);
        this.outsideGroup.add(bird);
        this.birdData.object = bird;
      }

      /*******************************
       * LAMP POSTS & PIAZZA
       *******************************/
      createBoundaryLampPosts(){
        for(let i=0; i<20; i++){
          const angle = (i/20)*Math.PI*2;
          const radius = 130;
          const x = Math.cos(angle)*radius;
          const z = Math.sin(angle)*radius;
          this.createLampPost(x,z,this.outsideGroup);
        }
      }
      createBuildingLampPosts(){
        // example positions near buildings
        this.createLampPost(-43,-35,this.outsideGroup);
        this.createLampPost(67,-25,this.outsideGroup);
        this.createLampPost(37,50,this.outsideGroup);
      }
      createLampPost(px,pz,group){
        const postGeo = new THREE.CylinderGeometry(0.2,0.2,4,8);
        const postMat = new THREE.MeshStandardMaterial({ color:0x444444 });
        const post = new THREE.Mesh(postGeo, postMat);
        post.position.set(px,2,pz);
        const lampGeo = new THREE.SphereGeometry(0.4,8,8);
        const lampMat = new THREE.MeshStandardMaterial({ color:0xffff00, emissive:0xffff00, emissiveIntensity:0.4 });
        const lamp = new THREE.Mesh(lampGeo, lampMat);
        lamp.position.set(px,4,pz);
        const light = new THREE.PointLight(0xffffaa,0.7,20);
        light.position.set(px,4,pz);
        group.add(post,lamp,light);
      }
      createPiazza(){
        const size = 15;
        const canvas = document.createElement("canvas");
        canvas.width=256; canvas.height=256;
        const ctx = canvas.getContext("2d");
        for(let y=0; y<256; y+=16){
          for(let x=0; x<256; x+=16){
            const shade = 150 + Math.floor(Math.random()*50);
            ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
            ctx.fillRect(x,y,16,16);
          }
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(2,2);
        const piazzaGeo = new THREE.PlaneGeometry(size,size);
        const piazzaMat = new THREE.MeshStandardMaterial({ map:texture });
        const piazza = new THREE.Mesh(piazzaGeo, piazzaMat);
        piazza.rotation.x = -Math.PI/2;
        piazza.position.set(0,0.02,0);
        this.outsideGroup.add(piazza);
      }
      createPiazzaNPCs(){
        const makeNPC = (color,px,pz,dialogue) => {
          const g = new THREE.Group();
          const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16),
            new THREE.MeshStandardMaterial({ color }));
          body.position.y=0.6;
          g.add(body);
          const head = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16),
            new THREE.MeshStandardMaterial({ color:0xffddc1 }));
          head.position.y=1.4;
          g.add(head);
          const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16),
            new THREE.MeshStandardMaterial({ color:0x4b2e05 }));
          hair.position.y=1.75;
          g.add(hair);
          const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.8,8);
          const skinMat = new THREE.MeshStandardMaterial({ color:0xffddc1 });
          const leftArm = new THREE.Mesh(armGeo, skinMat);
          leftArm.position.set(-0.5,1.0,0);
          leftArm.userData={isArm:true, side:"left"};
          g.add(leftArm);
          const rightArm = new THREE.Mesh(armGeo, skinMat);
          rightArm.position.set(0.5,1.0,0);
          rightArm.userData={isArm:true, side:"right"};
          g.add(rightArm);
          g.position.set(px,0.5,pz);
          g.userData={ dialogue, target:null };
          this.outsideGroup.add(g);
          this.objects.push({ mesh:g, type:"npc", x:px, z:pz, boundingRadius:1 });
          return g;
        };
        const npc1 = makeNPC(0x800080, -3, -3, "Hello Princess Donia, where are you going?");
        const npc2 = makeNPC(0xffa500, 3, 3, "Hello Princess Donia, where have you been?");
        this.piazzaNPCData.push({ object:npc1, speed:0.02 });
        this.piazzaNPCData.push({ object:npc2, speed:0.02 });
      }

      /*******************************
       * INSIDE CASTLE
       *******************************/
      initInside(){
        // Large interior: 80 wide, 80 deep, 20 tall
        this.insideGroup.visible = false;
        const floorSize = 80;
        const wallHeight = 20;
        const half = floorSize/2;

        const stoneTex = generateStoneTexture();
        const insideMat = new THREE.MeshStandardMaterial({ map:stoneTex, roughness:0.7 });

        // Floor
        const floorGeo = new THREE.PlaneGeometry(floorSize,floorSize);
        const floor = new THREE.Mesh(floorGeo, insideMat);
        floor.rotation.x = -Math.PI/2;
        floor.position.y = 0;
        this.insideGroup.add(floor);
        // Ceiling
        const ceilingGeo = new THREE.PlaneGeometry(floorSize,floorSize);
        const ceiling = new THREE.Mesh(ceilingGeo, insideMat);
        ceiling.rotation.x = Math.PI/2;
        ceiling.position.y = wallHeight; // tall ceiling
        this.insideGroup.add(ceiling);

        // 4 walls
        // front wall
        const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, wallHeight), insideMat);
        frontWall.position.set(0, wallHeight/2, half);
        this.insideGroup.add(frontWall);

        // back wall (with exit door)
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, wallHeight), insideMat);
        backWall.position.set(0, wallHeight/2, -half);
        backWall.rotation.y = Math.PI;
        this.insideGroup.add(backWall);
        // We'll put a "door" plane on the back wall for visuals
        const interiorDoor = new THREE.Mesh(new THREE.PlaneGeometry(4,6),
          new THREE.MeshStandardMaterial({ color:0x553300, side:THREE.DoubleSide }));
        interiorDoor.position.set(0,3,-half-0.01);
        this.insideGroup.add(interiorDoor);

        // left wall
        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, wallHeight), insideMat);
        leftWall.rotation.y = Math.PI/2;
        leftWall.position.set(-half, wallHeight/2, 0);
        this.insideGroup.add(leftWall);

        // right wall
        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, wallHeight), insideMat);
        rightWall.rotation.y = -Math.PI/2;
        rightWall.position.set(half, wallHeight/2, 0);
        this.insideGroup.add(rightWall);

        // Colliders for walls
        // We'll treat each wall as having boundingRadius ~ 1 near that edge
        this.insideColliders.push({ x:0, z:half, boundingRadius:1, type:"wall" });
        this.insideColliders.push({ x:0, z:-half, boundingRadius:1, type:"wall" });
        this.insideColliders.push({ x:-half, z:0, boundingRadius:1, type:"wall" });
        this.insideColliders.push({ x:half, z:0, boundingRadius:1, type:"wall" });

        // Lighting inside
        const insideLight = new THREE.PointLight(0xffffff,1,200);
        insideLight.position.set(0,10,0);
        this.insideGroup.add(insideLight);
      }

      /*******************************
       * MAIN UPDATE & ANIMATION
       *******************************/
      startAnimation(){
        const animate = () => {
          requestAnimationFrame(animate);
          this.updateDayNight();
          this.updateMovement();
          this.updateCollisions();
          this.updateBalls();
          this.updateNPCs();
          this.updatePickups();
          this.updateCamera();
          this.renderer.render(this.scene, this.camera);
        };
        animate();
      }
      updateDayNight(){
        this.dayNightCycle = (this.dayNightCycle+1) % this.dayNightMax;
        if(this.dayNightCycle < this.dayNightMax/2){
          this.time = "Day";
          if(this.sunMesh) this.sunMesh.visible=true;
          if(this.moonMesh) this.moonMesh.visible=false;
          if(this.starsMesh) this.starsMesh.visible=false;
          this.scene.background = new THREE.Color(0x87CEEB);
        } else {
          this.time = "Night";
          if(this.sunMesh) this.sunMesh.visible=false;
          if(this.moonMesh) this.moonMesh.visible=true;
          if(this.starsMesh) this.starsMesh.visible=true;
          this.scene.background = new THREE.Color(0x000000);
        }
        document.getElementById("time").textContent = this.time;
      }
      updateMovement(){
        let keyboardForward=0, keyboardTurn=0;
        if(this.keysPressed["ArrowUp"]) keyboardForward +=1;
        if(this.keysPressed["ArrowDown"]) keyboardForward -=1;
        if(this.keysPressed["ArrowLeft"]) keyboardTurn +=1;
        if(this.keysPressed["ArrowRight"]) keyboardTurn -=1;

        let touchForward=0, touchStrafe=0;
        if(controllerState.dpadUp) touchForward+=1;
        if(controllerState.dpadDown) touchForward-=1;
        if(controllerState.dpadLeft) touchStrafe+=1;
        if(controllerState.dpadRight) touchStrafe-=1;

        let finalForward = (keyboardForward!==0 ? keyboardForward : touchForward);
        let finalStrafe = touchStrafe;
        let finalTurn = keyboardTurn;
        if(controllerState.turnLeft) finalTurn+=1;
        if(controllerState.turnRight) finalTurn-=1;

        const speedMult = this.interior ? 1.0 : 2.5;
        const forwardVec = new THREE.Vector3(Math.sin(this.player.yaw),0,Math.cos(this.player.yaw));
        const rightVec = new THREE.Vector3(Math.cos(this.player.yaw),0,-Math.sin(this.player.yaw));
        const movement = forwardVec.clone().multiplyScalar(finalForward)
                          .add(rightVec.clone().multiplyScalar(finalStrafe));
        if(movement.length()>1) movement.normalize();
        movement.multiplyScalar(this.player.baseSpeed * speedMult);

        const newX = this.player.x + movement.x;
        const newZ = this.player.z + movement.z;
        let canMove = true;
        if(!this.interior){
          // outside collisions (we keep it simpler here)
          // (If needed, add boundingRadius checks for buildings, etc.)
        } else {
          // inside collisions
          for(const c of this.insideColliders){
            if(c.type==="wall"){
              const dx = newX - c.x;
              const dz = newZ - c.z;
              const r = c.boundingRadius + 1;
              if(dx*dx + dz*dz < r*r){
                canMove=false; break;
              }
            }
          }
        }
        if(canMove){
          this.player.x=newX; this.player.z=newZ;
        }
        this.player.yaw += finalTurn*0.02;
        // jump
        if(this.player.jumpVelocity!==0 || this.player.y>0.5){
          this.player.jumpVelocity -=0.02;
          this.player.y += this.player.jumpVelocity;
          if(this.player.y<0.5){ this.player.y=0.5; this.player.jumpVelocity=0; }
        }
        // update player object
        if(this.player.object){
          this.player.object.position.set(this.player.x,this.player.y,this.player.z);
          this.player.object.rotation.y = this.player.yaw;
        }
        // animate arms if moving
        if(finalForward!==0 || finalStrafe!==0){
          this.animateArms(this.player.object,true);
        } else {
          this.animateArms(this.player.object,false);
        }
      }
      updateCamera(){
        const camDist=15;
        const offsetX = -Math.sin(this.player.yaw)*camDist;
        const offsetZ = -Math.cos(this.player.yaw)*camDist;
        const offsetY = 10;
        this.camera.position.set(this.player.x+offsetX, this.player.y+offsetY, this.player.z+offsetZ);
        this.camera.lookAt(this.player.x, this.player.y+1, this.player.z);
      }
      animateArms(obj, isMoving){
        if(!obj) return;
        const t = Date.now()*0.002;
        obj.traverse(child => {
          if(child.userData && child.userData.isArm){
            if(isMoving){
              if(child.userData.side==="left"){
                child.rotation.x = Math.sin(t)*0.5;
              } else {
                child.rotation.x = -Math.sin(t)*0.5;
              }
            } else {
              child.rotation.x = 0;
            }
          }
        });
      }
      /*******************************
       * CASTLE TRANSITIONS
       *******************************/
      enterCastle(){
        this.outsideGroup.visible=false;
        this.insideGroup.visible=true;
        this.interior=true;
        this.player.x=0; this.player.z=0; this.player.y=0.5;
        if(this.player.object) this.player.object.position.set(0,0.5,0);
        document.getElementById("location").textContent="Castle Interior";
      }
      exitCastle(){
        this.insideGroup.visible=false;
        this.outsideGroup.visible=true;
        this.interior=false;
        this.player.x=40; this.player.z=45; this.player.y=0.5;
        if(this.player.object) this.player.object.position.set(40,0.5,45);
        document.getElementById("location").textContent="Town";
      }

      updateCollisions(){
        if(!this.interior){
          // check if near castle door
          const dx = this.player.x - this.castleDoorArea.x;
          const dz = this.player.z - this.castleDoorArea.z;
          if(dx*dx + dz*dz < this.castleDoorArea.radius*this.castleDoorArea.radius){
            this.enterCastle();
          }
        } else {
          // check if near interior door
          const dx = this.player.x - this.insideDoorArea.x;
          const dz = this.player.z - this.insideDoorArea.z;
          if(dx*dx + dz*dz < this.insideDoorArea.radius*this.insideDoorArea.radius){
            this.exitCastle();
          }
        }
        // Example guard dialogue
        if(this.guardObject && !this.guardMessageShown){
          const dx = this.player.x - this.guardObject.position.x;
          const dz = this.player.z - this.guardObject.position.z;
          if(dx*dx + dz*dz < 25){
            this.showGuardPopup("I'm the guard of this castle. Please show your ID.");
            this.guardMessageShown=true;
            setTimeout(()=>{ this.guardMessageShown=false; },2500);
          }
        }
        // Blue NPC
        if(this.npcBlueData.object && !this.npcBlueMessageShown){
          const dx = this.player.x - this.npcBlueData.object.position.x;
          const dz = this.player.z - this.npcBlueData.object.position.z;
          if(dx*dx + dz*dz < 25){
            this.showGuardPopup("Hello Princess Donia!");
            this.npcBlueMessageShown=true;
            setTimeout(()=>{ this.npcBlueMessageShown=false; },2500);
          }
        }
        // Additional NPC dialogues (like piazza)
        for(const obj of this.objects){
          if(obj.type==="npc" && obj.mesh.userData && obj.mesh.userData.dialogue){
            const dx = this.player.x - obj.x;
            const dz = this.player.z - obj.z;
            if(dx*dx + dz*dz < 9){
              this.showGuardPopup(obj.mesh.userData.dialogue);
            }
          }
        }
      }

      /*******************************
       * BALLS
       *******************************/
      throwBall(){
        const direction = new THREE.Vector3(Math.sin(this.player.yaw),0,Math.cos(this.player.yaw));
        const ballGeo = new THREE.SphereGeometry(0.3,16,16);
        const ballMat = new THREE.MeshStandardMaterial({ color:0xff4500 });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.position.set(this.player.x, this.player.y+1, this.player.z);
        ball.userData = {
          velocity: direction.multiplyScalar(0.3).add(new THREE.Vector3(0,0.3,0)),
          bounced:false, timer:0
        };
        this.scene.add(ball);
        this.thrownBalls.push(ball);
        this.ballCount++;
        document.getElementById("ballCountValue").textContent=this.ballCount;
        this.showDialogue("Threw a magic ball!");
      }

      updateBalls(){
        for(let i=this.thrownBalls.length-1; i>=0; i--){
          const ball = this.thrownBalls[i];
          ball.position.add(ball.userData.velocity);
          ball.userData.velocity.y -=0.01;
          // bounce off building?
          for(const obj of this.objects){
            if(["building","decoration"].includes(obj.type)){
              const dx = ball.position.x - obj.x;
              const dz = ball.position.z - obj.z;
              const r = (obj.boundingRadius||5)+0.3;
              if(dx*dx + dz*dz < r*r && ball.position.y<10){
                const normal = new THREE.Vector3(dx,0,dz).normalize();
                const v = ball.userData.velocity.clone();
                const dot = v.dot(normal);
                const reflection = v.sub(normal.multiplyScalar(2*dot)).multiplyScalar(0.6);
                ball.userData.velocity.copy(reflection);
              }
            }
          }
          if(!ball.userData.timer) ball.userData.timer=0;
          ball.userData.timer++;
          if(ball.userData.timer>150){
            this.scene.remove(ball);
            this.thrownBalls.splice(i,1);
            continue;
          }
          if(ball.position.y<0){
            if(!ball.userData.bounced){
              ball.position.y=0;
              ball.userData.velocity.y*=-0.7;
              ball.userData.bounced=true;
            } else if(ball.position.y<-0.5){
              this.scene.remove(ball);
              this.thrownBalls.splice(i,1);
            }
          }
        }
      }

      /*******************************
       * NPC Updates
       *******************************/
      updateNPCs(){
        // Blue NPC
        if(this.npcBlueData.object){
          this.npcBlueData.angle += this.npcBlueData.speed;
          const x = this.npcBlueData.radius * Math.cos(this.npcBlueData.angle);
          const z = this.npcBlueData.radius * Math.sin(this.npcBlueData.angle);
          this.npcBlueData.object.position.set(x,0.5,z);
          this.npcBlueData.object.rotation.y = -this.npcBlueData.angle;
          this.animateArms(this.npcBlueData.object,true);
        }
        // Yellow NPC
        if(this.npcYellowData.object){
          const npc = this.npcYellowData.object;
          if(!this.npcYellowData.target){
            this.npcYellowData.target = this.getRandomBuildingTarget();
          }
          const dx = this.npcYellowData.target.x - npc.position.x;
          const dz = this.npcYellowData.target.z - npc.position.z;
          if(dx*dx + dz*dz < 1){
            this.npcYellowData.target = this.getRandomBuildingTarget();
          } else {
            this.animateArms(npc,true);
            const angle = Math.atan2(dx,dz);
            npc.rotation.y = angle;
            npc.position.x += Math.sin(angle)*this.npcYellowData.speed;
            npc.position.z += Math.cos(angle)*this.npcYellowData.speed;
          }
        }
        // Mermaid
        if(this.mermaidData.object){
          const mer = this.mermaidData.object;
          const route = this.mermaidData.route;
          let tgt = route[this.mermaidData.routeIndex];
          const dx = tgt.x - mer.position.x;
          const dz = tgt.z - mer.position.z;
          if(dx*dx + dz*dz <1){
            this.mermaidData.routeIndex=(this.mermaidData.routeIndex+1)%route.length;
            tgt = route[this.mermaidData.routeIndex];
          }
          const angle = Math.atan2(dx,dz);
          mer.rotation.y = angle;
          this.animateArms(mer,true);
          mer.position.x += Math.sin(angle)*this.mermaidData.speed;
          mer.position.z += Math.cos(angle)*this.mermaidData.speed;
          // water splash
          if(mer.position.z< -55 && mer.position.z> -85){
            this.spawnRipple(mer.position.x, mer.position.z);
          }
          const pdx = this.player.x - mer.position.x;
          const pdz = this.player.z - mer.position.z;
          if((pdx*pdx + pdz*pdz <9) && !this.mermaidData.messaged){
            this.showDialogue("Hello from the mermaid!");
            this.mermaidData.messaged=true;
            setTimeout(()=>{ this.mermaidData.messaged=false; },3000);
          }
        }
        // Bird
        if(this.birdData.object){
          this.birdData.angle += this.birdData.speed;
          const bx = this.birdData.radius*Math.cos(this.birdData.angle);
          const bz = this.birdData.radius*Math.sin(this.birdData.angle);
          this.birdData.object.position.set(bx,60,bz);
          this.birdData.object.rotation.y = -this.birdData.angle;
        }
        // Guard
        this.guardData.timer++;
        if(this.guardData.state==="idle"){
          if(this.guardData.timer>7200){
            this.guardData.state="patrol";
            this.guardData.timer=0;
            this.guardData.routeIndex=0;
          }
        } else if(this.guardData.state==="patrol"){
          const route = this.guardData.route;
          const guard = this.guardData.object;
          const tgt = route[this.guardData.routeIndex];
          const dx = tgt.x - guard.position.x;
          const dz = tgt.z - guard.position.z;
          if(dx*dx + dz*dz <1){
            this.guardData.routeIndex++;
            if(this.guardData.routeIndex>=route.length){
              this.guardData.state="idle";
              this.guardData.timer=0;
            }
          } else {
            this.animateArms(guard,true);
            const angle = Math.atan2(dx,dz);
            guard.rotation.y=angle;
            guard.position.x += Math.sin(angle)*this.guardData.speed;
            guard.position.z += Math.cos(angle)*this.guardData.speed;
          }
        }
        // Piazza NPCs
        for(let i=0; i<this.piazzaNPCData.length; i++){
          const data = this.piazzaNPCData[i];
          const npc = data.object;
          if(!npc.userData.target){
            npc.userData.target = { x:Math.random()*10-5, z:Math.random()*10-5 };
          }
          const dx = npc.userData.target.x - npc.position.x;
          const dz = npc.userData.target.z - npc.position.z;
          if(dx*dx + dz*dz <1){
            npc.userData.target = { x:Math.random()*10-5, z:Math.random()*10-5 };
          } else {
            this.animateArms(npc,true);
            const angle = Math.atan2(dx,dz);
            npc.rotation.y = angle;
            npc.position.x += Math.sin(angle)*data.speed;
            npc.position.z += Math.cos(angle)*data.speed;
          }
        }
      }
      getRandomBuildingTarget(){
        const i = Math.floor(Math.random()*this.buildingPositions.length);
        return this.buildingPositions[i];
      }

      spawnRipple(x,z){
        const rippleGeo = new THREE.RingGeometry(0.2,0.4,16);
        const rippleMat = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.5 });
        const ripple = new THREE.Mesh(rippleGeo, rippleMat);
        ripple.rotation.x = -Math.PI/2;
        ripple.position.set(x,0.05,z);
        this.scene.add(ripple);
        setTimeout(()=>{ this.scene.remove(ripple); },600);
      }

      /*******************************
       * PICKUPS
       *******************************/
      createFlowers(count){
        for(let i=0; i<count; i++){
          const fx = Math.random()*80*2 -80;
          const fz = Math.random()*80*2 -80;
          const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,1,8),
            new THREE.MeshStandardMaterial({ color:0x008000 }));
          stem.position.y=0.5;
          const bloom = new THREE.Mesh(new THREE.SphereGeometry(0.2,8,8),
            new THREE.MeshStandardMaterial({ color:0xff0000 }));
          bloom.position.y=1;
          const flower = new THREE.Group();
          flower.add(stem,bloom);
          flower.position.set(fx,0,fz);
          this.outsideGroup.add(flower);
          this.objects.push({ mesh:flower, type:"flower", x:fx, z:fz, boundingRadius:0.5 });
        }
      }
      createCoins(count){
        for(let i=0; i<count; i++){
          const cx = Math.random()*80*2 -80;
          const cz = Math.random()*80*2 -80;
          const coin = new THREE.Mesh(new THREE.CircleGeometry(0.3,16),
            new THREE.MeshStandardMaterial({ color:0xffff00 }));
          coin.rotation.x=-Math.PI/2;
          coin.position.set(cx,0.01,cz);
          this.outsideGroup.add(coin);
          this.objects.push({ mesh:coin, type:"coin", x:cx, z:cz, boundingRadius:0.3 });
        }
      }
      createGems(count){
        for(let i=0; i<count; i++){
          const gx = Math.random()*80*2 -80;
          const gz = Math.random()*80*2 -80;
          const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.5,0),
            new THREE.MeshStandardMaterial({ color:0x00ffff }));
          gem.position.set(gx,0.5,gz);
          this.outsideGroup.add(gem);
          this.objects.push({ mesh:gem, type:"gem", x:gx, z:gz, boundingRadius:0.5 });
        }
      }
      createPotions(count){
        for(let i=0; i<count; i++){
          const px = Math.random()*80*2 -80;
          const pz = Math.random()*80*2 -80;
          const base = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.8,16),
            new THREE.MeshStandardMaterial({ color:0xffffff }));
          base.position.y=0.4;
          const liquid = new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.25,0.6,16),
            new THREE.MeshStandardMaterial({ color:0xff4500 }));
          liquid.position.y=0.4;
          const potion = new THREE.Group();
          potion.add(base,liquid);
          potion.position.set(px,0,pz);
          this.outsideGroup.add(potion);
          this.objects.push({ mesh:potion, type:"potion", x:px, z:pz, boundingRadius:0.5 });
        }
      }
      createKeys(count){
        for(let i=0; i<count; i++){
          const kx = Math.random()*80*2 -80;
          const kz = Math.random()*80*2 -80;
          const handle = new THREE.Mesh(new THREE.SphereGeometry(0.2,16,16),
            new THREE.MeshStandardMaterial({ color:0xffd700 }));
          const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,0.8,8),
            new THREE.MeshStandardMaterial({ color:0xffd700 }));
          shaft.position.y=-0.4;
          const key = new THREE.Group();
          key.add(handle,shaft);
          key.position.set(kx,0.5,kz);
          key.rotation.x=Math.PI/2;
          this.outsideGroup.add(key);
          this.objects.push({ mesh:key, type:"key", x:kx, z:kz, boundingRadius:0.5 });
        }
      }
      createArtifacts(count){
        for(let i=0; i<count; i++){
          const ax = Math.random()*80*2 -80;
          const az = Math.random()*80*2 -80;
          const artifact = new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),
            new THREE.MeshStandardMaterial({ color:0x9400d3 }));
          const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6,16,16),
            new THREE.MeshBasicMaterial({ color:0xffeb3b, transparent:true, opacity:0.5, side:THREE.BackSide }));
          const group = new THREE.Group();
          group.add(artifact,glow);
          group.position.set(ax,0.5,az);
          this.outsideGroup.add(group);
          this.objects.push({ mesh:group, type:"artifact", x:ax, z:az, boundingRadius:0.5 });
        }
      }

      updatePickups(){
        for(let i=this.objects.length-1; i>=0; i--){
          const obj = this.objects[i];
          if(["flower","coin","gem","potion","key","artifact"].includes(obj.type)){
            const dx = this.player.x - obj.x;
            const dz = this.player.z - obj.z;
            if(dx*dx + dz*dz <1){
              switch(obj.type){
                case "flower": this.flowers++; document.getElementById("flowers").textContent=this.flowers; break;
                case "coin": this.coins++; document.getElementById("coins").textContent=this.coins; break;
                case "gem": this.gems++; document.getElementById("gems").textContent=this.gems; break;
                case "potion": this.potions++; document.getElementById("potions").textContent=this.potions; break;
                case "key": this.keys++; document.getElementById("keys").textContent=this.keys; break;
                case "artifact": this.artifacts++; document.getElementById("artifacts").textContent=this.artifacts; break;
              }
              if(this.outsideGroup.children.includes(obj.mesh))
                this.outsideGroup.remove(obj.mesh);
              else
                this.insideGroup.remove(obj.mesh);
              this.objects.splice(i,1);
              this.showDialogue("Picked up a "+obj.type+"!");
            }
          }
        }
      }

      showDialogue(text){
        const dlg = document.getElementById("dialogue");
        dlg.style.display="block";
        dlg.textContent=text;
        setTimeout(()=>{
          dlg.style.display="none";
          dlg.textContent="";
        },1500);
      }
      showGuardPopup(text){
        const popup = document.getElementById("guardPopup");
        popup.style.display="block";
        popup.textContent=text;
        setTimeout(()=>{
          popup.style.display="none";
          popup.textContent="";
        },2000);
      }

      initKeyboardMouse(){
        document.addEventListener("keydown", e=>{
          this.keysPressed[e.key]=true;
          if(e.key===" ") this.throwBall();
        });
        document.addEventListener("keyup", e=>{
          this.keysPressed[e.key]=false;
        });
        document.addEventListener("mousedown", ()=>{
          try{ document.body.requestPointerLock(); }
          catch(err){ console.warn("Pointer lock failed:",err); }
        });
        document.addEventListener("mousemove", evt=>{
          if(document.pointerLockElement===document.body){
            const movementX = evt.movementX || 0;
            const sensitivity=0.001;
            this.player.yaw += movementX*sensitivity;
          }
        });
      }
    }

    try {
      window.game = new Game();
    } catch(err){
      console.error("Error initializing the game:", err);
      alert("Error initializing the game: "+err);
    }
  </script>
</body>
</html>
