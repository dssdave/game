<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town - With updateDayNight()</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw; height: 100vh;
    }
    canvas { display: block; }

    /* UI boxes */
    #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup {
      background: rgba(0,0,0,0.7);
      border: 4px solid #fff;
      border-radius: 5px;
      color: #fff;
      font-size: 28px;
      padding: 40px 80px;
      position: absolute;
      z-index: 10;
    }
    #ui         { top: 10px; left: 10px; }
    #ballCount  { top: 10px; right: 10px; }
    #dialogue   { bottom: 10px; left: 10px; max-width: 600px; display: none; }
    #controls   { bottom: 10px; right: 10px; }
    #errorMessage {
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      display: none;
    }
    #guardPopup {
      bottom: 50%; left: 50%;
      transform: translate(-50%,50%);
      display: none; text-align: center;
    }

    /* Toggle UI button */
    #toggleUIBtn {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      font-size: 24px;
      padding: 10px 20px;
      background: #333; color: #fff;
      border: 2px solid #fff; border-radius: 5px;
      cursor: pointer;
    }

    /* On-screen Controller Panels */
    #dpadContainer, #turnContainer, #actionContainer {
      position: absolute; z-index: 15;
    }
    /* D-Pad as a grid with a small gap */
    #dpadContainer {
      bottom: 16vh; left: 5vw;
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
    }
    #btnUp    { grid-column: 2; grid-row: 1; }
    #btnDown  { grid-column: 2; grid-row: 3; }
    #btnLeft  { grid-column: 1; grid-row: 2; }
    #btnRight { grid-column: 3; grid-row: 2; }

    #dpadContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 20px; color: #fff;
      cursor: pointer;
    }
    #turnContainer {
      bottom: 16vh; left: calc(5vw + 200px);
      display: flex; flex-direction: column; gap: 10px;
    }
    #turnContainer button, #actionContainer button {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      font-size: 16px; color: #fff;
      cursor: pointer;
    }
    #actionContainer {
      bottom: 16vh; left: calc(5vw + 200px + 70px);
      display: flex; flex-direction: column; gap: 10px;
    }

    /* Smaller UI on narrower screens */
    @media (max-width: 768px) {
      #ui, #ballCount, #dialogue, #controls, #guardPopup, #errorMessage {
        font-size: 16px; padding: 20px 30px;
      }
      #toggleUIBtn { font-size: 16px; }
      #dpadContainer {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
      }
      #dpadContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
      #turnContainer button, #actionContainer button {
        width: 50px; height: 50px; font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>

    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifacts: <span id="artifacts">0</span> |
      Health: <span id="health">100</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">Balls Thrown: <span id="ballCountValue">0</span></div>
    <div id="dialogue"></div>
    <div id="controls">
      Controls:<br>
      [Desktop] Arrow Up/Down = forward/back, Left/Right = turn, Space = throw ball<br>
      [Mobile] D‑Pad Up/Down = forward/back, Left/Right = strafe, L/R = turn, A = throw ball, B = jump
    </div>
    <div id="errorMessage">WebGL not supported in your browser.</div>
    <div id="guardPopup"></div>

    <!-- On-screen Controller Panels -->
    <div id="dpadContainer">
      <button id="btnUp">▲</button>
      <button id="btnDown">▼</button>
      <button id="btnLeft">◀</button>
      <button id="btnRight">▶</button>
    </div>
    <div id="turnContainer">
      <button id="btnTurnLeft">L</button>
      <button id="btnTurnRight">R</button>
    </div>
    <div id="actionContainer">
      <button id="btnThrow">A</button>
      <button id="btnBigThrow">B</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Toggle UI
    document.getElementById('toggleUIBtn').addEventListener('click', () => {
      const ids = ["ui", "ballCount", "dialogue", "controls", "guardPopup", "errorMessage"];
      for (const id of ids) {
        const el = document.getElementById(id);
        el.style.display = (el.style.display === "none") ? "block" : "none";
      }
    });

    // Prevent text highlighting on mobile
    function disableHighlight(id) {
      const btn = document.getElementById(id);
      ["touchstart", "mousedown"].forEach(evt => {
        btn.addEventListener(evt, e => { e.preventDefault(); }, { passive: false });
      });
    }
    ["btnUp","btnDown","btnLeft","btnRight","btnTurnLeft","btnTurnRight","btnThrow","btnBigThrow"]
      .forEach(disableHighlight);

    // On-screen controller state
    const controllerState = {
      dpadUp: false, dpadDown: false, dpadLeft: false, dpadRight: false,
      turnLeft: false, turnRight: false
    };
    function setButtonListener(btnId, stateProp) {
      const btn = document.getElementById(btnId);
      ["mousedown","touchstart"].forEach(evt => {
        btn.addEventListener(evt, e => { e.preventDefault(); controllerState[stateProp] = true; }, { passive:false });
      });
      ["mouseup", "touchend", "mouseleave"].forEach(evt => {
        btn.addEventListener(evt, e => { controllerState[stateProp] = false; });
      });
    }
    setButtonListener('btnUp', 'dpadUp');
    setButtonListener('btnDown', 'dpadDown');
    setButtonListener('btnLeft', 'dpadLeft');
    setButtonListener('btnRight', 'dpadRight');
    setButtonListener('btnTurnLeft', 'turnLeft');
    setButtonListener('btnTurnRight', 'turnRight');

    // A/B button actions
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game && typeof window.game.throwBall === "function") {
          window.game.throwBall();
        }
      }, { passive: false });
    });
    ["pointerdown", "click"].forEach(evt => {
      document.getElementById("btnBigThrow").addEventListener(evt, e => {
        e.preventDefault();
        if (window.game && typeof window.game.jump === "function") {
          window.game.jump();
        }
      }, { passive: false });
    });

    let game = null;

    try {
      const errorMsg = document.getElementById('errorMessage');
      const gameCanvas = document.getElementById('gameCanvas');
      if (!window.WebGLRenderingContext) {
        errorMsg.style.display = 'block';
        gameCanvas.style.display = 'none';
        throw new Error('WebGL not supported');
      }

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
      const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      gameCanvas.style.display = 'block';

      const keysPressed = {};

      class Game {
        constructor() {
          this.scene = scene;
          this.camera = camera;
          this.renderer = renderer;
          // We'll track dayNightCycle to do day/night transitions
          this.time = 'Day';
          this.dayNightCycle = 0;  // increments each frame

          this.player = {
            x: 0, y: 0.5, z: 0,
            baseSpeed: 0.1,
            yaw: 0, pitch: 0,
            jumpVelocity: 0,
            object: null
          };

          // Stats
          this.flowers = 0; 
          this.coins = 0; 
          this.gems = 0; 
          this.potions = 0; 
          this.keys = 0; 
          this.artifacts = 0;
          this.health = 100;

          this.objects = []; 
          this.buildingPositions = [];
          this.ballCount = 0;
          this.thrownBalls = [];
          this.keysPressed = keysPressed;
          this.itemRange = 80;

          // We'll keep references for day/night objects
          this.sunMesh = null; 
          this.moonMesh = null; 
          this.starsMesh = null;

          // Example NPC data
          this.npcBlueData = { angle: 0, speed: 0.001, radius: 120, object: null };
          this.npcYellowData = { object: null, speed: 0.03, target: null };
          this.guardData = {
            object: null,
            state: 'idle',
            timer: 0,
            route: [ { x: 35, z: 60 }, { x: 35, z: 70 }, { x: 55, z: 70 }, { x: 55, z: 60 }, { x: 45, z: 55 } ],
            routeIndex: 0,
            speed: 0.02
          };
          this.mermaidData = { object: null, route: [ { x: -15, z: -70 }, { x: 15, z: -70 } ], routeIndex: 0, speed: 0.02 };
          this.birdData = { angle: 0, speed: 0.002, radius: 140, object: null };
          this.guardObject = null; 
          this.guardMessageShown = false;
          this.npcBlueMessageShown = false; 
          this.mermaidMessageShown = false; 
          this.npcYellowMessageShown = false;

          // If we have an interior scene or not
          this.interior = false;
          this.outsideObjects = [];
          this.insideObjects = [];

          this.initScene();
          this.initKeyboardMouse();
          this.startAnimation();
        }

        // -----------------------
        // Example function stubs
        // to show day/night, etc.
        // -----------------------

        initScene() {
          // Example: outside background
          this.scene.background = new THREE.Color(0x87ceeb);

          // Basic environment (outside)
          // e.g. ground, sun, moon, etc.
          this.createOutside();
          this.createPlayer();
          // buildings, NPC, items, etc.

          // Camera start
          this.camera.position.set(this.player.x + 15, this.player.y + 15, this.player.z + 15);
          this.camera.lookAt(this.player.x, this.player.y + 1, this.player.z);
        }

        createOutside() {
          // Just an example ground
          const groundGeo = new THREE.PlaneGeometry(300,300);
          const groundMat = new THREE.MeshStandardMaterial({ color: 0x6bb26b });
          const ground = new THREE.Mesh(groundGeo, groundMat);
          ground.rotation.x = -Math.PI/2;
          this.scene.add(ground);
          this.outsideObjects.push(ground);

          // Simple day/night objects
          this.createSun();
          this.createMoon();
          this.createStars();
        }

        createSun() {
          const sunGeo = new THREE.SphereGeometry(9, 16, 16);
          const sunMat = new THREE.MeshBasicMaterial({ color: 0xffee00 });
          this.sunMesh = new THREE.Mesh(sunGeo, sunMat);
          this.sunMesh.position.set(0, 200, -200);
          this.sunMesh.visible = true;
          this.scene.add(this.sunMesh);
          this.outsideObjects.push(this.sunMesh);
        }
        createMoon() {
          const moonGeo = new THREE.SphereGeometry(6, 16, 16);
          const moonMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
          this.moonMesh = new THREE.Mesh(moonGeo, moonMat);
          this.moonMesh.position.set(-100,150,100);
          this.moonMesh.visible = false;
          this.scene.add(this.moonMesh);
          this.outsideObjects.push(this.moonMesh);
        }
        createStars() {
          const starCount = 300;
          const positions = new Float32Array(starCount * 3);
          for (let i=0; i<starCount; i++) {
            const r = 300 + Math.random()*200;
            const angle = Math.random()*Math.PI*2;
            const ySpread = Math.random()*200 - 50;
            positions[i*3]   = Math.cos(angle)*r;
            positions[i*3+1] = 50 + ySpread;
            positions[i*3+2] = Math.sin(angle)*r;
          }
          const starGeo = new THREE.BufferGeometry();
          starGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
          const starMat = new THREE.PointsMaterial({ color:0xffffff, size:1.2, depthTest:false });
          const starField = new THREE.Points(starGeo, starMat);
          starField.visible = false;
          this.scene.add(starField);
          this.starsMesh = starField;
          this.outsideObjects.push(starField);
        }

        createPlayer() {
          // minimal
          const group = new THREE.Group();
          const body = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4,0.5,1.2,16),
            new THREE.MeshStandardMaterial({ color:0xff69b4 })
          );
          body.position.y = 0.6;
          group.add(body);
          group.position.set(this.player.x, this.player.y, this.player.z);
          this.player.object = group;
          this.scene.add(group);
        }

        // The actual day/night function:
        updateDayNight() {
          // Increase cycle
          this.dayNightCycle = (this.dayNightCycle+1) % 1200;
          // Simple split day vs night
          if (this.dayNightCycle < 600) {
            this.time = 'Day';
            this.sunMesh.visible = true;
            this.moonMesh.visible = false;
            if (this.starsMesh) this.starsMesh.visible = false;
            this.scene.background = new THREE.Color(0x87ceeb);
          } else {
            this.time = 'Night';
            this.sunMesh.visible = false;
            this.moonMesh.visible = true;
            if (this.starsMesh) this.starsMesh.visible = true;
            this.scene.background = new THREE.Color(0x000000);
          }
          document.getElementById('time').textContent = this.time;
        }

        // -----------
        // ANIMATION
        // -----------
        startAnimation() {
          const animate = () => {
            requestAnimationFrame(animate);
            this.update();
            this.renderer.render(this.scene, this.camera);
          };
          animate();
        }

        update() {
          // We call updateDayNight here:
          this.updateDayNight();

          // Then do the rest
          this.updateMovement();
          // e.g. updateBalls(), updateGuard(), etc.
          this.updateCamera();
        }

        updateMovement() {
          // example
          let keyboardForward = 0, keyboardTurn=0;
          if (this.keysPressed['ArrowUp']) keyboardForward += 1;
          if (this.keysPressed['ArrowDown']) keyboardForward -= 1;
          if (this.keysPressed['ArrowLeft']) keyboardTurn += 1;
          if (this.keysPressed['ArrowRight']) keyboardTurn -= 1;

          let touchForward = 0, touchStrafe = 0;
          if (controllerState.dpadUp) touchForward += 1;
          if (controllerState.dpadDown) touchForward -= 1;
          if (controllerState.dpadLeft) touchStrafe += 1;
          if (controllerState.dpadRight) touchStrafe -= 1;

          let finalForward = (keyboardForward !== 0 ? keyboardForward : touchForward);
          let finalStrafe = touchStrafe;
          let finalTurn = keyboardTurn;
          if (controllerState.turnLeft) finalTurn += 1;
          if (controllerState.turnRight) finalTurn -= 1;

          // outside => 2.5 speed, inside => normal
          const speedMult = this.interior ? 1.0 : 2.5;
          const forwardVec = new THREE.Vector3(Math.sin(this.player.yaw),0,Math.cos(this.player.yaw));
          const rightVec   = new THREE.Vector3(Math.cos(this.player.yaw),0,-Math.sin(this.player.yaw));
          const movement   = forwardVec.clone().multiplyScalar(finalForward)
                              .add(rightVec.clone().multiplyScalar(finalStrafe));
          if (movement.length() > 1) movement.normalize();
          movement.multiplyScalar(this.player.baseSpeed * speedMult);

          const newX = this.player.x + movement.x;
          const newZ = this.player.z + movement.z;
          let canMove = true;

          // collision checks
          // ...
          if (canMove) {
            this.player.x = newX;
            this.player.z = newZ;
          }
          this.player.yaw += finalTurn * 0.02;

          // jump
          if (this.player.jumpVelocity !== 0 || this.player.y>0.5) {
            this.player.jumpVelocity -= 0.02;
            this.player.y += this.player.jumpVelocity;
            if (this.player.y<0.5) {
              this.player.y=0.5;
              this.player.jumpVelocity=0;
            }
          }

          if (this.player.object) {
            this.player.object.position.set(this.player.x, this.player.y, this.player.z);
            this.player.object.rotation.y = this.player.yaw;
          }
        }

        updateCamera() {
          const camDist=15;
          const offsetX = -Math.sin(this.player.yaw)*camDist;
          const offsetZ = -Math.cos(this.player.yaw)*camDist;
          const offsetY = 10;
          this.camera.position.set(
            this.player.x + offsetX,
            this.player.y + offsetY,
            this.player.z + offsetZ
          );
          this.camera.lookAt(
            this.player.x,
            this.player.y+1,
            this.player.z
          );
        }

        throwBall() {
          // ...
          console.log("Throwing ball...");
        }
        jump() {
          // ...
          console.log("Jumping...");
          if (this.player.y<=0.5) {
            this.player.jumpVelocity=0.3;
          }
        }

        initKeyboardMouse() {
          document.addEventListener('keydown', e => {
            this.keysPressed[e.key]=true;
            if (e.key===' ') this.throwBall();
          });
          document.addEventListener('keyup', e => {
            this.keysPressed[e.key]=false;
          });
          document.addEventListener('mousedown', () => {
            if (!/Mobi|Android/i.test(navigator.userAgent)) {
              // pointer lock on desktop only
              try { document.body.requestPointerLock(); }
              catch(err) { console.warn('Pointer lock fail',err); }
            }
          });
          document.addEventListener('mousemove', evt => {
            if (document.pointerLockElement===document.body) {
              const movementX= evt.movementX||0;
              const sensitivity=0.001;
              this.player.yaw += movementX*sensitivity;
            }
          });
        }
      }

      window.game = new Game();
    } catch (err) {
      console.error('Error initializing the game:', err);
    }
  </script>
</body>
</html>
