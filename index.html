<!-- Continue the same file here -->
<!-- (the line from updateBlueNPC onward) -->

            updateBlueNPC(){
              npcBlueData.angle += npcBlueData.speed;
              const npcX = npcBlueData.radius * Math.cos(npcBlueData.angle);
              const npcZ = npcBlueData.radius * Math.sin(npcBlueData.angle);
              if (npcBlueData.object) {
                npcBlueData.object.position.set(npcX, 0.5, npcZ);
                npcBlueData.object.rotation.y = -npcBlueData.angle;
                // Update collision position
                for (const obj of this.objects) {
                  if (obj.mesh === npcBlueData.object) {
                    obj.x = npcX;
                    obj.z = npcZ;
                    break;
                  }
                }
              }
            }

            updateYellowNPC(){
              // The yellow NPC roams among the buildings
              if (!npcYellowData.object) return;
              const npc = npcYellowData.object;
              if (!npcYellowData.target) {
                npcYellowData.target = this.getRandomBuildingTarget();
              }
              const dx = npcYellowData.target.x - npc.position.x;
              const dz = npcYellowData.target.z - npc.position.z;
              const distSq = dx*dx + dz*dz;
              if (distSq < 1) {
                // Reached building -> pick new
                npcYellowData.target = this.getRandomBuildingTarget();
              } else {
                const angle = Math.atan2(-dx, dz);
                npc.rotation.y = angle;
                const step = npcYellowData.speed;
                const newX = npc.position.x + Math.sin(angle)*step;
                const newZ = npc.position.z + Math.cos(angle)*step;
                // clamp to boundary
                if (Math.abs(newX) < 125 && Math.abs(newZ) < 125) {
                  npc.position.x = newX;
                  npc.position.z = newZ;
                }
              }
              // Update collision position
              for (const obj of this.objects) {
                if (obj.mesh === npcYellowData.object) {
                  obj.x = npc.position.x;
                  obj.z = npc.position.z;
                  break;
                }
              }
            }

            getRandomBuildingTarget(){
              const i = Math.floor(Math.random() * this.buildingPositions.length);
              return this.buildingPositions[i];
            }

            updateBird(){
              birdData.angle += birdData.speed;
              const bx = birdData.radius * Math.cos(birdData.angle);
              const bz = birdData.radius * Math.sin(birdData.angle);
              if (birdData.object) {
                birdData.object.position.set(bx, 60, bz);
                birdData.object.rotation.y = -birdData.angle;
              }
            }

            updateCollisions(){
              // Guard
              if (this.guardObject && !this.guardMessageShown) {
                const dxG = this.player.x - this.guardObject.position.x;
                const dzG = this.player.z - this.guardObject.position.z;
                const distG = Math.sqrt(dxG*dxG + dzG*dzG);
                if (distG < 5) {
                  this.showGuardPopup("I'm the guard of this castle. Please show your ID.");
                }
              }
              // Blue NPC
              if (npcBlueData.object && !this.npcBlueMessageShown) {
                const dxN = this.player.x - npcBlueData.object.position.x;
                const dzN = this.player.z - npcBlueData.object.position.z;
                const distN = Math.sqrt(dxN*dxN + dzN*dzN);
                if (distN < 5) {
                  this.showGuardPopup("Hello Princess Donia!");
                  this.npcBlueMessageShown = true;
                  setTimeout(() => { this.npcBlueMessageShown = false; }, 2500);
                }
              }
              // Mermaid
              if (!this.mermaidMessageShown) {
                const mermaidObj = this.objects.find(o => o.type === 'mermaid');
                if (mermaidObj) {
                  const dxM = this.player.x - mermaidObj.x;
                  const dzM = this.player.z - mermaidObj.z;
                  const distM = Math.sqrt(dxM*dxM + dzM*dzM);
                  if (distM < 5) {
                    this.showGuardPopup("Hello Princess Donia. It's me the Mermaid.");
                    this.mermaidMessageShown = true;
                    setTimeout(() => { this.mermaidMessageShown = false; }, 2500);
                  }
                }
              }
            }

            updateCamera(){
              const camDist = 15;
              const offsetX = camDist * Math.sin(this.player.yaw) * Math.cos(this.player.pitch);
              const offsetZ = camDist * Math.cos(this.player.yaw) * Math.cos(this.player.pitch);
              const offsetY = camDist * Math.sin(this.player.pitch) + 15;
              this.camera.position.set(this.player.x + offsetX, offsetY, this.player.z + offsetZ);
              this.camera.lookAt(this.player.x, 3.5, this.player.z);
            }

            updatePickups(){
              for (const obj of this.objects) {
                if (obj.isPickup) {
                  const dxObj = this.player.x - obj.x;
                  const dzObj = this.player.z - obj.z;
                  const distSq = dxObj*dxObj + dzObj*dzObj;
                  if (distSq < 4) {
                    switch(obj.type){
                      case 'flower':
                        this.flowers++;
                        document.getElementById('flowers').textContent = this.flowers;
                        this.showDialogue('You picked a radiant flower!');
                        break;
                      case 'coin':
                        this.coins++;
                        document.getElementById('coins').textContent = this.coins;
                        this.showDialogue('You picked up a shiny coin!');
                        break;
                      case 'gem':
                        this.gems++;
                        document.getElementById('gems').textContent = this.gems;
                        this.showDialogue('A dazzling gem is yours!');
                        break;
                      case 'potion':
                        this.potions++;
                        document.getElementById('potions').textContent = this.potions;
                        this.showDialogue('You found a potion!');
                        break;
                      case 'key':
                        this.keys++;
                        document.getElementById('keys').textContent = this.keys;
                        this.showDialogue('A golden key is yours!');
                        break;
                      case 'artifact':
                        this.artifacts++;
                        document.getElementById('artifacts').textContent = this.artifacts;
                        this.showDialogue('You discovered a mystical artifact!');
                        break;
                    }
                    this.sceneObj.remove(obj.mesh);
                    this.objects = this.objects.filter(o => o !== obj);
                    this.startCollectionGlow();
                  }
                }
              }
            }

            /*-----------------------------------------
              8) Utility
            -----------------------------------------*/
            showDialogue(text){
              document.getElementById('dialogue').textContent = text;
            }
            showGuardPopup(text){
              const popup = document.getElementById('guardPopup');
              popup.style.display = 'block';
              popup.textContent = text;
              setTimeout(() => {
                popup.style.display = 'none';
                popup.textContent = '';
              }, 2000);
            }
            throwBall(){
              let direction = new THREE.Vector3();
              if (this.player.lastMoveVec.lengthSq() > 0.001) {
                direction.copy(this.player.lastMoveVec).normalize();
              } else {
                direction.set(Math.cos(this.player.yaw), 0, Math.sin(this.player.yaw)).normalize();
              }
              const ballGeo = new THREE.SphereGeometry(0.3,16,16);
              const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4500 });
              const ball = new THREE.Mesh(ballGeo, ballMat);
              ball.position.copy(this.player.object.position);
              ball.position.y += 1;
              ball.userData = {
                velocity: direction.multiplyScalar(0.5).add(new THREE.Vector3(0,0.3,0)),
                bounced: false
              };
              this.sceneObj.add(ball);
              this.thrownBalls.push(ball);
              this.ballCount++;
              document.getElementById('ballCountValue').textContent = this.ballCount;
              this.showDialogue("Threw a magic ball!");
            }
            startCollectionGlow(){
              if (this.collectionGlow) this.sceneObj.remove(this.collectionGlow);
              const glowGeo = new THREE.SphereGeometry(1,16,16);
              const glowMat = new THREE.MeshBasicMaterial({ color:0xffff00, transparent:true, opacity:0.5, side:THREE.BackSide });
              const glow = new THREE.Mesh(glowGeo, glowMat);
              glow.position.copy(this.player.object.position);
              glow.position.y += 0.5;
              this.sceneObj.add(glow);
              this.collectionGlow = glow;
              setTimeout(() => {
                if (this.collectionGlow) {
                  this.sceneObj.remove(this.collectionGlow);
                  this.collectionGlow = null;
                }
              }, 1000);
            }

            initJoysticks(){
              this.joystickLeft = nipplejs.create({
                zone: document.getElementById('joystickLeft'),
                mode: 'static',
                color: 'white',
                size: 80,
                position: { left:'10vw', bottom:'14vh' }
              });
              this.joystickLeft.on('move', (evt, data) => {
                if (data && data.force > 0) {
                  const angle = data.angle.radian;
                  const speed = data.force * this.player.speedJoystick;
                  const dx = Math.cos(angle) * speed;
                  const dz = Math.sin(angle) * speed;
                  const newX = this.player.x + dx;
                  const newZ = this.player.z - dz;

                  let blocked = false;
                  for (const obj of this.objects) {
                    if (obj.type==='building' || obj.type==='wall' || obj.type==='boundary' || obj.type==='decoration' || obj.type==='npc') {
                      const dxObj = newX - obj.x;
                      const dzObj = newZ - obj.z;
                      const distSq = dxObj*dxObj + dzObj*dzObj;
                      const r = (obj.boundingRadius || 5);
                      if (distSq < r*r) {
                        blocked = true;
                        break;
                      }
                    }
                  }
                  if (!blocked) {
                    this.player.x = newX;
                    this.player.z = newZ;
                  }
                  this.joystickLeft.active = true;
                }
              });
              this.joystickLeft.on('end', () => { this.joystickLeft.active = false; });

              this.joystickRight = nipplejs.create({
                zone: document.getElementById('joystickRight'),
                mode: 'static',
                color: 'white',
                size: 80,
                position: { right:'10vw', bottom:'14vh' }
              });
              this.joystickRight.on('move', (evt, data) => {
                if (data && data.force>0) {
                  const sensitivity = 0.001;
                  this.player.yaw += data.vector.x * sensitivity * data.force;
                  this.player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.pitch + data.vector.y*sensitivity*data.force));
                }
              });
              this.joystickRight.on('end', () => {});

              // Tap center to throw
              document.getElementById('gameContainer').addEventListener('click', e=>{
                const rect=e.target.getBoundingClientRect();
                const x=e.clientX - rect.left;
                const y=e.clientY - rect.top;
                if (x>rect.width/4 && x<(rect.width*3)/4 && y>rect.height/4 && y<(rect.height*3)/4) {
                  this.throwBall();
                }
              });
            }

            initKeyboardMouse(){
              document.addEventListener('keydown', e=>{
                this.keysPressed[e.key] = true;
                if (e.key===' ') this.throwBall();
              });
              document.addEventListener('keyup', e=>{
                this.keysPressed[e.key] = false;
              });
              document.addEventListener('mousedown', ()=>{
                document.body.requestPointerLock();
              });
              document.addEventListener('mousemove', event=>{
                if (document.pointerLockElement===document.body) {
                  const movementX=event.movementX||0;
                  const movementY=event.movementY||0;
                  const sensitivity=0.001;
                  this.player.yaw += movementX*sensitivity;
                  this.player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.pitch+movementY*sensitivity));
                }
              });
            }
        }

        // Create the game
        const game = new Game();
      } catch(error){
        console.error('Error initializing the game:',error);
      }
    </script>
  </body>
</html>
