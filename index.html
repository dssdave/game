<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
  <title>Princess Donia’s Town – Enhanced RPG</title>
  <style>
    html, body { margin:0; padding:0; background:#000; font-family:Arial, sans-serif; overflow:hidden; user-select:none; touch-action:manipulation; }
    #gameContainer { position:relative; width:100vw; height:100vh; }
    canvas { display:block; }
    #ui, #ballCount, #dialogue, #controls, #errorMessage, #guardPopup, #healthBar, #inventory {
      background:rgba(0,0,0,0.7); border:4px solid #fff; border-radius:5px; color:#fff; font-size:28px; padding:20px 30px; position:absolute; z-index:10;
    }
    #ui { top:10px; left:10px; }
    #ballCount { top:10px; right:10px; }
    #dialogue { bottom:10px; left:10px; max-width:600px; display:none; }
    #controls { bottom:10px; right:10px; }
    #errorMessage { top:50%; left:50%; transform:translate(-50%,-50%); display:none; }
    #guardPopup { bottom:50%; left:50%; transform:translate(-50%,50%); display:none; text-align:center; }
    #healthBar { top:10px; left:50%; transform:translateX(-50%); width:300px; height:20px; background:#333; border:3px solid #fff; border-radius:10px; overflow:hidden; }
    #healthFill { width:100%; height:100%; background:#00ff00; transition:width 0.3s, background 0.3s; }
    #toggleUIBtn { position:absolute; top:10px; left:50%; transform:translateX(-50%); z-index:11; font-size:24px; padding:10px 20px; background:#333; color:#fff; border:2px solid #fff; border-radius:5px; cursor:pointer; }
    #inventory { display:none; top:50%; left:50%; transform:translate(-50%,-50%); padding:30px; border:4px solid #ffd700; border-radius:15px; font-size:24px; text-align:center; }
    @media (max-width:768px) {
      #ui, #ballCount, #dialogue, #controls { font-size:16px; padding:10px 15px; }
      #toggleUIBtn { font-size:16px; }
      #healthBar { width:200px; }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="toggleUIBtn">Toggle UI</button>
    <div id="ui">
      Flowers: <span id="flowers">0</span> |
      Coins: <span id="coins">0</span> |
      Gems: <span id="gems">0</span> |
      Potions: <span id="potions">0</span> |
      Keys: <span id="keys">0</span> |
      Artifacts: <span id="artifacts">0</span> |
      Health: <span id="health">100</span> |
      Time: <span id="time">Day</span> |
      Location: <span id="location">Town</span>
    </div>
    <div id="ballCount">Magic Orbs Thrown: <span id="ballCountValue">0</span></div>
    <div id="dialogue"></div>
    <div id="controls">
      Controls:<br>
      Desktop: WASD/Arrows move/turn, Space = orb, B = jump, I = inventory<br>
      Mobile: Left joystick move, A = orb, B = jump
    </div>
    <div id="errorMessage">WebGL not supported.</div>
    <div id="guardPopup"></div>
    <div id="healthBar"><div id="healthFill"></div></div>
    <div id="inventory">
      <div>Flowers: <span id="invFlowers">0</span></div>
      <div style="margin-top:20px;">Quest: Collect 10 flowers to restore the garden</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // UI Toggle
    document.getElementById('toggleUIBtn').onclick = () => {
      ["ui","ballCount","dialogue","controls","guardPopup","errorMessage","healthBar"].forEach(id => {
        const el = document.getElementById(id);
        el.style.display = el.style.display === "none" ? "block" : "none";
      });
    };

    // Mobile Joystick
    const joystick = {forward:0, strafe:0, active:false};
    function createJoystick() {
      const div = document.createElement('div');
      div.style.position='absolute'; div.style.left='5vw'; div.style.bottom='16vh';
      div.style.width='120px'; div.style.height='120px'; div.style.background='rgba(255,255,255,0.1)';
      div.style.border='3px solid #fff'; div.style.borderRadius='50%'; div.style.zIndex='15';
      const nipple = document.createElement('div');
      nipple.style.position='absolute'; nipple.style.width='50px'; nipple.style.height='50px';
      nipple.style.background='rgba(255,255,255,0.4)'; nipple.style.borderRadius='50%';
      nipple.style.left='35px'; nipple.style.top='35px'; nipple.style.transition='0.1s';
      div.appendChild(nipple);
      document.getElementById('gameContainer').appendChild(div);

      const start = e => { e.preventDefault(); joystick.active=true; move(e); };
      const move = e => {
        if(!joystick.active) return;
        const touch = e.touches ? e.touches[0] : e;
        const rect = div.getBoundingClientRect();
        const dx = touch.clientX - (rect.left + 60);
        const dy = touch.clientY - (rect.top + 60);
        const dist = Math.min(Math.hypot(dx,dy),50);
        const angle = Math.atan2(dx,dy);
        joystick.strafe = dist * Math.sin(angle) / 50;
        joystick.forward = dist * Math.cos(angle) / 50;
        nipple.style.transform = `translate(${dist*Math.sin(angle)}px, ${dist*Math.cos(angle)}px)`;
      };
      const end = () => { joystick.active=false; joystick.forward=joystick.strafe=0; nipple.style.transform='translate(0,0)'; };
      div.addEventListener('touchstart',start,{passive:false});
      div.addEventListener('touchmove',move,{passive:false});
      div.addEventListener('touchend',end);
      div.addEventListener('mousedown',start);
      div.addEventListener('mousemove',move);
      div.addEventListener('mouseup',end); div.addEventListener('mouseleave',end);
    }
    createJoystick();

    // Mobile Action Buttons
    const actions = document.createElement('div');
    actions.style.position='absolute'; actions.style.bottom='16vh'; actions.style.right='5vw';
    actions.style.display='flex'; actions.style.flexDirection='column'; actions.style.gap='15px'; actions.style.zIndex='15';
    const btnOrb = document.createElement('button');
    btnOrb.textContent='A (Orb)'; btnOrb.style.width='70px'; btnOrb.style.height='70px';
    btnOrb.style.background='rgba(255,100,100,0.6)'; btnOrb.style.border='3px solid #fff'; btnOrb.style.borderRadius='50%'; btnOrb.style.color='#fff'; btnOrb.style.fontSize='16px';
    const btnJump = document.createElement('button');
    btnJump.textContent='B (Jump)'; btnJump.style.width='70px'; btnJump.style.height='70px';
    btnJump.style.background='rgba(100,100,255,0.6)'; btnJump.style.border='3px solid #fff'; btnJump.style.borderRadius='50%'; btnJump.style.color='#fff'; btnJump.style.fontSize='16px';
    actions.appendChild(btnOrb); actions.appendChild(btnJump);
    document.getElementById('gameContainer').appendChild(actions);

    // Global
    const outsideScene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
    const keysPressed = {};
    let game = null;

    class Game {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({canvas:document.getElementById('gameCanvas'), antialias:true});
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
        this.renderer.shadowMap.enabled = true;

        this.player = {x:0,y:0.5,z:0,yaw:0,jumpVelocity:0,object:null,bobTime:0};
        this.flowers=this.coins=this.gems=this.potions=this.keys=this.artifacts=0;
        this.health=100; this.ballCount=0; this.thrownBalls=[];
        this.dayNightCounter=0; this.time="Day";
        this.outsideObjects=[]; this.fireflies=null; this.waterMesh=null;
        this.questActive=false; this.questComplete=false;

        this.initScene();
        this.createPlayer();
        this.createAllWorldObjects();
        this.startAnimation();
        this.initInput();
      }

      initScene() {
        outsideScene.background = new THREE.Color(0x87CEEB);
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshStandardMaterial({color:0x6bb26b}));
        ground.rotation.x = -Math.PI/2; ground.receiveShadow=true;
        outsideScene.add(ground);

        const ambient = new THREE.AmbientLight(0xffffff,0.6);
        const dirLight = new THREE.DirectionalLight(0xffffff,1);
        dirLight.position.set(50,100,50); dirLight.castShadow=true;
        outsideScene.add(ambient, dirLight);

        this.createSun(); this.createMoon(); this.createStars();
        this.createWaterWithWaves(); this.createFireflies();
      }

      createPlayer() {
        const g = new THREE.Group();
        const dress = new THREE.Mesh(new THREE.ConeGeometry(0.6,1.6,16), new THREE.MeshStandardMaterial({color:0xff69b4}));
        dress.position.y=0.7; g.add(dress);
        const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.4,0.8,16), new THREE.MeshStandardMaterial({color:0xffa0d0}));
        torso.position.y=1.2; g.add(torso);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({color:0xffddc1}));
        head.position.y=1.8; g.add(head);
        const hair = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.45,1.2,16), new THREE.MeshStandardMaterial({color:0xb5651d}));
        hair.position.y=1.9; g.add(hair);
        const crown = new THREE.Mesh(new THREE.TorusGeometry(0.32,0.08,8,16), new THREE.MeshStandardMaterial({color:0xffd700,emissive:0xffd700,emissiveIntensity:0.8}));
        crown.rotation.x=Math.PI/2; crown.position.y=2.15; g.add(crown);
        const armGeo = new THREE.CylinderGeometry(0.1,0.1,0.9,8);
        const armMat = new THREE.MeshStandardMaterial({color:0xffddc1});
        const left = new THREE.Mesh(armGeo,armMat); left.position.set(-0.5,1.3,0); left.rotation.z=0.3; left.userData={arm:true}; g.add(left);
        const right = left.clone(); right.position.x=0.5; right.rotation.z=-0.3; g.add(right);
        g.position.set(this.player.x,this.player.y,this.player.z);
        this.player.object = g;
        outsideScene.add(g);
      }

      generateStoneTexture() {
        const c = document.createElement('canvas'); c.width=c.height=256;
        const ctx = c.getContext('2d');
        for(let y=0;y<256;y+=16)for(let x=0;x<256;x+=16){
          const s = 100 + Math.random()*60;
          ctx.fillStyle=`rgb(${s},${s},${s})`; ctx.fillRect(x,y,16,16);
        }
        return new THREE.CanvasTexture(c);
      }

      createCastle() {
        const g = new THREE.Group();
        const tex = this.generateStoneTexture();
        const mat = new THREE.MeshStandardMaterial({map:tex});
        const base = new THREE.Mesh(new THREE.BoxGeometry(20,10,20), mat);
        base.position.y=5; g.add(base);
        const towerGeo = new THREE.CylinderGeometry(3,3,15,16);
        [[10,7.5,10],[-10,7.5,10],[10,7.5,-10],[-10,7.5,-10]].forEach(p=> {
          const t = new THREE.Mesh(towerGeo,mat.clone()); t.position.set(...p); g.add(t);
        });
        const door = new THREE.Mesh(new THREE.PlaneGeometry(4,6), new THREE.MeshStandardMaterial({color:0x553300,side:THREE.DoubleSide}));
        door.position.set(0,3,10.01); g.add(door);
        g.position.set(40,0,40);
        outsideScene.add(g);
        this.outsideObjects.push({type:'building',x:40,z:40,boundingRadius:12});
        // Castle door entry
        this.castleDoor = {x:40,z:50,radius:5};
      }

      createHouse() {
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(12,8,10), new THREE.MeshStandardMaterial({color:0x8b4513}));
        base.position.y=4; g.add(base);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(6,4,4), new THREE.MeshStandardMaterial({color:0x800000}));
        roof.position.y=8; roof.rotation.y=Math.PI/4; g.add(roof);
        g.position.set(-40,0,-40);
        outsideScene.add(g);
        this.outsideObjects.push({type:'building',x:-40,z:-40,boundingRadius:10});
      }

      createCafe() {
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(12,7,10), new THREE.MeshStandardMaterial({color:0x888888}));
        base.position.y=3.5; g.add(base);
        g.position.set(70,0,-30);
        outsideScene.add(g);
        this.outsideObjects.push({type:'building',x:70,z:-30,boundingRadius:10});
      }

      createFountain() {
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(3,3,1,16), new THREE.MeshStandardMaterial({color:0x808080}));
        base.position.y=0.5; g.add(base);
        g.position.set(0,0,20);
        outsideScene.add(g);
        this.outsideObjects.push({type:'decoration',x:0,z:20,boundingRadius:3});
      }

      createGuard() {
        const g = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,1.2,16), new THREE.MeshStandardMaterial({color:0x000000}));
        body.position.y=0.6; g.add(body);
        g.position.set(45,0.5,55.5);
        outsideScene.add(g);
        this.outsideObjects.push({type:'guard',x:45,z:55.5,boundingRadius:3});
      }

      createLightPost(x,z) {
        const post = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,4,8), new THREE.MeshStandardMaterial({color:0x444444}));
        post.position.set(x,2,z);
        const lamp = new THREE.Mesh(new THREE.SphereGeometry(0.4,8,8), new THREE.MeshStandardMaterial({color:0xffff00,emissive:0xffff00,emissiveIntensity:0.5}));
        lamp.position.set(x,4,z);
        const light = new THREE.PointLight(0xffffaa,0.7,20);
        light.position.set(x,4,z);
        outsideScene.add(post,lamp,light);
      }

      createWaterWithWaves() {
        const geo = new THREE.PlaneGeometry(300,80);
        const mat = new THREE.MeshStandardMaterial({color:0x1e90ff,transparent:true,opacity:0.7});
        const water = new THREE.Mesh(geo,mat);
        water.rotation.x = -Math.PI/2;
        water.position.set(0,0.1,-70);
        water.userData={time:0};
        outsideScene.add(water);
        this.waterMesh = water;
      }

      createFireflies() {
        const count=80;
        const pos = new Float32Array(count*3);
        for(let i=0;i<count;i++){
          pos[i*3]=(Math.random()-0.5)*200;
          pos[i*3+1]=5+Math.random()*20;
          pos[i*3+2]=(Math.random()-0.5)*200;
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
        const mat = new THREE.PointsMaterial({color:0xffff88,size:3,transparent:true});
        const flies = new THREE.Points(geo,mat);
        flies.visible=false;
        outsideScene.add(flies);
        this.fireflies = flies;
      }

      createSun() { /* same as before */ 
        const sun = new THREE.Mesh(new THREE.SphereGeometry(10,16,16), new THREE.MeshBasicMaterial({color:0xffee00}));
        sun.position.set(0,200,-200);
        this.sunMesh=sun; outsideScene.add(sun);
      }
      createMoon() {
        const moon = new THREE.Mesh(new THREE.SphereGeometry(6,16,16), new THREE.MeshBasicMaterial({color:0xddddff}));
        moon.position.set(-100,150,100); moon.visible=false;
        this.moonMesh=moon; outsideScene.add(moon);
      }
      createStars() {
        const count=300;
        const pos = new Float32Array(count*3);
        for(let i=0;i<count;i++){
          const r=300+Math.random()*200; const a=Math.random()*Math.PI*2;
          pos[i*3]=Math.cos(a)*r; pos[i*3+1]=50+Math.random()*100; pos[i*3+2]=Math.sin(a)*r;
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
        const mat = new THREE.PointsMaterial({color:0xffffff,size:1.5});
        const stars = new THREE.Points(geo,mat); stars.visible=false;
        this.starsMesh=stars; outsideScene.add(stars);
      }

      createFlowers(count) {
        for(let i=0;i<count;i++){
          const x=Math.random()*160-80, z=Math.random()*160-80;
          const f = new THREE.Group();
          const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,1,8), new THREE.MeshStandardMaterial({color:0x008000}));
          stem.position.y=0.5; f.add(stem);
          const bloom = new THREE.Mesh(new THREE.SphereGeometry(0.25,12,12), new THREE.MeshStandardMaterial({color:0xff1493}));
          bloom.position.y=1; f.add(bloom);
          f.position.set(x,0,z);
          outsideScene.add(f);
          this.outsideObjects.push({type:'flower',mesh:f,x,z,boundingRadius:1});
        }
      }

      // Add other collectibles similarly (coins, gems, etc.) - abbreviated for space
      createCoins(count) { /* similar to flowers, color 0xffff00 */ }
      createGems(count) { /* octahedron, cyan */ }
      createPotions(count) { /* small bottle group */ }
      createKeys(count) { /* gold key group */ }
      createArtifacts(count) { /* purple sphere with glow */ }

      createAllWorldObjects() {
        this.createCastle(); this.createHouse(); this.createCafe(); this.createFountain(); this.createGuard();
        this.createLightPost(7,7); this.createLightPost(7,-7); this.createLightPost(-7,7); this.createLightPost(-7,-7);
        this.createLightPost(40,55); this.createLightPost(-40,-45); this.createLightPost(70,-35);
        this.createFlowers(20);
        // add other collectibles if you want
      }

      update() {
        this.updateDayNight();
        this.updateWater();
        this.updateFireflies();
        this.updateMovement();
        this.updateCamera();
        this.updatePickups();
        this.updateCollisions();
        this.updateQuest();
        this.updateBalls();
        this.updateUI();
      }

      updateDayNight() {
        this.dayNightCounter = (this.dayNightCounter+1)%18000;
        this.time = this.dayNightCounter<9000 ? "Day" : "Night";
        document.getElementById('time').textContent = this.time;
        outsideScene.background = new THREE.Color(this.time==="Day"?0x87CEEB:0x000022);
        this.sunMesh.visible = this.time==="Day";
        this.moonMesh.visible = this.time==="Night";
        this.starsMesh.visible = this.time==="Night";
        this.fireflies.visible = this.time==="Night";
      }

      updateWater() {
        if(this.waterMesh){
          this.waterMesh.userData.time += 0.01;
          const pos = this.waterMesh.geometry.attributes.position;
          for(let i=0;i<pos.count;i++){
            const vx=pos.getX(i), vz=pos.getZ(i);
            pos.setY(i, Math.sin(vx*0.1 + this.waterMesh.userData.time)*0.3 + Math.sin(vz*0.15 + this.waterMesh.userData.time*1.2)*0.2);
          }
          pos.needsUpdate=true;
        }
      }

      updateFireflies() {
        if(this.fireflies && this.fireflies.visible){
          const pos = this.fireflies.geometry.attributes.position.array;
          const t = Date.now()*0.001;
          for(let i=1;i<pos.length;i+=3) pos[i] += Math.sin(t + i)*0.03;
          this.fireflies.geometry.attributes.position.needsUpdate=true;
        }
      }

      updateMovement() {
        let forward=0, turn=0;
        if(keysPressed['w']||keysPressed['ArrowUp']) forward+=1;
        if(keysPressed['s']||keysPressed['ArrowDown']) forward-=1;
        if(keysPressed['a']||keysPressed['ArrowLeft']) turn+=1;
        if(keysPressed['d']||keysPressed['ArrowRight']) turn-=1;
        forward += joystick.forward;
        const strafe = joystick.strafe;

        const speed=0.12;
        const dir = new THREE.Vector3(Math.sin(this.player.yaw),0,Math.cos(this.player.yaw));
        const right = new THREE.Vector3(Math.cos(this.player.yaw),0,-Math.sin(this.player.yaw));
        const move = dir.clone().multiplyScalar(forward*speed).add(right.clone().multiplyScalar(strafe*speed));

        // simple collision
        let canMove=true;
        const newX = this.player.x + move.x;
        const newZ = this.player.z + move.z;
        for(const obj of this.outsideObjects){
          if(['building','decoration','guard'].includes(obj.type)){
            const dx = newX - obj.x;
            const dz = newZ - obj.z;
            if(dx*dx + dz*dz < (obj.boundingRadius||5)**2){ canMove=false; break; }
          }
        }
        if(canMove){ this.player.x=newX; this.player.z=newZ; }

        this.player.yaw -= turn*0.03;

        // jump
        if(this.player.jumpVelocity){
          this.player.jumpVelocity -= 0.02;
          this.player.y += this.player.jumpVelocity;
          if(this.player.y<0.5){ this.player.y=0.5; this.player.jumpVelocity=0; }
        }

        // bob & arms
        if(Math.abs(forward)+Math.abs(strafe)>0.1){
          this.player.bobTime += 0.15;
          this.player.object.position.y = 0.5 + Math.sin(this.player.bobTime)*0.05;
        } else this.player.object.position.y = this.player.y;
        this.player.object.position.x = this.player.x;
        this.player.object.position.z = this.player.z;
        this.player.object.rotation.y = this.player.yaw;
        this.player.object.traverse(c=>{ if(c.userData.arm) c.rotation.z = Math.sin(this.player.bobTime)*0.6*(c.position.x>0?-1:1); });

        // water splash
        if(this.player.z < -65 && this.player.z > -75 && (forward||strafe)) this.showDialogue("Splash!");
      }

      updateCamera() {
        const offset = new THREE.Vector3(-Math.sin(this.player.yaw)*18,12,-Math.cos(this.player.yaw)*18);
        camera.position.lerp(this.player.object.position.clone().add(offset),0.1);
        camera.lookAt(this.player.object.position.x, this.player.object.position.y+1.5, this.player.object.position.z);
      }

      updateCollisions() {
        // Guard greeting
        const dx = this.player.x - 45;
        const dz = this.player.z - 55.5;
        if(dx*dx + dz*dz < 25){
          document.getElementById('guardPopup').textContent = "Greetings, Princess Donia!";
          document.getElementById('guardPopup').style.display = 'block';
          setTimeout(()=>document.getElementById('guardPopup').style.display='none',2000);
        }
        // Castle entry
        if(this.castleDoor){
          const dx2 = this.player.x - this.castleDoor.x;
          const dz2 = this.player.z - this.castleDoor.z;
          if(dx2*dx2 + dz2*dz2 < this.castleDoor.radius**2){
            this.showDialogue("You entered the castle! (interior coming soon)");
          }
        }
      }

      updatePickups() {
        for(let i=this.outsideObjects.length-1;i>=0;i--){
          const o = this.outsideObjects[i];
          if(o.type==='flower'){
            const dx=this.player.x-o.x, dz=this.player.z-o.z;
            if(dx*dx + dz*dz < 4){
              this.flowers++;
              document.getElementById('flowers').textContent=this.flowers;
              document.getElementById('invFlowers').textContent=this.flowers;
              this.createSparkles(o.x,1,o.z);
              outsideScene.remove(o.mesh);
              this.outsideObjects.splice(i,1);
            }
          }
        }
      }

      createSparkles(x,y,z){
        for(let i=0;i<15;i++){
          const s = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshBasicMaterial({color:0xffff00}));
          s.position.set(x+(Math.random()-0.5),y+Math.random(),z+(Math.random()-0.5));
          s.userData={vel:new THREE.Vector3((Math.random()-0.5)*0.1,0.1+Math.random()*0.1,(Math.random()-0.5)*0.1),life:60};
          outsideScene.add(s);
          this.thrownBalls.push(s);
        }
      }

      updateQuest() {
        if(!this.questActive && this.flowers>=1){
          this.showDialogue("A gentle spirit whispers: Princess, please collect 10 flowers to restore the garden's magic!");
          this.questActive=true;
        }
        if(this.questActive && !this.questComplete && this.flowers>=10){
          this.showDialogue("Thank you, Princess Donia! The garden blooms once more. Your power grows...");
          this.questComplete=true;
        }
      }

      throwBall() {
        const dir = new THREE.Vector3(Math.sin(this.player.yaw),0.3,Math.cos(this.player.yaw)).normalize().multiplyScalar(0.8);
        const ball = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({color:0xff4500,emissive:0xff4500,emissiveIntensity:2}));
        ball.position.copy(this.player.object.position); ball.position.y+=1;
        const light = new THREE.PointLight(0xff4500,2,15); ball.add(light);
        ball.userData={velocity:dir,timer:0};
        outsideScene.add(ball);
        this.thrownBalls.push(ball);
        this.ballCount++;
        document.getElementById('ballCountValue').textContent=this.ballCount;
        this.showDialogue("Magic Orb!");
      }

      jump() {
        if(this.player.y<=0.51){
          this.player.jumpVelocity=0.35;
          this.showDialogue("♪ Jump! ♪");
        }
      }

      updateBalls() {
        for(let i=this.thrownBalls.length-1;i>=0;i--){
          const b=this.thrownBalls[i];
          if(b.userData.velocity){
            b.position.add(b.userData.velocity);
            b.userData.velocity.y-=0.015;
            b.userData.timer++;
            if(b.userData.timer>200 || b.position.y<0){
              outsideScene.remove(b); this.thrownBalls.splice(i,1);
            }
          } else if(b.userData.life){
            b.userData.life--;
            b.position.add(b.userData.vel);
            b.scale.multiplyScalar(0.95);
            if(b.userData.life<=0){
              outsideScene.remove(b); this.thrownBalls.splice(i,1);
            }
          }
        }
      }

      updateUI() {
        document.getElementById('healthFill').style.width = this.health+'%';
        document.getElementById('healthFill').style.background = this.health<30?'#ff0000':'#00ff00';
      }

      showDialogue(text) {
        const d=document.getElementById('dialogue');
        d.textContent=text; d.style.display='block';
        clearTimeout(this.dlgTO);
        this.dlgTO=setTimeout(()=>d.style.display='none',2500);
      }

      initInput() {
        document.addEventListener('keydown',e=>{
          keysPressed[e.key.toLowerCase()]=true;
          if(e.key===' ') this.throwBall();
          if(e.key.toLowerCase()==='b') this.jump();
          if(e.key.toLowerCase()==='i'){
            const inv=document.getElementById('inventory');
            inv.style.display=inv.style.display==='none'?'block':'none';
          }
        });
        document.addEventListener('keyup',e=>keysPressed[e.key.toLowerCase()]=false);
        btnOrb.onclick = btnOrb.ontouchstart = e=>{e.preventDefault(); this.throwBall();};
        btnJump.onclick = btnJump.ontouchstart = e=>{e.preventDefault(); this.jump();};
      }

      startAnimation() {
        const animate = () => {
          requestAnimationFrame(animate);
          this.update();
          this.renderer.render(outsideScene, camera);
        };
        animate();
      }
    }

    window.onload = () => {
      try {
        game = new Game();
      } catch(e) {
        console.error(e);
        document.getElementById('errorMessage').style.display='block';
      }
    };
  </script>
</body>
</html>
