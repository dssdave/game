<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Princess RPG - NES Final Fantasy Style</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(to bottom, #87ceeb, #e0ffff); /* NES sky */
        }
        canvas {
            border: 1px solid black;
            background-color: #32cd32; /* Grass base */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; // Crisp pixel art
        const tileSize = 16; // NES standard 16x16 tiles
        const mapWidth = 50;
        const mapHeight = 37;

        // Game state
        let score = 0;
        let currentScene = 'town';
        let fadeAlpha = 0;
        let isFading = false;
        let fadeDirection = 1;
        let targetScene = '';
        let questActive = false;
        let questItems = 0;
        let playerHP = 100;
        let enemyHP = 20;

        // Colors (NES palette-like)
        const colors = {
            grass: '#32cd32',
            path: '#cd853f',
            water: '#4169e1',
            mountain: '#a9a9a9',
            door: '#0000ff',
            floor: '#8b4513',
            wall: '#808080',
            pink: '#ff69b4',
            peach: '#ffdab9',
            yellow: '#ffd700',
            black: '#000',
            white: '#fff',
            enemy: '#ff0000',
            npc: '#228b22',
            exitDoor: '#ff4500'
        };

        // Define maps
        const townMap = Array(mapHeight).fill().map(() => Array(mapWidth).fill(0)); // Grass base
        const castleMap = Array(15).fill().map(() => Array(30).fill(5)); // Floor base
        const houseMap = Array(12).fill().map(() => Array(25).fill(5)); // Floor base

        // Town map details
        for (let r = 15; r < 25; r++) for (let c = 15; c < 35; c++) townMap[r][c] = 1; // Path
        for (let r = 5; r < 10; r++) for (let c = 5; c < 15; c++) townMap[r][c] = 2; // Water
        for (let r = 30; r < 37; r++) for (let c = 35; c < 50; c++) townMap[r][c] = 3; // Mountain
        townMap[10][10] = 4; // Castle door
        townMap[20][40] = 4; // House door

        // Interior details
        for (let c = 0; c < 30; c++) castleMap[0][c] = 6; // Castle walls
        for (let c = 0; c < 25; c++) houseMap[0][c] = 6; // House walls
        castleMap[7][15] = 7; // Castle exit
        houseMap[6][12] = 7; // House exit

        // Items
        const townItems = [
            {type: 'flower', row: 8, col: 18, points: 10, collected: false},
            {type: 'coin', row: 15, col: 25, points: 5, collected: false},
            {type: 'flower', row: 22, col: 30, points: 10, collected: false},
            {type: 'coin', row: 28, col: 45, points: 5, collected: false}
        ];

        // NPCs
        const townNPCs = [
            {row: 17, col: 20, dialogue: 'Welcome to Eldoria!', quest: false},
            {row: 23, col: 38, dialogue: 'Find 3 flowers for me!', quest: true}
        ];

        // Enemies
        const townEnemies = [
            {row: 18, col: 28, hp: 15, alive: true},
            {row: 25, col: 45, hp: 15, alive: true}
        ];

        // Princess
        let princess = {
            x: 2 * tileSize,
            y: 2 * tileSize,
            width: tileSize,
            height: tileSize,
            speed: 2,
            direction: 'down',
            frame: 0,
            animationCounter: 0
        };

        // Input handling
        const keys = {};
        document.addEventListener('keydown', e => keys[e.key] = true);
        document.addEventListener('keyup', e => keys[e.key] = false);

        // Scene definitions
        const scenes = {
            town: { map: townMap, offsetX: 0, offsetY: 0, items: townItems, npcs: townNPCs, enemies: townEnemies },
            castle: { map: castleMap, offsetX: 160, offsetY: 120, items: [], npcs: [], enemies: [] },
            house: { map: houseMap, offsetX: 160, offsetY: 120, items: [], npcs: [], enemies: [] }
        };

        // Transitions
        const transitions = {
            town: [
                {row: 10, col: 10, targetScene: 'castle', targetRow: 6, targetCol: 15},
                {row: 20, col: 40, targetScene: 'house', targetRow: 5, targetCol: 12}
            ],
            castle: [{row: 7, col: 15, targetScene: 'town', targetRow: 11, targetCol: 10}],
            house: [{row: 6, col: 12, targetScene: 'town', targetRow: 21, targetCol: 40}]
        };

        // Helper functions
        function isWalkable(x, y) {
            const scene = scenes[currentScene];
            const col = Math.floor((x + princess.width / 2) / tileSize);
            const row = Math.floor((y + princess.height / 2) / tileSize);
            if (row < 0 || row >= scene.map.length || col < 0 || col >= scene.map[0].length) return false;
            const type = scene.map[row][col];
            return ![2, 3, 6].includes(type); // Not water, mountain, or wall
        }

        function checkItems() {
            const items = scenes[currentScene].items;
            for (let item of items) {
                if (!item.collected && princess.tileRow === item.row && princess.tileCol === item.col) {
                    item.collected = true;
                    score += item.points;
                    if (questActive && item.type === 'flower') {
                        questItems++;
                        if (questItems === 3) {
                            score += 50;
                            questActive = false;
                            alert('Quest complete! +50 points!');
                        }
                    }
                }
            }
        }

        function checkNPCs() {
            const npcs = scenes[currentScene].npcs;
            for (let npc of npcs) {
                if (princess.tileRow === npc.row && princess.tileCol === npc.col && keys[' ']) {
                    alert(npc.dialogue);
                    if (npc.quest && !questActive) {
                        questActive = true;
                        questItems = 0;
                        alert('Quest: Collect 3 flowers!');
                    }
                }
            }
        }

        function checkEnemies() {
            const enemies = scenes[currentScene].enemies;
            for (let enemy of enemies) {
                if (enemy.alive && princess.tileRow === enemy.row && princess.tileCol === enemy.col) {
                    if (keys['Enter']) {
                        enemy.hp -= 5;
                        if (enemy.hp <= 0) {
                            enemy.alive = false;
                            score += 20;
                            alert('Enemy defeated! +20 points');
                        } else {
                            alert(`Enemy HP: ${enemy.hp}`);
                        }
                    } else if (!keys['Enter']) {
                        playerHP -= 2;
                        alert(`You took damage! HP: ${playerHP}`);
                        if (playerHP <= 0) {
                            alert('Game Over! Press any key to restart.');
                            resetGame();
                        }
                    }
                }
            }
        }

        function checkDoors() {
            const doors = transitions[currentScene];
            for (let door of doors) {
                if (princess.tileRow === door.row && princess.tileCol === door.col) {
                    targetScene = door.targetScene;
                    isFading = true;
                    fadeDirection = 1;
                }
            }
        }

        function resetGame() {
            score = 0;
            playerHP = 100;
            questActive = false;
            questItems = 0;
            townItems.forEach(item => item.collected = false);
            townEnemies.forEach(enemy => { enemy.hp = 15; enemy.alive = true; });
            princess.x = 2 * tileSize;
            princess.y = 2 * tileSize;
            currentScene = 'town';
        }

        function handleFade() {
            if (isFading) {
                fadeAlpha += 0.05 * fadeDirection;
                if (fadeAlpha >= 1 && fadeDirection === 1) {
                    currentScene = targetScene;
                    const door = transitions[targetScene].find(d => d.targetScene === currentScene) || transitions[currentScene][0];
                    princess.x = door.targetCol * tileSize;
                    princess.y = door.targetRow * tileSize;
                    fadeDirection = -1;
                } else if (fadeAlpha <= 0 && fadeDirection === -1) {
                    isFading = false;
                }
            }
        }

        // Drawing functions for NES-style detail
        function drawBackground() {
            // Sky and clouds
            ctx.fillStyle = colors.white;
            ctx.fillRect(0, 0, canvas.width, 100);
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 100, canvas.width, canvas.height - 100);
            ctx.fillStyle = colors.white;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(50 + i * 150, 50 + Math.random() * 20, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawMap(map, offsetX, offsetY) {
            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[r].length; c++) {
                    const x = c * tileSize + offsetX;
                    const y = r * tileSize + offsetY;
                    switch (map[r][c]) {
                        case 0: // Grass
                            ctx.fillStyle = colors.grass;
                            ctx.fillRect(x, y, tileSize, tileSize);
                            ctx.fillStyle = '#228b22';
                            for (let i = 0; i < 3; i++) {
                                ctx.fillRect(x + Math.random() * tileSize, y + Math.random() * tileSize, 1, 1);
                            }
                            break;
                        case 1: // Path
                            ctx.fillStyle = colors.path;
                            ctx.fillRect(x, y, tileSize, tileSize);
                            ctx.fillStyle = '#d2691e';
                            for (let i = 0; i < tileSize; i += 2) {
                                ctx.fillRect(x + i, y + i / 2, 1, 1);
                            }
                            break;
                        case 2: // Water
                            ctx.fillStyle = colors.water;
                            ctx.fillRect(x, y, tileSize, tileSize);
                            ctx.fillStyle = colors.white;
                            for (let i = 0; i < 2; i++) {
                                ctx.fillRect(x + Math.random() * tileSize, y + Math.random() * tileSize, 1, 1);
                            }
                            break;
                        case 3: // Mountain
                            ctx.fillStyle = colors.mountain;
                            ctx.fillRect(x, y, tileSize, tileSize);
                            ctx.fillStyle = '#696969';
                            for (let i = 0; i < tileSize; i += 2) {
                                ctx.fillRect(x + i, y + i / 2, 1, 1);
                            }
                            break;
                        case 4: // Door
                            ctx.fillStyle = colors.door;
                            ctx.fillRect(x, y, tileSize, tileSize);
                            ctx.fillStyle = '#00008b';
                            ctx.fillRect(x + 2, y + 2, tileSize - 4, tileSize - 4);
                            break;
                        case 5: // Floor
                            ctx.fillStyle = colors.floor;
                            ctx.fillRect(x, y, tileSize, tileSize);
                            ctx.fillStyle = '#a0522d';
                            for (let i = 0; i < tileSize; i += 4) {
                                ctx.fillRect(x + i, y + i / 2, 1, 1);
                            }
                            break;
                        case 6: // Wall
                            ctx.fillStyle = colors.wall;
                            ctx.fillRect(x, y, tileSize, tileSize);
                            ctx.fillStyle = '#696969';
                            for (let i = 0; i < tileSize; i += 4) {
                                ctx.fillRect(x, y + i, 1, 1);
                                ctx.fillRect(x + i, y, 1, tileSize);
                            }
                            break;
                        case 7: // Exit door
                            ctx.fillStyle = colors.exitDoor;
                            ctx.fillRect(x, y, tileSize, tileSize);
                            ctx.fillStyle = '#ff6347';
                            ctx.fillRect(x + 2, y + 2, tileSize - 4, tileSize - 4);
                            break;
                    }
                }
            }
            if (currentScene === 'town') {
                // Castle
                ctx.fillStyle = '#696969';
                ctx.fillRect(10 * tileSize, 5 * tileSize, tileSize * 5, tileSize * 3);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(10 * tileSize + 2, 5 * tileSize - tileSize / 2, tileSize * 5 - 4, tileSize / 2);
                // House
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(40 * tileSize, 15 * tileSize, tileSize * 3, tileSize * 2);
                ctx.fillStyle = '#cd853f';
                ctx.fillRect(40 * tileSize + 2, 15 * tileSize - tileSize / 2, tileSize * 3 - 4, tileSize / 2);
            }
        }

        function drawItems(items, offsetX, offsetY) {
            for (let item of items) {
                if (!item.collected) {
                    const x = item.col * tileSize + offsetX;
                    const y = item.row * tileSize + offsetY;
                    if (item.type === 'flower') {
                        ctx.fillStyle = colors.yellow;
                        ctx.beginPath();
                        ctx.arc(x + tileSize / 2, y + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#006400';
                        ctx.fillRect(x + tileSize / 2 - 1, y + tileSize / 2, 2, tileSize / 2 - 4);
                    } else {
                        ctx.fillStyle = '#ffa500';
                        ctx.beginPath();
                        ctx.arc(x + tileSize / 2, y + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = colors.yellow;
                        ctx.beginPath();
                        ctx.arc(x + tileSize / 2, y + tileSize / 2, tileSize / 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawNPCs(npcs, offsetX, offsetY) {
            for (let npc of npcs) {
                const x = npc.col * tileSize + offsetX;
                const y = npc.row * tileSize + offsetY;
                ctx.fillStyle = colors.npc;
                ctx.fillRect(x + 4, y + 4, 8, 8);
                ctx.fillStyle = colors.peach;
                ctx.beginPath();
                ctx.arc(x + 8, y + 4, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = colors.black;
                ctx.fillRect(x + 7, y + 2, 2, 2); // Eyes
            }
        }

        function drawEnemies(enemies, offsetX, offsetY) {
            for (let enemy of enemies) {
                if (enemy.alive) {
                    const x = enemy.col * tileSize + offsetX;
                    const y = enemy.row * tileSize + offsetY;
                    ctx.fillStyle = colors.enemy;
                    ctx.fillRect(x + 4, y + 4, 8, 8);
                    ctx.fillStyle = colors.black;
                    ctx.fillRect(x + 6, y + 6, 2, 2); // Eye
                    ctx.fillRect(x + 8, y + 12, 4, 2); // Feet
                }
            }
        }

        function drawPrincess(x, y) {
            princess.animationCounter++;
            if (princess.animationCounter % 10 === 0) {
                princess.frame = (princess.frame + 1) % 2;
            }
            ctx.fillStyle = colors.pink;
            ctx.fillRect(x + 4, y + 6, 8, 8); // Dress
            ctx.fillStyle = colors.peach;
            ctx.beginPath();
            ctx.arc(x + 8, y + 4, 4, 0, Math.PI * 2); // Head
            ctx.fill();
            ctx.fillStyle = colors.yellow;
            ctx.fillRect(x + 6, y, 4, 2); // Crown
            ctx.fillStyle = colors.black;
            if (princess.direction === 'down') {
                if (princess.frame === 0) {
                    ctx.fillRect(x + 4, y + 14, 2, 2);
                    ctx.fillRect(x + 10, y + 14, 2, 2);
                } else {
                    ctx.fillRect(x + 2, y + 14, 2, 2);
                    ctx.fillRect(x + 12, y + 14, 2, 2);
                }
            } else if (princess.direction === 'up') {
                ctx.fillRect(x + 6, y + 14, 2, 2);
                ctx.fillRect(x + 8, y + 14, 2, 2);
            } else if (princess.direction === 'left') {
                if (princess.frame === 0) {
                    ctx.fillRect(x + 4, y + 14, 2, 4);
                } else {
                    ctx.fillRect(x + 10, y + 14, 2, 4);
                }
            } else if (princess.direction === 'right') {
                if (princess.frame === 0) {
                    ctx.fillRect(x + 10, y + 14, 2, 4);
                } else {
                    ctx.fillRect(x + 4, y + 14, 2, 4);
                }
            }
        }

        function drawHUD() {
            ctx.fillStyle = '#00008b';
            ctx.fillRect(0, 0, 120, 40);
            ctx.fillStyle = colors.white;
            ctx.font = '12px Arial';
            ctx.fillText(`Score: ${score}`, 10, 20);
            ctx.fillText(`HP: ${playerHP}`, 10, 35);
            if (questActive) ctx.fillText(`Flowers: ${questItems}/3`, 60, 20);
        }

        // Game loop
        function gameLoop() {
            const scene = scenes[currentScene];
            princess.tileCol = Math.floor((princess.x + princess.width / 2) / tileSize);
            princess.tileRow = Math.floor((princess.y + princess.height / 2) / tileSize);

            if (!isFading) {
                let dx = 0, dy = 0;
                if (keys['ArrowLeft']) { dx -= princess.speed; princess.direction = 'left'; }
                if (keys['ArrowRight']) { dx += princess.speed; princess.direction = 'right'; }
                if (keys['ArrowUp']) { dy -= princess.speed; princess.direction = 'up'; }
                if (keys['ArrowDown']) { dy += princess.speed; princess.direction = 'down'; }

                const newX = princess.x + dx;
                const newY = princess.y + dy;
                if (isWalkable(newX, princess.y)) princess.x = newX;
                if (isWalkable(princess.x, newY)) princess.y = newY;

                checkItems();
                checkNPCs();
                checkEnemies();
                checkDoors();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawMap(scene.map, scene.offsetX, scene.offsetY);
            drawItems(scene.items, scene.offsetX, scene.offsetY);
            drawNPCs(scene.npcs, scene.offsetX, scene.offsetY);
            drawEnemies(scene.enemies, scene.offsetX, scene.offsetY);
            drawPrincess(princess.x + scene.offsetX, princess.y + scene.offsetY);
            drawHUD();
            handleFade();

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
